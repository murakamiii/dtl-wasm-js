#ifndef dtl_wandbox_hpp
#define dtl_wandbox_hpp
/*
  https://wandbox.org/permlink/ivYcDxESe8fB3N1I
*/
/*
Copyright (c) 2017-2019 Kasugaccho

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

#ifndef TN
#define TN typename
#endif
#ifndef NS
#define NS namespace
#endif
#ifndef CE
#define CE constexpr
#endif
#ifndef NE
#define NE noexcept
#endif
#ifndef RT
#define RT return
#endif
#ifndef TP
#define TP template
#endif
#ifndef IS
#define IS Index_Size
#endif
#ifndef MI
#define MI Matrix_Int_
#endif
#ifndef BL
#define BL bool
#endif
#ifndef CS
#define CS const
#endif
#ifndef IDTL_DTL
#define IDTL_DTL
#ifndef IDTL_DTL_DTL
#define IDTL_DTL_DTL
#ifndef DUNGEON_TEMPLATE_LIBRARY
#define DUNGEON_TEMPLATE_LIBRARY
#endif
#ifndef DUNGEON_TEMPLATE_LIBRARY_VERSION
#define DUNGEON_TEMPLATE_LIBRARY_VERSION (20190515L)
#endif
#ifndef NOT_IDTL_DTL_BASE
#ifndef IDTL_DTL_BASE
#define IDTL_DTL_BASE
#ifndef IDTL_DTL_BASE_STRUCT
#define IDTL_DTL_BASE_STRUCT
#ifndef IDTL_DTL_TYPE_SIZE_T
#define IDTL_DTL_TYPE_SIZE_T
#if defined(UE_BUILD_FINAL_RELEASE) 
NS dtl { NS type { using size = ::SIZE_T; } }
#else
#include <cstddef>
NS dtl { NS type { using size = std::size_t; } }
#endif
#endif 
NS dtl {
inline NS base {
TP<TN Int_>
struct Coordinate1Dimensional {
Int_ x{};
CE Coordinate1Dimensional() NE = default;
CE Coordinate1Dimensional(CS Int_& x_) NE :x(x_) {};
};
TP<TN Int_>
struct Coordinate2Dimensional {
Int_ x{};
Int_ y{};
CE Coordinate2Dimensional() NE = default;
CE Coordinate2Dimensional(CS Int_& x_, CS Int_& y_) NE :x(x_), y(y_) {};
CE BL operator==(CS dtl::base::Coordinate2Dimensional<Int_>& vec2_) CS NE {
RT vec2_.x == this->x && vec2_.y == this->y;
}
CE BL operator!=(CS dtl::base::Coordinate2Dimensional<Int_>& vec2_) CS NE {
RT vec2_.x != this->x || vec2_.y != this->y;
}
};
using MatrixVec2 = Coordinate2Dimensional<dtl::type::size>;
TP<TN Int_>
struct Coordinate2DimensionalAndLength2Dimensional {
Int_ x{};
Int_ y{};
Int_ w{};
Int_ h{};
CE Coordinate2DimensionalAndLength2Dimensional() NE = default;
CE Coordinate2DimensionalAndLength2Dimensional(CS Int_& x_, CS Int_& y_) NE
:x(x_), y(y_) {};
CE Coordinate2DimensionalAndLength2Dimensional(CS Int_& x_, CS Int_& y_, CS Int_& l_) NE
:x(x_), y(y_), w(l_), h(l_) {};
CE Coordinate2DimensionalAndLength2Dimensional(CS Int_& x_, CS Int_& y_, CS Int_& w_, CS Int_& h_) NE
:x(x_), y(y_), w(w_), h(h_) {};
CE BL operator==(CS dtl::base::Coordinate2DimensionalAndLength2Dimensional<Int_>& range_) CS NE {
RT range_.x == this->x && range_.y == this->y && range_.w == this->w && range_.h == this->h;
}
CE BL operator!=(CS dtl::base::Coordinate2DimensionalAndLength2Dimensional<Int_>& range_) CS NE {
RT range_.x != this->x || range_.y != this->y || range_.w != this->w || range_.h != this->h;
}
CE BL operator>(CS dtl::base::Coordinate2DimensionalAndLength2Dimensional<Int_>& range_) CS NE {
RT (this->w * this->h) > (range_.w * range_.h);
}
CE BL operator>=(CS dtl::base::Coordinate2DimensionalAndLength2Dimensional<Int_>& range_) CS NE {
RT (this->w * this->h) >= (range_.w * range_.h);
}
CE BL operator<(CS dtl::base::Coordinate2DimensionalAndLength2Dimensional<Int_>& range_) CS NE {
RT (this->w * this->h) < (range_.w * range_.h);
}
CE BL operator<=(CS dtl::base::Coordinate2DimensionalAndLength2Dimensional<Int_>& range_) CS NE {
RT (this->w * this->h) <= (range_.w * range_.h);
}
};
using MatrixRange = Coordinate2DimensionalAndLength2Dimensional<dtl::type::size>;
}
}
#endif 
#endif 
#endif 
#ifndef NOT_IDTL_DTL_BOARD
#ifndef IDTL_DTL_BOARD
#define IDTL_DTL_BOARD
#ifndef IDTL_DTL_BOARD_WRITE_NUMBER
#define IDTL_DTL_BOARD_WRITE_NUMBER
#include <sstream>
#include <string>
#ifndef IDTL_DTL_MACROS_CONSTEXPR
#define IDTL_DTL_MACROS_CONSTEXPR
#ifndef DVCC
#if defined(_MSC_VER)
#if (_MSC_VER <= 1900)
#define DVCC
#elif defined(_MSC_VER) && defined(_MSVC_LANG)
#if (_MSVC_LANG >= 201402L)
#define DVCC CE
#endif
#endif
#elif defined(__cplusplus)
#if (__cplusplus >= 201402L)
#define DVCC CE
#endif
#endif
#endif
#ifndef DVCC
#define DVCC
#endif
#endif 
#ifndef IDTL_DTL_MACROS_NODISCARD
#define IDTL_DTL_MACROS_NODISCARD
#ifndef DVCN
#ifdef __has_cpp_attribute
#if __has_cpp_attribute(nodiscard)
#define DVCN [[nodiscard]]
#endif
#elif defined(__clang__)
#define DVCN __attribute__((warn_unused_result))
#elif defined(_MSC_VER)
#define DVCN                                                                                                                                                                                                                                                                                                \
__declspec("SAL_name"                                                                                                                                                                                                                                                                                                        \
"("                                                                                                                                                                                                                                                                                                               \
"\"_Must_inspect_result_\""                                                                                                                                                                                                                                                                                       \
","                                                                                                                                                                                                                                                                                                               \
"\"\""                                                                                                                                                                                                                                                                                                            \
","                                                                                                                                                                                                                                                                                                               \
"\"2\""                                                                                                                                                                                                                                                                                                           \
")") __declspec("SAL_begin") __declspec("SAL_post") __declspec("SAL_mustInspect") __declspec("SAL_post") __declspec("SAL_checkReturn") __declspec("SAL_end")
#endif
#endif
#ifndef DVCN
#define DVCN
#endif
#endif
#ifndef IDTL_DTL_TYPE_FORWARD
#define IDTL_DTL_TYPE_FORWARD
#ifndef DTL_TYPE_FORWARD
#if defined(UE_BUILD_FINAL_RELEASE) 
#define DTL_TYPE_FORWARD ::Forward
#else
#include <utility>
#define DTL_TYPE_FORWARD std::forward
#endif
#endif
#endif 
#ifndef IDTL_DTL_UTILITY_IS_OUTPUT_CAST
#define IDTL_DTL_UTILITY_IS_OUTPUT_CAST
NS dtl {
inline NS utility {
TP<TN Int_>
DVCN
CE BL isOutputCast() NE {
RT false;
}
TP<>
DVCN
CE BL isOutputCast<char>() NE {
RT true;
}
TP<>
DVCN
CE BL isOutputCast<signed char>() NE {
RT true;
}
TP<>
DVCN
CE BL isOutputCast<unsigned char>() NE {
RT true;
}
}
}
#endif 
NS dtl {
inline NS board {
TP<TN MI, TN OutputChar_ = char>
class WriteNumber {
private:
using IS = dtl::type::size;
using OutputString_ = std::basic_string<OutputChar_>;
using OutputStream_ = std::basic_stringstream<OutputChar_>;
IS start_x{};
IS start_y{};
IS width{};
IS height{};
OutputString_ draw_string{};
OutputString_ before_draw_string{};
OutputString_ new_line_string{};
TP<TN Matrix_>
DVCC
inline void outputSTL(CS Matrix_& matrix_, CS IS point_x_, CS IS point_y_, OutputString_& string_) CS NE {
OutputStream_ stream_{};
stream_ << this->before_draw_string << ((dtl::utility::isOutputCast<MI>()) ? static_cast<int>(matrix_[point_y_][point_x_]) : matrix_[point_y_][point_x_]) << this->draw_string;
string_ += stream_.str();
}
TP<TN Matrix_>
DVCC
inline void outputArray(CS Matrix_& matrix_, CS IS point_x_, CS IS point_y_, CS IS max_x_, OutputString_& string_) CS NE {
OutputStream_ stream_{};
stream_ << this->before_draw_string << ((dtl::utility::isOutputCast<MI>()) ? static_cast<int>(matrix_[point_y_ * max_x_ + point_x_]) : matrix_[point_y_ * max_x_ + point_x_]) << this->draw_string;
string_ += stream_.str();
}
TP<TN Matrix_>
DVCC
inline void outputLayer(CS Matrix_& matrix_, CS IS layer_, CS IS point_x_, CS IS point_y_, OutputString_& string_) CS NE {
OutputStream_ stream_{};
stream_ << this->before_draw_string << ((dtl::utility::isOutputCast<MI>()) ? static_cast<int>(matrix_[point_y_][point_x_][layer_]) : matrix_[point_y_][point_x_][layer_]) << this->draw_string;
string_ += stream_.str();
}
TP<TN Matrix_Value_>
DVCC
inline void outputList(CS Matrix_Value_& matrix_, OutputString_& string_) CS NE {
OutputStream_ stream_{};
stream_ << this->before_draw_string << ((dtl::utility::isOutputCast<MI>()) ? static_cast<int>(matrix_) : matrix_) << this->draw_string;
string_ += stream_.str();
}
TP<TN Matrix_>
BL drawSTL(CS Matrix_ & matrix_, CS IS end_y_, OutputString_& string_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i) {
for (IS j{ this->start_x }; j < matrix_[i].size(); ++j)
this->outputSTL(matrix_, j, i, string_);
string_ += this->new_line_string;
}
RT true;
}
TP<TN Matrix_>
BL drawWidthSTL(CS Matrix_ & matrix_, CS IS end_x_, CS IS end_y_, OutputString_& string_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i) {
for (IS j{ this->start_x }; j < matrix_[i].size() && j < end_x_; ++j)
this->outputSTL(matrix_, j, i, string_);
string_ += this->new_line_string;
}
RT true;
}
TP<TN Matrix_>
BL drawLayerSTL(CS Matrix_ & matrix_, CS IS layer_, CS IS end_y_, OutputString_& string_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i) {
for (IS j{ this->start_x }; j < matrix_[i].size(); ++j)
this->outputLayer(matrix_, layer_, j, i, string_);
string_ += this->new_line_string;
}
RT true;
}
TP<TN Matrix_>
BL drawLayerWidthSTL(CS Matrix_ & matrix_, CS IS layer_, CS IS end_x_, CS IS end_y_, OutputString_& string_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i) {
for (IS j{ this->start_x }; j < matrix_[i].size() && j < end_x_; ++j)
this->outputLayer(matrix_, layer_, j, i, string_);
string_ += this->new_line_string;
}
RT true;
}
TP<TN Matrix_>
BL drawNormal(CS Matrix_ & matrix_, CS IS end_x_, CS IS end_y_, OutputString_& string_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i) {
for (IS j{ this->start_x }; j < end_x_; ++j)
this->outputSTL(matrix_, j, i, string_);
string_ += this->new_line_string;
}
RT true;
}
TP<TN Matrix_>
BL drawLayerNormal(CS Matrix_ & matrix_, CS IS layer_, CS IS end_x_, CS IS end_y_, OutputString_& string_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i) {
for (IS j{ this->start_x }; j < end_x_; ++j)
this->outputLayer(matrix_, layer_, j, i, string_);
string_ += this->new_line_string;
}
RT true;
}
TP<TN Matrix_>
BL drawArray(CS Matrix_ & matrix_, CS IS end_x_, CS IS end_y_, CS IS max_x_, OutputString_& string_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i) {
for (IS j{ this->start_x }; j < end_x_; ++j)
this->outputArray(matrix_, j, i, max_x_, string_);
string_ += this->new_line_string;
}
RT true;
}
TP<TN Matrix_>
BL drawList(CS Matrix_ & matrix_, CS IS end_x_, CS IS end_y_, OutputString_& string_) CS NE {
dtl::type::size row_count{}, col_count{};
for (CS auto& i : matrix_) {
++row_count;
if (row_count <= this->start_y) continue;
if (end_y_ != 1 && row_count >= end_y_) break;
col_count = 0;
for (CS auto& j : i) {
++col_count;
if (col_count <= this->start_x) continue;
if (end_x_ != 1 && col_count >= end_x_) break;
this->outputList(j, string_);
}
string_ += this->new_line_string;
}
RT true;
}
public:
DVCN
CE IS getPointX() CS NE {
RT this->start_x;
}
DVCN
CE IS getPointY() CS NE {
RT this->start_y;
}
DVCN
CE IS getWidth() CS NE {
RT this->width;
}
DVCN
CE IS getHeight() CS NE {
RT this->height;
}
TP<TN Matrix_>
BL draw(CS Matrix_ & matrix_, OutputString_& string_) CS NE {
RT (this->width == 0) ? this->drawSTL(matrix_, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, string_) : this->drawWidthSTL(matrix_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, string_);
}
TP<TN Matrix_>
BL draw(CS Matrix_ & matrix_, CS IS layer_, OutputString_& string_) CS NE {
RT (this->width == 0) ? this->drawLayerSTL(matrix_, layer_, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, string_) : this->drawLayerWidthSTL(matrix_, layer_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, string_);
}
TP<TN Matrix_>
BL draw(CS Matrix_ & matrix_, CS IS max_x_, CS IS max_y_, OutputString_& string_) CS NE {
RT this->drawNormal(matrix_, (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, string_);
}
TP<TN Matrix_>
BL draw(CS Matrix_ & matrix_, CS IS layer_, CS IS max_x_, CS IS max_y_, OutputString_& string_) CS NE {
RT this->drawLayerNormal(matrix_, layer_, (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, string_);
}
TP<TN Matrix_>
BL drawArray(CS Matrix_ & matrix_, CS IS max_x_, CS IS max_y_, OutputString_& string_) CS NE {
RT this->drawArray(matrix_, (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, max_x_, string_);
}
TP<TN Matrix_>
BL drawList(CS Matrix_ & matrix_, OutputString_& string_) CS NE {
RT this->drawList(matrix_, this->start_x + this->width + 1, this->start_y + this->height + 1, string_);
}
TP<TN Matrix_, TN ...Args_>
CE BL operator()(CS Matrix_ & matrix_, Args_ && ... args_) CS NE {
RT this->draw(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& create(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->draw(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createArray(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->drawArray(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
DVCC
WriteNumber& clearPointX() NE {
this->start_x = 0;
RT *this;
}
DVCC
WriteNumber& clearPointY() NE {
this->start_y = 0;
RT *this;
}
DVCC
WriteNumber& clearWidth() NE {
this->width = 0;
RT *this;
}
DVCC
WriteNumber& clearHeight() NE {
this->height = 0;
RT *this;
}
DVCC
WriteNumber& clearPoint() NE {
this->clearPointX();
this->clearPointY();
RT *this;
}
DVCC
WriteNumber& clearRange() NE {
this->clearPointX();
this->clearPointY();
this->clearWidth();
this->clearHeight();
RT *this;
}
DVCC
WriteNumber& clear() NE {
this->clearRange();
RT *this;
}
DVCC
WriteNumber& setPointX(CS IS start_x_) NE {
this->start_x = start_x_;
RT *this;
}
DVCC
WriteNumber& setPointY(CS IS start_y_) NE {
this->start_y = start_y_;
RT *this;
}
DVCC
WriteNumber& setWidth(CS IS width_) NE {
this->width = width_;
RT *this;
}
DVCC
WriteNumber& setHeight(CS IS height_) NE {
this->height = height_;
RT *this;
}
DVCC
WriteNumber& setPoint(CS IS point_) NE {
this->start_x = point_;
this->start_y = point_;
RT *this;
}
DVCC
WriteNumber& setPoint(CS IS start_x_, CS IS start_y_) NE {
this->start_x = start_x_;
this->start_y = start_y_;
RT *this;
}
DVCC
WriteNumber& setRange(CS IS start_x_, CS IS start_y_, CS IS length_) NE {
this->start_x = start_x_;
this->start_y = start_y_;
this->width = length_;
this->height = length_;
RT *this;
}
DVCC
WriteNumber& setRange(CS IS start_x_, CS IS start_y_, CS IS width_, CS IS height_) NE {
this->start_x = start_x_;
this->start_y = start_y_;
this->width = width_;
this->height = height_;
RT *this;
}
DVCC
WriteNumber& setRange(CS dtl::base::MatrixRange & matrix_range_) NE {
this->start_x = matrix_range_.x;
this->start_y = matrix_range_.y;
this->width = matrix_range_.w;
this->height = matrix_range_.h;
RT *this;
}
CE WriteNumber() NE = default;
CE explicit WriteNumber(CS OutputString_& new_line_string_) NE
:new_line_string(new_line_string_) {}
CE explicit WriteNumber(CS OutputString_& new_line_string_, CS OutputString_& draw_string_) NE
:new_line_string(new_line_string_), draw_string(draw_string_) {}
CE explicit WriteNumber(CS OutputString_& new_line_string_, CS OutputString_ & before_draw_string_, CS OutputString_ & draw_string_) NE
:new_line_string(new_line_string_), draw_string(draw_string_), before_draw_string(before_draw_string_) {}
CE WriteNumber(CS dtl::base::MatrixRange & matrix_range_)
: start_x(matrix_range_.x), start_y(matrix_range_.y),
width(matrix_range_.w), height(matrix_range_.h) {}
CE explicit WriteNumber(CS dtl::base::MatrixRange& matrix_range_, CS OutputString_& new_line_string_) NE
:start_x(matrix_range_.x), start_y(matrix_range_.y),
width(matrix_range_.w), height(matrix_range_.h), new_line_string(new_line_string_) {}
CE explicit WriteNumber(CS dtl::base::MatrixRange & matrix_range_, CS OutputString_& new_line_string_, CS OutputString_ & draw_string_) NE
:start_x(matrix_range_.x), start_y(matrix_range_.y),
width(matrix_range_.w), height(matrix_range_.h), new_line_string(new_line_string_), draw_string(draw_string_) {}
CE explicit WriteNumber(CS dtl::base::MatrixRange & matrix_range_, CS OutputString_& new_line_string_, CS OutputString_ & before_draw_string_, CS OutputString_ & draw_string_) NE
:start_x(matrix_range_.x), start_y(matrix_range_.y),
width(matrix_range_.w), height(matrix_range_.h), new_line_string(new_line_string_), draw_string(draw_string_), before_draw_string(before_draw_string_) {}
CE explicit WriteNumber(CS IS start_x_, CS IS start_y_, CS IS width_, CS IS height_) NE
:start_x(start_x_), start_y(start_y_),
width(width_), height(height_) {}
CE explicit WriteNumber(CS IS start_x_, CS IS start_y_, CS IS width_, CS IS height_, CS OutputString_& new_line_string_) NE
:start_x(start_x_), start_y(start_y_),
width(width_), height(height_),
new_line_string(new_line_string_) {}
CE explicit WriteNumber(CS IS start_x_, CS IS start_y_, CS IS width_, CS IS height_, CS OutputString_& new_line_string_, CS OutputString_ & draw_string_) NE
:start_x(start_x_), start_y(start_y_),
width(width_), height(height_),
new_line_string(new_line_string_), draw_string(draw_string_) {}
CE explicit WriteNumber(CS IS start_x_, CS IS start_y_, CS IS width_, CS IS height_, CS OutputString_& new_line_string_, CS OutputString_ & before_draw_string_, CS OutputString_ & draw_string_) NE
:start_x(start_x_), start_y(start_y_),
width(width_), height(height_),
new_line_string(new_line_string_), draw_string(draw_string_), before_draw_string(before_draw_string_) {}
};
}
}
#endif 
#endif 
#endif 
#ifndef NOT_IDTL_DTL_CONSOLE
#ifndef IDTL_DTL_CONSOLE
#define IDTL_DTL_CONSOLE
#ifndef IDTL_DTL_CONSOLE_OUTPUT_NUMBER
#define IDTL_DTL_CONSOLE_OUTPUT_NUMBER
#include <iostream>
#include <string>
NS dtl {
inline NS console {
TP<TN MI, TN OutputString_ = std::string>
class OutputNumber {
private:
using IS = dtl::type::size;
IS start_x{};
IS start_y{};
IS width{};
IS height{};
OutputString_ after_string{};
OutputString_ before_string{};
TP<TN Matrix_>
DVCC
inline void outputSTL(CS Matrix_& matrix_, CS IS point_x_, CS IS point_y_) CS NE {
std::cout << this->before_string << ((dtl::utility::isOutputCast<MI>()) ? static_cast<int>(matrix_[point_y_][point_x_]) : matrix_[point_y_][point_x_]) << this->after_string;
}
TP<TN Matrix_>
DVCC
inline void outputArray(CS Matrix_ & matrix_, CS IS point_x_, CS IS point_y_, CS IS max_x_) CS NE {
std::cout << this->before_string << ((dtl::utility::isOutputCast<MI>()) ? static_cast<int>(matrix_[point_y_ * max_x_ + point_x_]) : matrix_[point_y_ * max_x_ + point_x_]) << this->after_string;
}
TP<TN Matrix_>
DVCC
inline void outputLayer(CS Matrix_ & matrix_, CS IS layer_, CS IS point_x_, CS IS point_y_) CS NE {
std::cout << this->before_string << ((dtl::utility::isOutputCast<MI>()) ? static_cast<int>(matrix_[point_y_][point_x_][layer_]) : matrix_[point_y_][point_x_][layer_]) << this->after_string;
}
TP<TN Matrix_Value_>
DVCC
inline void outputList(CS Matrix_Value_& matrix_) CS NE {
std::cout << this->before_string << ((dtl::utility::isOutputCast<MI>()) ? static_cast<int>(matrix_) : matrix_) << this->after_string;
}
TP<TN Matrix_>
BL drawSTL(CS Matrix_ & matrix_, CS IS end_y_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i) {
for (IS j{ this->start_x }; j < matrix_[i].size(); ++j)
this->outputSTL(matrix_, j, i);
std::cout << '\n';
}
RT true;
}
TP<TN Matrix_>
BL drawWidthSTL(CS Matrix_ & matrix_, CS IS end_x_, CS IS end_y_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i) {
for (IS j{ this->start_x }; j < matrix_[i].size() && j < end_x_; ++j)
this->outputSTL(matrix_, j, i);
std::cout << '\n';
}
RT true;
}
TP<TN Matrix_>
BL drawLayerSTL(CS Matrix_ & matrix_, CS IS layer_, CS IS end_y_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i) {
for (IS j{ this->start_x }; j < matrix_[i].size(); ++j)
this->outputLayer(matrix_, layer_, j, i);
std::cout << '\n';
}
RT true;
}
TP<TN Matrix_>
BL drawLayerWidthSTL(CS Matrix_ & matrix_, CS IS layer_, CS IS end_x_, CS IS end_y_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i) {
for (IS j{ this->start_x }; j < matrix_[i].size() && j < end_x_; ++j)
this->outputLayer(matrix_, layer_, j, i);
std::cout << '\n';
}
RT true;
}
TP<TN Matrix_>
BL drawNormal(CS Matrix_ & matrix_, CS IS end_x_, CS IS end_y_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i) {
for (IS j{ this->start_x }; j < end_x_; ++j)
this->outputSTL(matrix_, j, i);
std::cout << '\n';
}
RT true;
}
TP<TN Matrix_>
BL drawLayerNormal(CS Matrix_ & matrix_, CS IS layer_, CS IS end_x_, CS IS end_y_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i) {
for (IS j{ this->start_x }; j < end_x_; ++j)
this->outputLayer(matrix_, layer_, j, i);
std::cout << '\n';
}
RT true;
}
TP<TN Matrix_>
BL drawArray(CS Matrix_ & matrix_, CS IS end_x_, CS IS end_y_, CS IS max_x_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i) {
for (IS j{ this->start_x }; j < end_x_; ++j)
this->outputArray(matrix_, j, i, max_x_);
std::cout << '\n';
}
RT true;
}
TP<TN Matrix_>
BL drawList(CS Matrix_& matrix_, CS IS end_x_, CS IS end_y_) CS NE {
dtl::type::size row_count{}, col_count{};
for (CS auto& i : matrix_) {
++row_count;
if (row_count <= this->start_y) continue;
if (end_y_ != 1 && row_count >= end_y_) break;
col_count = 0;
for (CS auto& j : i) {
++col_count;
if (col_count <= this->start_x) continue;
if (end_x_ != 1 && col_count >= end_x_) break;
this->outputList(j);
}
std::cout << '\n';
}
RT true;
}
public:
DVCN
CE IS getPointX() CS NE {
RT this->start_x;
}
DVCN
CE IS getPointY() CS NE {
RT this->start_y;
}
DVCN
CE IS getWidth() CS NE {
RT this->width;
}
DVCN
CE IS getHeight() CS NE {
RT this->height;
}
DVCN
CE OutputString_ getAfterString() CS NE {
RT this->after_string;
}
DVCN
CE OutputString_ getBeforeString() CS NE {
RT this->before_string;
}
TP<TN Matrix_>
BL draw(CS Matrix_ & matrix_) CS NE {
RT (this->width == 0) ? this->drawSTL(matrix_, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height) : this->drawWidthSTL(matrix_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height);
}
TP<TN Matrix_>
BL draw(CS Matrix_ & matrix_, CS IS layer_) CS NE {
RT (this->width == 0) ? this->drawLayerSTL(matrix_, layer_, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height) : this->drawLayerWidthSTL(matrix_, layer_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height);
}
TP<TN Matrix_>
BL draw(CS Matrix_ & matrix_, CS IS max_x_, CS IS max_y_) CS NE {
RT this->drawNormal(matrix_, (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height);
}
TP<TN Matrix_>
BL draw(CS Matrix_ & matrix_, CS IS layer_, CS IS max_x_, CS IS max_y_) CS NE {
RT this->drawLayerNormal(matrix_, layer_, (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height);
}
TP<TN Matrix_>
BL drawArray(CS Matrix_ & matrix_, CS IS max_x_, CS IS max_y_) CS NE {
RT this->drawArray(matrix_, (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, max_x_);
}
TP<TN Matrix_>
BL drawList(CS Matrix_& matrix_) CS NE {
RT this->drawList(matrix_, this->start_x + this->width + 1, this->start_y + this->height + 1);
}
TP<TN Matrix_, TN ...Args_>
CE BL operator()(CS Matrix_& matrix_, Args_&& ... args_) CS NE {
RT this->draw(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& create(Matrix_&& matrix_, Args_&& ... args_) CS NE {
this->draw(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createArray(Matrix_&& matrix_, Args_&& ... args_) CS NE {
this->drawArray(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
DVCC
OutputNumber& clearPointX() NE {
this->start_x = 0;
RT *this;
}
DVCC
OutputNumber& clearPointY() NE {
this->start_y = 0;
RT *this;
}
DVCC
OutputNumber& clearWidth() NE {
this->width = 0;
RT *this;
}
DVCC
OutputNumber& clearHeight() NE {
this->height = 0;
RT *this;
}
DVCC
OutputNumber& clearPoint() NE {
this->clearPointX();
this->clearPointY();
RT *this;
}
DVCC
OutputNumber& clearRange() NE {
this->clearPointX();
this->clearPointY();
this->clearWidth();
this->clearHeight();
RT *this;
}
DVCC
OutputNumber& clearAfterString() NE {
OutputString_ output_string{};
this->after_string = output_string;
RT *this;
}
DVCC
OutputNumber& clearBeforeString() NE {
OutputString_ output_string{};
this->before_string = output_string;
RT *this;
}
DVCC
OutputNumber& clearString() NE {
this->clearAfterString();
this->clearBeforeString();
RT *this;
}
DVCC
OutputNumber& clear() NE {
this->clearRange();
this->clearString();
RT *this;
}
DVCC
OutputNumber& setPointX(CS IS start_x_) NE {
this->start_x = start_x_;
RT *this;
}
DVCC
OutputNumber& setPointY(CS IS start_y_) NE {
this->start_y = start_y_;
RT *this;
}
DVCC
OutputNumber& setWidth(CS IS width_) NE {
this->width = width_;
RT *this;
}
DVCC
OutputNumber& setHeight(CS IS height_) NE {
this->height = height_;
RT *this;
}
DVCC
OutputNumber& setPoint(CS IS point_) NE {
this->start_x = point_;
this->start_y = point_;
RT *this;
}
DVCC
OutputNumber& setPoint(CS IS start_x_, CS IS start_y_) NE {
this->start_x = start_x_;
this->start_y = start_y_;
RT *this;
}
DVCC
OutputNumber& setRange(CS IS start_x_, CS IS start_y_, CS IS length_) NE {
this->start_x = start_x_;
this->start_y = start_y_;
this->width = length_;
this->height = length_;
RT *this;
}
DVCC
OutputNumber& setRange(CS IS start_x_, CS IS start_y_, CS IS width_, CS IS height_) NE {
this->start_x = start_x_;
this->start_y = start_y_;
this->width = width_;
this->height = height_;
RT *this;
}
DVCC
OutputNumber& setRange(CS dtl::base::MatrixRange& matrix_range_) NE {
this->start_x = matrix_range_.x;
this->start_y = matrix_range_.y;
this->width = matrix_range_.w;
this->height = matrix_range_.h;
RT *this;
}
DVCC
OutputNumber& setAfterString(CS OutputString_& output_string_) NE {
this->after_string = output_string_;
RT *this;
}
DVCC
OutputNumber& setBeforeString(CS OutputString_& output_string_) NE {
this->before_string = output_string_;
RT *this;
}
CE OutputNumber() NE = default;
CE explicit OutputNumber(CS OutputString_ & draw_string_) NE
:after_string(draw_string_) {}
CE explicit OutputNumber(CS OutputString_ & before_draw_string_, CS OutputString_ & draw_string_) NE
:after_string(draw_string_), before_string(before_draw_string_) {}
CE OutputNumber(CS dtl::base::MatrixRange& matrix_range_)
: start_x(matrix_range_.x), start_y(matrix_range_.y),
width(matrix_range_.w), height(matrix_range_.h) {}
CE explicit OutputNumber(CS dtl::base::MatrixRange& matrix_range_, CS OutputString_& draw_string_) NE
:start_x(matrix_range_.x), start_y(matrix_range_.y),
width(matrix_range_.w), height(matrix_range_.h), after_string(draw_string_) {}
CE explicit OutputNumber(CS dtl::base::MatrixRange& matrix_range_, CS OutputString_& before_draw_string_, CS OutputString_& draw_string_) NE
:start_x(matrix_range_.x), start_y(matrix_range_.y),
width(matrix_range_.w), height(matrix_range_.h), after_string(draw_string_), before_string(before_draw_string_) {}
CE explicit OutputNumber(CS IS start_x_, CS IS start_y_, CS IS width_, CS IS height_) NE
:start_x(start_x_), start_y(start_y_),
width(width_), height(height_) {}
CE explicit OutputNumber(CS IS start_x_, CS IS start_y_, CS IS width_, CS IS height_, CS OutputString_ & draw_string_) NE
:start_x(start_x_), start_y(start_y_),
width(width_), height(height_),
after_string(draw_string_) {}
CE explicit OutputNumber(CS IS start_x_, CS IS start_y_, CS IS width_, CS IS height_, CS OutputString_ & before_draw_string_, CS OutputString_ & draw_string_) NE
:start_x(start_x_), start_y(start_y_),
width(width_), height(height_),
after_string(draw_string_), before_string(before_draw_string_) {}
};
}
}
#endif 
#ifndef IDTL_DTL_CONSOLE_OUTPUT_STRING
#define IDTL_DTL_CONSOLE_OUTPUT_STRING
#include <iostream>
#include <string>
#include <vector>
NS dtl {
inline NS console {
TP<TN MI, TN OutputStringName_ = std::string>
class OutputString {
private:
using IS = dtl::type::size;
IS start_x{};
IS start_y{};
IS width{};
IS height{};
std::vector<OutputStringName_> string_vector{};
DVCC
void string_String() CS NE {}
TP<TN ...Args_>
DVCC
void string_String(CS OutputStringName_& first_, CS Args_& ... args_) NE {
this->string_vector.emplace_back(first_);
this->string_String(args_...);
}
TP<TN Matrix_>
DVCN
CE inline dtl::type::size outputSTL(CS Matrix_& matrix_, CS IS point_x_, CS IS point_y_) CS NE {
RT static_cast<dtl::type::size>(matrix_[point_y_][point_x_]);
}
TP<TN Matrix_>
DVCN
CE inline dtl::type::size outputArray(CS Matrix_& matrix_, CS IS point_x_, CS IS point_y_, CS IS max_x_) CS NE {
RT static_cast<dtl::type::size>(matrix_[point_y_ * max_x_ + point_x_]);
}
TP<TN Matrix_>
DVCN
CE inline dtl::type::size outputLayer(CS Matrix_ & matrix_, CS IS layer_, CS IS point_x_, CS IS point_y_) CS NE {
RT static_cast<dtl::type::size>(matrix_[point_y_][point_x_][layer_]);
}
TP<TN Matrix_>
DVCN
CE inline dtl::type::size outputList(CS Matrix_& matrix_) CS NE {
RT static_cast<dtl::type::size>(matrix_);
}
TP<TN Matrix_>
BL drawSTL(CS Matrix_ & matrix_, CS IS end_y_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i) {
for (IS j{ this->start_x }; j < matrix_[i].size(); ++j) {
if (this->outputSTL(matrix_, j, i) >= this->string_vector.size()) continue;
std::cout << this->string_vector[this->outputSTL(matrix_, j, i)];
}
std::cout << '\n';
}
RT true;
}
TP<TN Matrix_>
BL drawWidthSTL(CS Matrix_ & matrix_, CS IS end_x_, CS IS end_y_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i) {
for (IS j{ this->start_x }; j < matrix_[i].size() && j < end_x_; ++j) {
if (this->outputSTL(matrix_, j, i) >= this->string_vector.size()) continue;
std::cout << this->string_vector[this->outputSTL(matrix_, j, i)];
}
std::cout << '\n';
}
RT true;
}
TP<TN Matrix_>
BL drawLayerSTL(CS Matrix_ & matrix_, CS IS layer_, CS IS end_y_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i) {
for (IS j{ this->start_x }; j < matrix_[i].size(); ++j) {
if (this->outputLayer(matrix_, layer_, j, i) >= this->string_vector.size()) continue;
std::cout << this->string_vector[this->outputLayer(matrix_, layer_, j, i)];
}
std::cout << '\n';
}
RT true;
}
TP<TN Matrix_>
BL drawLayerWidthSTL(CS Matrix_ & matrix_, CS IS layer_, CS IS end_x_, CS IS end_y_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i) {
for (IS j{ this->start_x }; j < matrix_[i].size() && j < end_x_; ++j) {
if (this->outputLayer(matrix_, layer_, j, i) >= this->string_vector.size()) continue;
std::cout << this->string_vector[this->outputLayer(matrix_, layer_, j, i)];
}
std::cout << '\n';
}
RT true;
}
TP<TN Matrix_>
BL drawNormal(CS Matrix_ & matrix_, CS IS end_x_, CS IS end_y_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i) {
for (IS j{ this->start_x }; j < end_x_; ++j) {
if (this->outputSTL(matrix_, j, i) >= this->string_vector.size()) continue;
std::cout << this->string_vector[this->outputSTL(matrix_, j, i)];
}
std::cout << '\n';
}
RT true;
}
TP<TN Matrix_>
BL drawLayerNormal(CS Matrix_ & matrix_, CS IS layer_, CS IS end_x_, CS IS end_y_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i) {
for (IS j{ this->start_x }; j < end_x_; ++j) {
if (this->outputLayer(matrix_, layer_, j, i) >= this->string_vector.size()) continue;
std::cout << this->string_vector[this->outputLayer(matrix_, layer_, j, i)];
}
std::cout << '\n';
}
RT true;
}
TP<TN Matrix_>
BL drawArray(CS Matrix_ & matrix_, CS IS end_x_, CS IS end_y_, CS IS max_x_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i) {
for (IS j{ this->start_x }; j < end_x_; ++j) {
if (this->outputArray(matrix_, j, i, max_x_) >= this->string_vector.size()) continue;
std::cout << this->string_vector[this->outputArray(matrix_, j, i, max_x_)];
}
std::cout << '\n';
}
RT true;
}
TP<TN Matrix_>
BL drawList(CS Matrix_& matrix_, CS IS end_x_, CS IS end_y_) CS NE {
dtl::type::size row_count{}, col_count{};
for (CS auto& i : matrix_) {
++row_count;
if (row_count <= this->start_y) continue;
if (end_y_ != 1 && row_count >= end_y_) break;
col_count = 0;
for (CS auto& j : i) {
++col_count;
if (col_count <= this->start_x) continue;
if (end_x_ != 1 && col_count >= end_x_) break;
std::cout << this->string_vector[this->outputList(j)];
}
std::cout << '\n';
}
RT true;
}
public:
DVCN
CE IS getPointX() CS NE {
RT this->start_x;
}
DVCN
CE IS getPointY() CS NE {
RT this->start_y;
}
DVCN
CE IS getWidth() CS NE {
RT this->width;
}
DVCN
CE IS getHeight() CS NE {
RT this->height;
}
TP<TN Matrix_>
BL draw(CS Matrix_ & matrix_) CS NE {
RT (this->width == 0) ? this->drawSTL(matrix_, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height) : this->drawWidthSTL(matrix_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height);
}
TP<TN Matrix_>
BL draw(CS Matrix_ & matrix_, CS IS layer_) CS NE {
RT (this->width == 0) ? this->drawLayerSTL(matrix_, layer_, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height) : this->drawLayerWidthSTL(matrix_, layer_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height);
}
TP<TN Matrix_>
BL draw(CS Matrix_ & matrix_, CS IS max_x_, CS IS max_y_) CS NE {
RT this->drawNormal(matrix_, (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height);
}
TP<TN Matrix_>
BL draw(CS Matrix_ & matrix_, CS IS layer_, CS IS max_x_, CS IS max_y_) CS NE {
RT this->drawLayerNormal(matrix_, layer_, (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height);
}
TP<TN Matrix_>
BL drawArray(CS Matrix_ & matrix_, CS IS max_x_, CS IS max_y_) CS NE {
RT this->drawArray(matrix_, (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, max_x_);
}
TP<TN Matrix_>
BL drawList(CS Matrix_& matrix_) CS NE {
RT this->drawList(matrix_, this->start_x + this->width + 1, this->start_y + this->height + 1);
}
TP<TN Matrix_, TN ...Args_>
CE BL operator()(CS Matrix_& matrix_, Args_&& ... args_) CS NE {
RT this->draw(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& create(Matrix_&& matrix_, Args_&& ... args_) CS NE {
this->draw(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createArray(Matrix_&& matrix_, Args_&& ... args_) CS NE {
this->drawArray(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
DVCC
OutputString& clearPointX() NE {
this->start_x = 0;
RT *this;
}
DVCC
OutputString& clearPointY() NE {
this->start_y = 0;
RT *this;
}
DVCC
OutputString& clearWidth() NE {
this->width = 0;
RT *this;
}
DVCC
OutputString& clearHeight() NE {
this->height = 0;
RT *this;
}
DVCC
OutputString& clearPoint() NE {
this->clearPointX();
this->clearPointY();
RT *this;
}
DVCC
OutputString& clearRange() NE {
this->clearPointX();
this->clearPointY();
this->clearWidth();
this->clearHeight();
RT *this;
}
DVCC
OutputString& clear() NE {
this->clearRange();
RT *this;
}
DVCC
OutputString& setPointX(CS IS start_x_) NE {
this->start_x = start_x_;
RT *this;
}
DVCC
OutputString& setPointY(CS IS start_y_) NE {
this->start_y = start_y_;
RT *this;
}
DVCC
OutputString& setWidth(CS IS width_) NE {
this->width = width_;
RT *this;
}
DVCC
OutputString& setHeight(CS IS height_) NE {
this->height = height_;
RT *this;
}
DVCC
OutputString& setPoint(CS IS point_) NE {
this->start_x = point_;
this->start_y = point_;
RT *this;
}
DVCC
OutputString& setPoint(CS IS start_x_, CS IS start_y_) NE {
this->start_x = start_x_;
this->start_y = start_y_;
RT *this;
}
DVCC
OutputString& setRange(CS IS start_x_, CS IS start_y_, CS IS length_) NE {
this->start_x = start_x_;
this->start_y = start_y_;
this->width = length_;
this->height = length_;
RT *this;
}
DVCC
OutputString& setRange(CS IS start_x_, CS IS start_y_, CS IS width_, CS IS height_) NE {
this->start_x = start_x_;
this->start_y = start_y_;
this->width = width_;
this->height = height_;
RT *this;
}
DVCC
OutputString& setRange(CS dtl::base::MatrixRange& matrix_range_) NE {
this->start_x = matrix_range_.x;
this->start_y = matrix_range_.y;
this->width = matrix_range_.w;
this->height = matrix_range_.h;
RT *this;
}
CE OutputString() NE = default;
TP<TN ...Args_>
explicit OutputString(CS OutputStringName_ & first_, CS Args_ & ... args_) NE {
this->string_String(first_, args_...);
}
TP<TN ...Args_>
CE explicit OutputString(CS dtl::base::MatrixRange& matrix_range_) NE
:start_x(matrix_range_.x), start_y(matrix_range_.y),
width(matrix_range_.w), height(matrix_range_.h) {}
TP<TN ...Args_>
explicit OutputString(CS dtl::base::MatrixRange& matrix_range_, CS OutputStringName_& first_, CS Args_& ... args_) NE
:start_x(matrix_range_.x), start_y(matrix_range_.y),
width(matrix_range_.w), height(matrix_range_.h) {
this->string_String(first_, args_...);
}
TP<TN ...Args_>
CE explicit OutputString(CS IS start_x_, CS IS start_y_, CS IS width_, CS IS height_) NE
:start_x(start_x_), start_y(start_y_),
width(width_), height(height_) {}
TP<TN ...Args_>
explicit OutputString(CS IS start_x_, CS IS start_y_, CS IS width_, CS IS height_, CS OutputStringName_ & first_, CS Args_ & ... args_) NE
:start_x(start_x_), start_y(start_y_),
width(width_), height(height_) {
this->string_String(first_, args_...);
}
};
}
}
#endif 
#ifndef IDTL_DTL_CONSOLE_OUTPUT_STRING_BOOL
#define IDTL_DTL_CONSOLE_OUTPUT_STRING_BOOL
#include <iostream>
#include <string>
NS dtl {
inline NS console {
TP<TN MI, TN OutputString_ = std::string>
class OutputStringBool {
private:
using IS = dtl::type::size;
IS start_x{};
IS start_y{};
IS width{};
IS height{};
OutputString_ false_string{};
OutputString_ true_string{};
TP<TN Matrix_>
DVCN
CE inline MI outputSTL(CS Matrix_& matrix_, CS IS point_x_, CS IS point_y_) CS NE {
RT matrix_[point_y_][point_x_];
}
TP<TN Matrix_>
DVCN
CE inline MI outputArray(CS Matrix_& matrix_, CS IS point_x_, CS IS point_y_, CS IS max_x_) CS NE {
RT matrix_[point_y_ * max_x_ + point_x_];
}
TP<TN Matrix_>
DVCN
CE inline MI outputLayer(CS Matrix_& matrix_, CS IS layer_, CS IS point_x_, CS IS point_y_) CS NE {
RT matrix_[point_y_][point_x_][layer_];
}
TP<TN Matrix_>
DVCN
CE inline MI outputList(CS Matrix_& matrix_) CS NE {
RT matrix_;
}
TP<TN Matrix_, TN Function_>
DVCN
CE inline MI outputSTL(CS Matrix_& matrix_, CS IS point_x_, CS IS point_y_, Function_&& function_) CS NE {
RT function_(matrix_[point_y_][point_x_]);
}
TP<TN Matrix_, TN Function_>
DVCN
CE inline MI outputArray(CS Matrix_& matrix_, CS IS point_x_, CS IS point_y_, CS IS max_x_, Function_&& function_) CS NE {
RT function_(matrix_[point_y_ * max_x_ + point_x_]);
}
TP<TN Matrix_, TN Function_>
DVCN
CE inline MI outputLayer(CS Matrix_ & matrix_, CS IS layer_, CS IS point_x_, CS IS point_y_, Function_ && function_) CS NE {
RT function_(matrix_[point_y_][point_x_][layer_]);
}
TP<TN Matrix_, TN Function_>
DVCN
CE inline MI outputList(CS Matrix_& matrix_, Function_&& function_) CS NE {
RT function_(matrix_);
}
TP<TN Matrix_, TN ...Args_>
BL drawSTL(CS Matrix_ & matrix_, CS IS end_y_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i) {
for (IS j{ this->start_x }; j < matrix_[i].size(); ++j)
std::cout << ((this->outputSTL(matrix_, j, i, args_...)) ? this->true_string : this->false_string);
std::cout << '\n';
}
RT true;
}
TP<TN Matrix_, TN ...Args_>
BL drawWidthSTL(CS Matrix_ & matrix_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i) {
for (IS j{ this->start_x }; j < matrix_[i].size() && j < end_x_; ++j)
std::cout << ((this->outputSTL(matrix_, j, i, args_...)) ? this->true_string : this->false_string);
std::cout << '\n';
}
RT true;
}
TP<TN Matrix_, TN ...Args_>
BL drawLayerSTL(CS Matrix_ & matrix_, CS IS layer_, CS IS end_y_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i) {
for (IS j{ this->start_x }; j < matrix_[i].size(); ++j)
std::cout << ((this->outputLayer(matrix_, layer_, j, i, args_...)) ? this->true_string : this->false_string);
std::cout << '\n';
}
RT true;
}
TP<TN Matrix_, TN ...Args_>
BL drawLayerWidthSTL(CS Matrix_ & matrix_, CS IS layer_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i) {
for (IS j{ this->start_x }; j < matrix_[i].size() && j < end_x_; ++j)
std::cout << ((this->outputLayer(matrix_, layer_, j, i, args_...)) ? this->true_string : this->false_string);
std::cout << '\n';
}
RT true;
}
TP<TN Matrix_, TN ...Args_>
BL drawNormal(CS Matrix_ & matrix_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i) {
for (IS j{ this->start_x }; j < end_x_; ++j)
std::cout << ((this->outputSTL(matrix_, j, i, args_...)) ? this->true_string : this->false_string);
std::cout << '\n';
}
RT true;
}
TP<TN Matrix_, TN ...Args_>
BL drawLayerNormal(CS Matrix_ & matrix_, CS IS layer_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i) {
for (IS j{ this->start_x }; j < end_x_; ++j)
std::cout << ((this->outputLayer(matrix_, layer_, j, i, args_...)) ? this->true_string : this->false_string);
std::cout << '\n';
}
RT true;
}
TP<TN Matrix_, TN ...Args_>
BL drawArray(CS Matrix_ & matrix_, CS IS end_x_, CS IS end_y_, CS IS max_x_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i) {
for (IS j{ this->start_x }; j < end_x_; ++j)
std::cout << ((this->outputArray(matrix_, j, i, max_x_, args_...)) ? this->true_string : this->false_string);
std::cout << '\n';
}
RT true;
}
TP<TN Matrix_, TN ...Args_>
BL drawList(CS Matrix_& matrix_, CS IS end_x_, CS IS end_y_, Args_&& ... args_) CS NE {
dtl::type::size row_count{}, col_count{};
for (CS auto& i : matrix_) {
++row_count;
if (row_count <= this->start_y) continue;
if (end_y_ != 1 && row_count >= end_y_) break;
col_count = 0;
for (CS auto& j : i) {
++col_count;
if (col_count <= this->start_x) continue;
if (end_x_ != 1 && col_count >= end_x_) break;
std::cout << ((this->outputList(j, args_...)) ? this->true_string : this->false_string);
}
std::cout << '\n';
}
RT true;
}
public:
DVCN
CE IS getPointX() CS NE {
RT this->start_x;
}
DVCN
CE IS getPointY() CS NE {
RT this->start_y;
}
DVCN
CE IS getWidth() CS NE {
RT this->width;
}
DVCN
CE IS getHeight() CS NE {
RT this->height;
}
DVCN
CE OutputString_ getTrueString() CS NE {
RT this->true_string;
}
DVCN
CE OutputString_ getFalseString() CS NE {
RT this->false_string;
}
TP<TN Matrix_>
BL draw(CS Matrix_ & matrix_) CS NE {
RT (this->width == 0) ? this->drawSTL(matrix_, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height) : this->drawWidthSTL(matrix_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
BL drawOperator(CS Matrix_ & matrix_, Function_ && function_) CS NE {
RT (this->width == 0) ? this->drawSTL(matrix_, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_) : this->drawWidthSTL(matrix_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_);
}
TP<TN Matrix_>
BL draw(CS Matrix_ & matrix_, CS IS layer_) CS NE {
RT (this->width == 0) ? this->drawLayerSTL(matrix_, layer_, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height) : this->drawLayerWidthSTL(matrix_, layer_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
BL drawOperator(CS Matrix_ & matrix_, CS IS layer_, Function_ && function_) CS NE {
RT (this->width == 0) ? this->drawLayerSTL(matrix_, layer_, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_) : this->drawLayerWidthSTL(matrix_, layer_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_);
}
TP<TN Matrix_>
BL draw(CS Matrix_ & matrix_, CS IS max_x_, CS IS max_y_) CS NE {
RT this->drawNormal(matrix_, (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
BL drawOperator(CS Matrix_ & matrix_, CS IS max_x_, CS IS max_y_, Function_ && function_) CS NE {
RT this->drawNormal(matrix_, (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, function_);
}
TP<TN Matrix_>
BL draw(CS Matrix_ & matrix_, CS IS layer_, CS IS max_x_, CS IS max_y_) CS NE {
RT this->drawLayerNormal(matrix_, layer_, (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
BL drawOperator(CS Matrix_ & matrix_, CS IS layer_, CS IS max_x_, CS IS max_y_, Function_ && function_) CS NE {
RT this->drawLayerNormal(matrix_, layer_, (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, function_);
}
TP<TN Matrix_>
BL drawArray(CS Matrix_ & matrix_, CS IS max_x_, CS IS max_y_) CS NE {
RT this->drawArray(matrix_, (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, max_x_);
}
TP<TN Matrix_, TN Function_>
BL drawOperatorArray(CS Matrix_ & matrix_, CS IS max_x_, CS IS max_y_, Function_ && function_) CS NE {
RT this->drawArray(matrix_, (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, max_x_, function_);
}
TP<TN Matrix_>
BL drawList(CS Matrix_& matrix_) CS NE {
RT this->drawList(matrix_, this->start_x + this->width + 1, this->start_y + this->height + 1);
}
TP<TN Matrix_, TN Function_>
BL drawOperatorList(CS Matrix_& matrix_, Function_&& function_) CS NE {
RT this->drawList(matrix_, this->start_x + this->width + 1, this->start_y + this->height + 1, function_);
}
TP<TN Matrix_, TN ...Args_>
CE BL operator()(CS Matrix_& matrix_, Args_&& ... args_) CS NE {
RT this->draw(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& create(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->draw(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createArray(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->drawArray(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createOperator(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->drawOperator(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createOperatorArray(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->drawOperatorArray(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
DVCC
OutputStringBool& clearPointX() NE {
this->start_x = 0;
RT *this;
}
DVCC
OutputStringBool& clearPointY() NE {
this->start_y = 0;
RT *this;
}
DVCC
OutputStringBool& clearWidth() NE {
this->width = 0;
RT *this;
}
DVCC
OutputStringBool& clearHeight() NE {
this->height = 0;
RT *this;
}
DVCC
OutputStringBool& clearPoint() NE {
this->clearPointX();
this->clearPointY();
RT *this;
}
DVCC
OutputStringBool& clearRange() NE {
this->clearPointX();
this->clearPointY();
this->clearWidth();
this->clearHeight();
RT *this;
}
DVCC
OutputStringBool& clearTrueString() NE {
OutputString_ output_string{};
this->true_string = output_string;
RT *this;
}
DVCC
OutputStringBool& clearFalseString() NE {
OutputString_ output_string{};
this->false_string = output_string;
RT *this;
}
DVCC
OutputStringBool& clearString() NE {
this->clearTrueString();
this->clearFalseString();
RT *this;
}
DVCC
OutputStringBool& clear() NE {
this->clearRange();
this->clearString();
RT *this;
}
DVCC
OutputStringBool& setPointX(CS IS start_x_) NE {
this->start_x = start_x_;
RT *this;
}
DVCC
OutputStringBool& setPointY(CS IS start_y_) NE {
this->start_y = start_y_;
RT *this;
}
DVCC
OutputStringBool& setWidth(CS IS width_) NE {
this->width = width_;
RT *this;
}
DVCC
OutputStringBool& setHeight(CS IS height_) NE {
this->height = height_;
RT *this;
}
DVCC
OutputStringBool& setPoint(CS IS point_) NE {
this->start_x = point_;
this->start_y = point_;
RT *this;
}
DVCC
OutputStringBool& setPoint(CS IS start_x_, CS IS start_y_) NE {
this->start_x = start_x_;
this->start_y = start_y_;
RT *this;
}
DVCC
OutputStringBool& setRange(CS IS start_x_, CS IS start_y_, CS IS length_) NE {
this->start_x = start_x_;
this->start_y = start_y_;
this->width = length_;
this->height = length_;
RT *this;
}
DVCC
OutputStringBool& setRange(CS IS start_x_, CS IS start_y_, CS IS width_, CS IS height_) NE {
this->start_x = start_x_;
this->start_y = start_y_;
this->width = width_;
this->height = height_;
RT *this;
}
DVCC
OutputStringBool& setRange(CS dtl::base::MatrixRange& matrix_range_) NE {
this->start_x = matrix_range_.x;
this->start_y = matrix_range_.y;
this->width = matrix_range_.w;
this->height = matrix_range_.h;
RT *this;
}
DVCC
OutputStringBool& setTrueString(CS OutputString_& output_string_) NE {
this->true_string = output_string_;
RT *this;
}
DVCC
OutputStringBool& setFalseString(CS OutputString_& output_string_) NE {
this->false_string = output_string_;
RT *this;
}
CE OutputStringBool() NE = default;
CE explicit OutputStringBool(CS OutputString_ & true_string_) NE
:true_string(true_string_) {}
CE explicit OutputStringBool(CS OutputString_ & true_string_, CS OutputString_ & false_string_) NE
:false_string(false_string_), true_string(true_string_) {}
CE OutputStringBool(CS dtl::base::MatrixRange& matrix_range_)
: start_x(matrix_range_.x), start_y(matrix_range_.y),
width(matrix_range_.w), height(matrix_range_.h) {}
CE explicit OutputStringBool(CS dtl::base::MatrixRange& matrix_range_, CS OutputString_& true_string_) NE
:start_x(matrix_range_.x), start_y(matrix_range_.y),
width(matrix_range_.w), height(matrix_range_.h),
true_string(true_string_) {}
CE explicit OutputStringBool(CS dtl::base::MatrixRange& matrix_range_, CS OutputString_& true_string_, CS OutputString_& false_string_) NE
:start_x(matrix_range_.x), start_y(matrix_range_.y),
width(matrix_range_.w), height(matrix_range_.h),
false_string(false_string_), true_string(true_string_) {}
CE explicit OutputStringBool(CS IS start_x_, CS IS start_y_, CS IS width_, CS IS height_) NE
:start_x(start_x_), start_y(start_y_),
width(width_), height(height_) {}
CE explicit OutputStringBool(CS IS start_x_, CS IS start_y_, CS IS width_, CS IS height_, CS OutputString_ & true_string_) NE
:start_x(start_x_), start_y(start_y_),
width(width_), height(height_),
true_string(true_string_) {}
CE explicit OutputStringBool(CS IS start_x_, CS IS start_y_, CS IS width_, CS IS height_, CS OutputString_ & true_string_, CS OutputString_ & false_string_) NE
:start_x(start_x_), start_y(start_y_),
width(width_), height(height_),
false_string(false_string_), true_string(true_string_) {}
};
}
}
#endif 
#ifndef IDTL_DTL_CONSOLE_OUTPUT_VIEW
#define IDTL_DTL_CONSOLE_OUTPUT_VIEW
#include <iostream>
#include <string>
NS dtl {
inline NS console {
TP<TN MI, TN OutputView_ = dtl::type::size>
class OutputView {
private:
using IS = dtl::type::size;
IS start_x{};
IS start_y{};
IS width{};
IS height{};
OutputView_ view_width{};
OutputView_ view_height{};
TP<TN Matrix_, TN Function_>
DVCC
inline void outputSTL(CS Matrix_& matrix_, CS IS point_x_, CS IS point_y_, Function_&& function_) CS NE {
function_(matrix_[point_y_][point_x_], static_cast<OutputView_>(point_x_), static_cast<OutputView_>(point_y_), this->view_width, this->view_height);
}
TP<TN Matrix_, TN Function_>
DVCC
inline void outputArray(CS Matrix_& matrix_, CS IS point_x_, CS IS point_y_, CS IS max_x_, Function_&& function_) CS NE {
function_(matrix_[point_y_ * max_x_ + point_x_], static_cast<OutputView_>(point_x_), static_cast<OutputView_>(point_y_), this->view_width, this->view_height);
}
TP<TN Matrix_, TN Function_>
DVCC
inline void outputLayer(CS Matrix_ & matrix_, CS IS layer_, CS IS point_x_, CS IS point_y_, Function_ && function_) CS NE {
function_(matrix_[point_y_][point_x_][layer_], static_cast<OutputView_>(point_x_), static_cast<OutputView_>(point_y_), this->view_width, this->view_height);
}
TP<TN Matrix_, TN ...Args_>
BL drawSTL(CS Matrix_ & matrix_, CS IS end_y_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i)
for (IS j{ this->start_x }; j < matrix_[i].size(); ++j)
this->outputSTL(matrix_, j, i, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
BL drawWidthSTL(CS Matrix_ & matrix_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i)
for (IS j{ this->start_x }; j < matrix_[i].size() && j < end_x_; ++j)
this->outputSTL(matrix_, j, i, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
BL drawLayerSTL(CS Matrix_ & matrix_, CS IS layer_, CS IS end_y_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i)
for (IS j{ this->start_x }; j < matrix_[i].size(); ++j)
this->outputLayer(matrix_, layer_, j, i, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
BL drawLayerWidthSTL(CS Matrix_ & matrix_, CS IS layer_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i)
for (IS j{ this->start_x }; j < matrix_[i].size() && j < end_x_; ++j)
this->outputLayer(matrix_, layer_, j, i, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
BL drawNormal(CS Matrix_ & matrix_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i)
for (IS j{ this->start_x }; j < end_x_; ++j)
this->outputSTL(matrix_, j, i, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
BL drawLayerNormal(CS Matrix_ & matrix_, CS IS layer_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i)
for (IS j{ this->start_x }; j < end_x_; ++j)
this->outputLayer(matrix_, layer_, j, i, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
BL drawArray(CS Matrix_ & matrix_, CS IS end_x_, CS IS end_y_, CS IS max_x_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i)
for (IS j{ this->start_x }; j < end_x_; ++j)
this->outputArray(matrix_, j, i, max_x_, args_...);
RT true;
}
public:
DVCN
CE IS getPointX() CS NE {
RT this->start_x;
}
DVCN
CE IS getPointY() CS NE {
RT this->start_y;
}
DVCN
CE IS getWidth() CS NE {
RT this->width;
}
DVCN
CE IS getHeight() CS NE {
RT this->height;
}
DVCN
CE OutputView_ getViewWidth() CS NE {
RT this->view_width;
}
DVCN
CE OutputView_ getViewHeight() CS NE {
RT this->view_height;
}
TP<TN Matrix_, TN Function_>
BL draw(CS Matrix_ & matrix_, Function_ && function_) CS NE {
RT (this->width == 0) ? this->drawSTL(matrix_, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_) : this->drawWidthSTL(matrix_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_);
}
TP<TN Matrix_, TN Function_>
BL draw(CS Matrix_ & matrix_, CS IS layer_, Function_ && function_) CS NE {
RT (this->width == 0) ? this->drawLayerSTL(matrix_, layer_, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_) : this->drawLayerWidthSTL(matrix_, layer_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_);
}
TP<TN Matrix_, TN Function_>
BL draw(CS Matrix_ & matrix_, CS IS max_x_, CS IS max_y_, Function_ && function_) CS NE {
RT this->drawNormal(matrix_, (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, function_);
}
TP<TN Matrix_, TN Function_>
BL draw(CS Matrix_ & matrix_, CS IS layer_, CS IS max_x_, CS IS max_y_, Function_ && function_) CS NE {
RT this->drawLayerNormal(matrix_, layer_, (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, function_);
}
TP<TN Matrix_, TN Function_>
BL drawArray(CS Matrix_ & matrix_, CS IS max_x_, CS IS max_y_, Function_ && function_) CS NE {
RT this->drawArray(matrix_, (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, max_x_, function_);
}
TP<TN Matrix_, TN ...Args_>
CE BL operator()(CS Matrix_ & matrix_, Args_ && ... args_) CS NE {
RT this->draw(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& create(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->draw(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createArray(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->drawArray(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
DVCC
OutputView& clearPointX() NE {
this->start_x = 0;
RT *this;
}
DVCC
OutputView& clearPointY() NE {
this->start_y = 0;
RT *this;
}
DVCC
OutputView& clearWidth() NE {
this->width = 0;
RT *this;
}
DVCC
OutputView& clearHeight() NE {
this->height = 0;
RT *this;
}
DVCC
OutputView& clearPoint() NE {
this->clearPointX();
this->clearPointY();
RT *this;
}
DVCC
OutputView& clearRange() NE {
this->clearPointX();
this->clearPointY();
this->clearWidth();
this->clearHeight();
RT *this;
}
DVCC
OutputView& clearViewHeight() NE {
this->view_height = 0;
RT *this;
}
DVCC
OutputView& clearViewWidth() NE {
this->view_width = 0;
RT *this;
}
DVCC
OutputView& clearView() NE {
this->clearViewHeight();
this->clearViewWidth();
RT *this;
}
DVCC
OutputView& clear() NE {
this->clearRange();
this->clearView();
RT *this;
}
DVCC
OutputView& setPointX(CS IS start_x_) NE {
this->start_x = start_x_;
RT *this;
}
DVCC
OutputView& setPointY(CS IS start_y_) NE {
this->start_y = start_y_;
RT *this;
}
DVCC
OutputView& setWidth(CS IS width_) NE {
this->width = width_;
RT *this;
}
DVCC
OutputView& setHeight(CS IS height_) NE {
this->height = height_;
RT *this;
}
DVCC
OutputView& setPoint(CS IS point_) NE {
this->start_x = point_;
this->start_y = point_;
RT *this;
}
DVCC
OutputView& setPoint(CS IS start_x_, CS IS start_y_) NE {
this->start_x = start_x_;
this->start_y = start_y_;
RT *this;
}
DVCC
OutputView& setRange(CS IS start_x_, CS IS start_y_, CS IS length_) NE {
this->start_x = start_x_;
this->start_y = start_y_;
this->width = length_;
this->height = length_;
RT *this;
}
DVCC
OutputView& setRange(CS IS start_x_, CS IS start_y_, CS IS width_, CS IS height_) NE {
this->start_x = start_x_;
this->start_y = start_y_;
this->width = width_;
this->height = height_;
RT *this;
}
DVCC
OutputView& setRange(CS dtl::base::MatrixRange& matrix_range_) NE {
this->start_x = matrix_range_.x;
this->start_y = matrix_range_.y;
this->width = matrix_range_.w;
this->height = matrix_range_.h;
RT *this;
}
DVCC
OutputView& setViewHeight(CS OutputView_ view_value_) NE {
this->view_height = view_value_;
RT *this;
}
DVCC
OutputView& setViewWidth(CS OutputView_ view_value_) NE {
this->view_width = view_value_;
RT *this;
}
CE OutputView() NE = default;
CE explicit OutputView(CS OutputView_& view_) NE
:view_width(view_), view_height(view_) {}
CE explicit OutputView(CS OutputView_& view_width_, CS OutputView_& view_height_) NE
:view_width(view_width_), view_height(view_height_) {}
CE explicit OutputView(CS IS start_x_, CS IS start_y_, CS IS width_, CS IS height_) NE
:start_x(start_x_), start_y(start_y_),
width(width_), height(height_) {}
CE explicit OutputView(CS IS start_x_, CS IS start_y_, CS IS width_, CS IS height_, CS OutputView_& view_) NE
:start_x(start_x_), start_y(start_y_),
width(width_), height(height_),
view_width(view_), view_height(view_) {}
CE explicit OutputView(CS IS start_x_, CS IS start_y_, CS IS width_, CS IS height_, CS OutputView_& view_width_, CS OutputView_& view_height_) NE
:start_x(start_x_), start_y(start_y_),
width(width_), height(height_),
view_width(view_width_), view_height(view_height_) {}
};
}
}
#endif 
#endif 
#endif 
#ifndef NOT_IDTL_DTL_RANDOM
#ifndef IDTL_DTL_RANDOM
#define IDTL_DTL_RANDOM
#ifndef IDTL_DTL_RANDOM_MERSENNE_TWISTER_32_BIT
#define IDTL_DTL_RANDOM_MERSENNE_TWISTER_32_BIT
#include <cstdint>
#include <bitset>
#include <random>
NS dtl {
inline NS random {
class MersenneTwister_64bit {
private:
std::mt19937_64 mt;
std::random_device rd;
public:
explicit MersenneTwister_64bit() NE { this->mt.seed(this->rd()); }
void seed() NE {
this->mt.seed(this->rd());
}
TP<TN Random_Int_ = std::uint_fast64_t>
void seed(CS Random_Int_ seed_) NE {
this->mt.seed(static_cast<std::uint_fast64_t>(seed_));
}
TP<TN Random_Int_ = std::uint_fast64_t>
DVCN
Random_Int_ get() NE {
RT static_cast<Random_Int_>(this->mt());
}
};
static thread_local dtl::random::MersenneTwister_64bit mt64bit;
CE dtl::type::size mt64_bit_counter_num_1{ 64 };
class MT64bit_1 {
private:
dtl::type::size counter{ mt64_bit_counter_num_1 };
std::uint_fast64_t random_num{};
public:
DVCN
BL get() NE {
if (this->counter >= mt64_bit_counter_num_1) {
this->random_num = dtl::random::mt64bit.get();
this->counter = 0;
}
else ++(this->counter);
CS BL tmp{ (this->random_num & 1) == 0 };
this->random_num >>= 1;
RT tmp;
}
};
static thread_local dtl::random::MT64bit_1 mt64bit_1;
CE dtl::type::size mt32_bit_counter_num_1{ 32 };
class MersenneTwister_32bit {
private:
std::mt19937 mt;
std::random_device rd;
dtl::type::size counter_bit1{ mt32_bit_counter_num_1 };
std::uint_fast32_t random_num_bit1{};
DVCN
BL getBit1() NE {
if (counter_bit1 >= mt32_bit_counter_num_1) {
random_num_bit1 = this->get();
counter_bit1 = 0;
}
else ++counter_bit1;
CS BL tmp{ (random_num_bit1 & 1) == 0 };
random_num_bit1 >>= 1;
RT tmp;
}
public:
explicit MersenneTwister_32bit() NE { this->mt.seed(this->rd()); }
void seed() NE {
this->mt.seed(this->rd());
}
TP<TN Random_Int_ = std::uint_fast32_t>
void seed(CS Random_Int_ seed_) NE {
this->mt.seed(static_cast<std::uint_fast32_t>(seed_));
}
TP<TN Random_Int_ = std::uint_fast32_t>
DVCN
Random_Int_ get() NE {
RT static_cast<Random_Int_>(this->mt());
}
TP<TN Random_Int_ = std::int_fast32_t, TN Random_Int2_>
DVCN
Random_Int_ get(CS Random_Int2_ max_) NE {
if (static_cast<std::int_fast32_t>(max_) <= 1) RT 0;
std::uniform_int_distribution<> uid(0, static_cast<std::int_fast32_t>(max_) - 1);
RT static_cast<Random_Int_>(uid(this->mt));
}
TP<TN Random_Int_ = std::int_fast32_t, TN Random_Int2_, TN Random_Int3_>
DVCN
Random_Int_ get(CS Random_Int2_ min_, CS Random_Int3_ max_) NE {
std::uniform_int_distribution<> uid(static_cast<std::int_fast32_t>((min_ <= static_cast<Random_Int2_>(max_)) ? min_ : static_cast<Random_Int2_>(max_)), static_cast<std::int_fast32_t>((min_ <= static_cast<Random_Int2_>(max_)) ? static_cast<Random_Int2_>(max_) : min_));
RT static_cast<Random_Int_>(uid(this->mt));
}
DVCN
BL probability(CS double probability_) NE {
std::bernoulli_distribution uid(probability_);
RT uid(this->mt);
}
DVCN
BL probability() NE {
RT this->getBit1();
}
};
static thread_local dtl::random::MersenneTwister_32bit mt32bit;
class MT32bit_1 {
private:
dtl::type::size counter{ mt32_bit_counter_num_1 };
std::uint_fast32_t random_num{};
public:
DVCN
BL get() NE {
if (counter >= mt32_bit_counter_num_1) {
random_num = dtl::random::mt32bit.get();
counter = 0;
}
else ++counter;
CS BL tmp{ (random_num & 1) == 0 };
random_num >>= 1;
RT tmp;
}
};
static thread_local dtl::random::MT32bit_1 mt32bit_1;
CE dtl::type::size counter_num_2{ 32 };
CE dtl::type::size counter_bit_num_2{ counter_num_2 * 2 };
class MT64bit_4 {
private:
dtl::type::size counter{ counter_num_2 };
std::uint_fast64_t random_num{};
public:
TP<TN Random_Int_ = std::uint_fast64_t>
DVCN
Random_Int_ get() NE {
if (this->counter >= counter_num_2) {
this->random_num = dtl::random::mt64bit.get();
this->counter = 0;
}
else ++(this->counter);
CS auto tmp{ this->random_num & 3 };
this->random_num >>= 2;
RT static_cast<Random_Int_>(tmp);
}
};
static thread_local dtl::random::MT64bit_4 mt64bit_4;
class MersenneTwister32bit {
private:
std::mt19937 mt;
std::random_device rd;
public:
explicit MersenneTwister32bit() NE { this->mt.seed(this->rd()); }
void seed() NE {
this->mt.seed(this->rd());
}
void seed(CS std::uint_fast32_t seed_) NE {
this->mt.seed(seed_);
}
DVCN
std::uint_fast32_t operator()() NE {
RT this->mt();
}
DVCN
std::int_fast32_t operator()(CS std::int_fast32_t max_) NE {
if (max_ <= 1) RT 0;
std::uniform_int_distribution<> uid(0, max_ - 1);
RT uid(this->mt);
}
DVCN
std::int_fast32_t operator()(CS std::int_fast32_t min_, CS std::int_fast32_t max_) NE {
std::uniform_int_distribution<> uid((min_ <= max_) ? min_ : max_, (min_ <= max_) ? max_ : min_);
RT uid(this->mt);
}
DVCN
BL probability(CS double probability_) NE {
std::bernoulli_distribution uid(probability_);
RT uid(this->mt);
}
DVCN
BL probability() NE {
std::uniform_int_distribution<> uid(0, 1);
RT ((uid(this->mt)) ? true : false);
}
};
static thread_local dtl::random::MersenneTwister32bit mersenne_twister_32bit;
}
}
#endif 
#endif 
#endif 
#ifndef NOT_IDTL_DTL_RETOUCH
#ifndef IDTL_DTL_RETOUCH
#define IDTL_DTL_RETOUCH
#ifndef IDTL_DTL_RETOUCH_BURY_POINT
#define IDTL_DTL_RETOUCH_BURY_POINT
NS dtl {
inline NS retouch {
TP<TN MI>
class BuryPoint {
private:
using IS = dtl::type::size;
IS start_x{};
IS start_y{};
IS width{};
IS height{};
TP<TN Matrix_>
DVCC
inline void substitutionSTL(Matrix_&& matrix_, CS IS end_x_, CS IS end_y_) CS NE {
if (matrix_[end_y_][end_x_] != matrix_[end_y_][end_x_ - 1] && matrix_[end_y_][end_x_] != matrix_[end_y_][end_x_ + 1] && matrix_[end_y_][end_x_] != matrix_[end_y_ - 1][end_x_] && matrix_[end_y_][end_x_] != matrix_[end_y_ + 1][end_x_])
matrix_[end_y_][end_x_] = matrix_[end_y_][end_x_ + 1];
}
TP<TN Matrix_>
DVCC
inline void substitutionArray(Matrix_ && matrix_, CS IS end_x_, CS IS end_y_, CS IS max_x_) CS NE {
if (matrix_[end_y_ * max_x_ + end_x_] != matrix_[end_y_ * max_x_ + end_x_ - 1] && matrix_[end_y_ * max_x_ + end_x_] != matrix_[end_y_ * max_x_ + end_x_ + 1] && matrix_[end_y_ * max_x_ + end_x_] != matrix_[end_y_ - 1 * max_x_ + end_x_] && matrix_[end_y_ * max_x_ + end_x_] != matrix_[end_y_ + 1 * max_x_ + end_x_])
matrix_[end_y_ * max_x_ + end_x_] = matrix_[end_y_ * max_x_ + end_x_ + 1];
}
TP<TN Matrix_>
DVCC
inline void substitutionLayer(Matrix_ && matrix_, CS IS layer_, CS IS end_x_, CS IS end_y_) CS NE {
if (matrix_[end_y_][end_x_][layer_] != matrix_[end_y_][end_x_ - 1][layer_] && matrix_[end_y_][end_x_][layer_] != matrix_[end_y_][end_x_ + 1][layer_] && matrix_[end_y_][end_x_][layer_] != matrix_[end_y_ - 1][end_x_][layer_] && matrix_[end_y_][end_x_][layer_] != matrix_[end_y_ + 1][end_x_][layer_])
matrix_[end_y_][end_x_][layer_] = matrix_[end_y_][end_x_ + 1][layer_];
}
TP<TN Matrix_, TN Function_>
DVCC
inline void substitutionSTL(Matrix_ && matrix_, CS IS end_x_, CS IS end_y_, Function_ && function_) CS NE {
if (matrix_[end_y_][end_x_] != matrix_[end_y_][end_x_ - 1] && matrix_[end_y_][end_x_] != matrix_[end_y_][end_x_ + 1] && matrix_[end_y_][end_x_] != matrix_[end_y_ - 1][end_x_] && matrix_[end_y_][end_x_] != matrix_[end_y_ + 1][end_x_] && function_(matrix_[end_y_][end_x_]))
matrix_[end_y_][end_x_] = matrix_[end_y_][end_x_ + 1];
}
TP<TN Matrix_, TN Function_>
DVCC
inline void substitutionArray(Matrix_ && matrix_, CS IS end_x_, CS IS end_y_, CS IS max_x_, Function_ && function_) CS NE {
if (matrix_[end_y_ * max_x_ + end_x_] != matrix_[end_y_ * max_x_ + end_x_ - 1] && matrix_[end_y_ * max_x_ + end_x_] != matrix_[end_y_ * max_x_ + end_x_ + 1] && matrix_[end_y_ * max_x_ + end_x_] != matrix_[end_y_ - 1 * max_x_ + end_x_] && matrix_[end_y_ * max_x_ + end_x_] != matrix_[end_y_ + 1 * max_x_ + end_x_] && function_(matrix_[end_y_][end_x_]))
matrix_[end_y_ * max_x_ + end_x_] = matrix_[end_y_ * max_x_ + end_x_ + 1];
}
TP<TN Matrix_, TN Function_>
DVCC
inline void substitutionLayer(Matrix_ && matrix_, CS IS layer_, CS IS end_x_, CS IS end_y_, Function_ && function_) CS NE {
if (matrix_[end_y_][end_x_][layer_] != matrix_[end_y_][end_x_ - 1][layer_] && matrix_[end_y_][end_x_][layer_] != matrix_[end_y_][end_x_ + 1][layer_] && matrix_[end_y_][end_x_][layer_] != matrix_[end_y_ - 1][end_x_][layer_] && matrix_[end_y_][end_x_][layer_] != matrix_[end_y_ + 1][end_x_][layer_] && function_(matrix_[end_y_][end_x_]))
matrix_[end_y_][end_x_][layer_] = matrix_[end_y_][end_x_ + 1][layer_];
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawSTL(Matrix_ && matrix_, CS IS end_y_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y + 1 }; i < end_y_ - 1; ++i)
for (IS j{ this->start_x + 1 }; j < matrix_[i].size() - 1; ++j)
this->substitutionSTL(matrix_, j, i, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawWidthSTL(Matrix_ && matrix_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y + 1 }; i < end_y_ - 1; ++i)
for (IS j{ this->start_x + 1 }; j < matrix_[i].size() - 1 && j < end_x_ - 1; ++j)
this->substitutionSTL(matrix_, j, i, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawLayerSTL(Matrix_ && matrix_, CS IS layer_, CS IS end_y_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y + 1 }; i < end_y_ - 1; ++i)
for (IS j{ this->start_x + 1 }; j < matrix_[i].size() - 1; ++j)
this->substitutionLayer(matrix_, layer_, j, i, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawLayerWidthSTL(Matrix_ && matrix_, CS IS layer_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y + 1 }; i < end_y_ - 1; ++i)
for (IS j{ this->start_x + 1 }; j < matrix_[i].size() - 1 && j < end_x_ - 1; ++j)
this->substitutionLayer(matrix_, layer_, j, i, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawNormal(Matrix_ && matrix_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y + 1 }; i < end_y_ - 1; ++i)
for (IS j{ this->start_x + 1 }; j < end_x_ - 1; ++j)
this->substitutionSTL(matrix_, j, i, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawLayerNormal(Matrix_ && matrix_, CS IS layer_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y + 1 }; i < end_y_ - 1; ++i)
for (IS j{ this->start_x + 1 }; j < end_x_ - 1; ++j)
this->substitutionLayer(matrix_, layer_, j, i, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawArray(Matrix_ && matrix_, CS IS end_x_, CS IS end_y_, CS IS max_x_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y + 1 }; i < end_y_ - 1; ++i)
for (IS j{ this->start_x + 1 }; j < end_x_ - 1; ++j)
this->substitutionArray(matrix_, j, i, max_x_, args_...);
RT true;
}
public:
DVCN
CE IS getPointX() CS NE {
RT this->start_x;
}
DVCN
CE IS getPointY() CS NE {
RT this->start_y;
}
DVCN
CE IS getWidth() CS NE {
RT this->width;
}
DVCN
CE IS getHeight() CS NE {
RT this->height;
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_) CS NE {
RT (this->width == 0) ? this->drawSTL(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height) : this->drawWidthSTL(matrix_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, Function_ && function_) CS NE {
RT (this->width == 0) ? this->drawSTL(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_) : this->drawWidthSTL(matrix_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_, CS IS layer_) CS NE {
RT (this->width == 0) ? this->drawLayerSTL(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height) : this->drawLayerWidthSTL(matrix_, layer_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, CS IS layer_, Function_ && function_) CS NE {
RT (this->width == 0) ? this->drawLayerSTL(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_) : this->drawLayerWidthSTL(matrix_, layer_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_) CS NE {
RT this->drawNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_, Function_ && function_) CS NE {
RT this->drawNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_, CS IS layer_, CS IS max_x_, CS IS max_y_) CS NE {
RT this->drawLayerNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, CS IS layer_, CS IS max_x_, CS IS max_y_, Function_ && function_) CS NE {
RT this->drawLayerNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL drawArray(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_) CS NE {
RT this->drawArray(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, max_x_);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperatorArray(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_, Function_ && function_) CS NE {
RT this->drawArray(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, max_x_, function_);
}
TP<TN Matrix_, TN ...Args_>
CE BL operator()(Matrix_&& matrix_, Args_&& ... args_) CS NE {
RT this->draw(DTL_TYPE_FORWARD<Matrix_>(matrix_), DTL_TYPE_FORWARD<Args_>(args_)...);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& create(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->draw(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createArray(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->drawArray(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createOperator(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->drawOperator(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createOperatorArray(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->drawOperatorArray(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
DVCC
BuryPoint& clearPointX() NE {
this->start_x = 0;
RT *this;
}
DVCC
BuryPoint& clearPointY() NE {
this->start_y = 0;
RT *this;
}
DVCC
BuryPoint& clearWidth() NE {
this->width = 0;
RT *this;
}
DVCC
BuryPoint& clearHeight() NE {
this->height = 0;
RT *this;
}
DVCC
BuryPoint& clearPoint() NE {
this->clearPointX();
this->clearPointY();
RT *this;
}
DVCC
BuryPoint& clearRange() NE {
this->clearPointX();
this->clearPointY();
this->clearWidth();
this->clearHeight();
RT *this;
}
DVCC
BuryPoint& clear() NE {
this->clearRange();
RT *this;
}
DVCC
BuryPoint& setPointX(CS IS end_x_) NE {
this->start_x = end_x_;
RT *this;
}
DVCC
BuryPoint& setPointY(CS IS end_y_) NE {
this->start_y = end_y_;
RT *this;
}
DVCC
BuryPoint& setWidth(CS IS width_) NE {
this->width = width_;
RT *this;
}
DVCC
BuryPoint& setHeight(CS IS height_) NE {
this->height = height_;
RT *this;
}
DVCC
BuryPoint& setPoint(CS IS point_) NE {
this->start_x = point_;
this->start_y = point_;
RT *this;
}
DVCC
BuryPoint& setPoint(CS IS end_x_, CS IS end_y_) NE {
this->start_x = end_x_;
this->start_y = end_y_;
RT *this;
}
DVCC
BuryPoint& setRange(CS IS end_x_, CS IS end_y_, CS IS length_) NE {
this->start_x = end_x_;
this->start_y = end_y_;
this->width = length_;
this->height = length_;
RT *this;
}
DVCC
BuryPoint& setRange(CS IS end_x_, CS IS end_y_, CS IS width_, CS IS height_) NE {
this->start_x = end_x_;
this->start_y = end_y_;
this->width = width_;
this->height = height_;
RT *this;
}
DVCC
BuryPoint& setRange(CS dtl::base::MatrixRange& matrix_range_) NE {
this->start_x = matrix_range_.x;
this->start_y = matrix_range_.y;
this->width = matrix_range_.w;
this->height = matrix_range_.h;
RT *this;
}
CE BuryPoint() NE = default;
CE explicit BuryPoint(CS dtl::base::MatrixRange& matrix_range_) NE
:start_x(matrix_range_.x), start_y(matrix_range_.y),
width(matrix_range_.w), height(matrix_range_.h) {}
CE explicit BuryPoint(CS IS end_x_, CS IS end_y_, CS IS width_, CS IS height_) NE
:start_x(end_x_), start_y(end_y_),
width(width_), height(height_) {}
};
}
}
#endif 
#ifndef IDTL_DTL_RETOUCH_REMOVE_POINT
#define IDTL_DTL_RETOUCH_REMOVE_POINT
NS dtl {
inline NS retouch {
TP<TN MI>
class RemovePoint {
private:
using IS = dtl::type::size;
IS start_x{};
IS start_y{};
IS width{};
IS height{};
TP<TN Matrix_>
DVCC
inline void substitutionSTL(Matrix_&& matrix_, CS IS end_x_, CS IS end_y_) CS NE {
if (matrix_[end_y_][end_x_ - 1] == matrix_[end_y_][end_x_ + 1] && matrix_[end_y_][end_x_ + 1] == matrix_[end_y_ - 1][end_x_] && matrix_[end_y_ - 1][end_x_] == matrix_[end_y_ + 1][end_x_])
matrix_[end_y_][end_x_] = matrix_[end_y_][end_x_ + 1];
}
TP<TN Matrix_>
DVCC
inline void substitutionArray(Matrix_ && matrix_, CS IS end_x_, CS IS end_y_, CS IS max_x_) CS NE {
if (matrix_[end_y_ * max_x_ + end_x_ - 1] == matrix_[end_y_ * max_x_ + end_x_ + 1] && matrix_[end_y_ * max_x_ + end_x_ + 1] == matrix_[end_y_ - 1 * max_x_ + end_x_] && matrix_[end_y_ - 1 * max_x_ + end_x_] == matrix_[end_y_ + 1 * max_x_ + end_x_])
matrix_[end_y_ * max_x_ + end_x_] = matrix_[end_y_ * max_x_ + end_x_ + 1];
}
TP<TN Matrix_>
DVCC
inline void substitutionLayer(Matrix_ && matrix_, CS IS layer_, CS IS end_x_, CS IS end_y_) CS NE {
if (matrix_[end_y_][end_x_ - 1][layer_] == matrix_[end_y_][end_x_ + 1][layer_] && matrix_[end_y_][end_x_ + 1][layer_] == matrix_[end_y_ - 1][end_x_][layer_] && matrix_[end_y_ - 1][end_x_][layer_] == matrix_[end_y_ + 1][end_x_][layer_])
matrix_[end_y_][end_x_][layer_] = matrix_[end_y_][end_x_ + 1][layer_];
}
TP<TN Matrix_, TN Function_>
DVCC
inline void substitutionSTL(Matrix_ && matrix_, CS IS end_x_, CS IS end_y_, Function_ && function_) CS NE {
if (matrix_[end_y_][end_x_ - 1] == matrix_[end_y_][end_x_ + 1] && matrix_[end_y_][end_x_ + 1] == matrix_[end_y_ - 1][end_x_] && matrix_[end_y_ - 1][end_x_] == matrix_[end_y_ + 1][end_x_] && function_(matrix_[end_y_][end_x_]))
matrix_[end_y_][end_x_] = matrix_[end_y_][end_x_ + 1];
}
TP<TN Matrix_, TN Function_>
DVCC
inline void substitutionArray(Matrix_ && matrix_, CS IS end_x_, CS IS end_y_, CS IS max_x_, Function_ && function_) CS NE {
if (matrix_[end_y_ * max_x_ + end_x_ - 1] == matrix_[end_y_ * max_x_ + end_x_ + 1] && matrix_[end_y_ * max_x_ + end_x_ + 1] == matrix_[end_y_ - 1 * max_x_ + end_x_] && matrix_[end_y_ - 1 * max_x_ + end_x_] == matrix_[end_y_ + 1 * max_x_ + end_x_] && function_(matrix_[end_y_][end_x_]))
matrix_[end_y_ * max_x_ + end_x_] = matrix_[end_y_ * max_x_ + end_x_ + 1];
}
TP<TN Matrix_, TN Function_>
DVCC
inline void substitutionLayer(Matrix_ && matrix_, CS IS layer_, CS IS end_x_, CS IS end_y_, Function_ && function_) CS NE {
if (matrix_[end_y_][end_x_ - 1][layer_] == matrix_[end_y_][end_x_ + 1][layer_] && matrix_[end_y_][end_x_ + 1][layer_] == matrix_[end_y_ - 1][end_x_][layer_] && matrix_[end_y_ - 1][end_x_][layer_] == matrix_[end_y_ + 1][end_x_][layer_] && function_(matrix_[end_y_][end_x_]))
matrix_[end_y_][end_x_][layer_] = matrix_[end_y_][end_x_ + 1][layer_];
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawSTL(Matrix_ && matrix_, CS IS end_y_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y + 1 }; i < end_y_ - 1; ++i)
for (IS j{ this->start_x + 1 }; j < matrix_[i].size() - 1; ++j)
this->substitutionSTL(matrix_, j, i, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawWidthSTL(Matrix_ && matrix_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y + 1 }; i < end_y_ - 1; ++i)
for (IS j{ this->start_x + 1 }; j < matrix_[i].size() - 1 && j < end_x_ - 1; ++j)
this->substitutionSTL(matrix_, j, i, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawLayerSTL(Matrix_ && matrix_, CS IS layer_, CS IS end_y_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y + 1 }; i < end_y_ - 1; ++i)
for (IS j{ this->start_x + 1 }; j < matrix_[i].size() - 1; ++j)
this->substitutionLayer(matrix_, layer_, j, i, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawLayerWidthSTL(Matrix_ && matrix_, CS IS layer_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y + 1 }; i < end_y_ - 1; ++i)
for (IS j{ this->start_x + 1 }; j < matrix_[i].size() - 1 && j < end_x_ - 1; ++j)
this->substitutionLayer(matrix_, layer_, j, i, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawNormal(Matrix_ && matrix_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y + 1 }; i < end_y_ - 1; ++i)
for (IS j{ this->start_x + 1 }; j < end_x_ - 1; ++j)
this->substitutionSTL(matrix_, j, i, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawLayerNormal(Matrix_ && matrix_, CS IS layer_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y + 1 }; i < end_y_ - 1; ++i)
for (IS j{ this->start_x + 1 }; j < end_x_ - 1; ++j)
this->substitutionLayer(matrix_, layer_, j, i, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawArray(Matrix_ && matrix_, CS IS end_x_, CS IS end_y_, CS IS max_x_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y + 1 }; i < end_y_ - 1; ++i)
for (IS j{ this->start_x + 1 }; j < end_x_ - 1; ++j)
this->substitutionArray(matrix_, j, i, max_x_, args_...);
RT true;
}
public:
DVCN
CE IS getPointX() CS NE {
RT this->start_x;
}
DVCN
CE IS getPointY() CS NE {
RT this->start_y;
}
DVCN
CE IS getWidth() CS NE {
RT this->width;
}
DVCN
CE IS getHeight() CS NE {
RT this->height;
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_) CS NE {
RT (this->width == 0) ? this->drawSTL(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height) : this->drawWidthSTL(matrix_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, Function_ && function_) CS NE {
RT (this->width == 0) ? this->drawSTL(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_) : this->drawWidthSTL(matrix_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_, CS IS layer_) CS NE {
RT (this->width == 0) ? this->drawLayerSTL(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height) : this->drawLayerWidthSTL(matrix_, layer_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, CS IS layer_, Function_ && function_) CS NE {
RT (this->width == 0) ? this->drawLayerSTL(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_) : this->drawLayerWidthSTL(matrix_, layer_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_) CS NE {
RT this->drawNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_, Function_ && function_) CS NE {
RT this->drawNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_, CS IS layer_, CS IS max_x_, CS IS max_y_) CS NE {
RT this->drawLayerNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, CS IS layer_, CS IS max_x_, CS IS max_y_, Function_ && function_) CS NE {
RT this->drawLayerNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL drawArray(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_) CS NE {
RT this->drawArray(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, max_x_);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperatorArray(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_, Function_ && function_) CS NE {
RT this->drawArray(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, max_x_, function_);
}
TP<TN Matrix_, TN ...Args_>
CE BL operator()(Matrix_&& matrix_, Args_&& ... args_) CS NE {
RT this->draw(DTL_TYPE_FORWARD<Matrix_>(matrix_), DTL_TYPE_FORWARD<Args_>(args_)...);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& create(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->draw(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createArray(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->drawArray(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createOperator(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->drawOperator(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createOperatorArray(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->drawOperatorArray(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
DVCC
RemovePoint& clearPointX() NE {
this->start_x = 0;
RT *this;
}
DVCC
RemovePoint& clearPointY() NE {
this->start_y = 0;
RT *this;
}
DVCC
RemovePoint& clearWidth() NE {
this->width = 0;
RT *this;
}
DVCC
RemovePoint& clearHeight() NE {
this->height = 0;
RT *this;
}
DVCC
RemovePoint& clearPoint() NE {
this->clearPointX();
this->clearPointY();
RT *this;
}
DVCC
RemovePoint& clearRange() NE {
this->clearPointX();
this->clearPointY();
this->clearWidth();
this->clearHeight();
RT *this;
}
DVCC
RemovePoint& clear() NE {
this->clearRange();
RT *this;
}
DVCC
RemovePoint& setPointX(CS IS end_x_) NE {
this->start_x = end_x_;
RT *this;
}
DVCC
RemovePoint& setPointY(CS IS end_y_) NE {
this->start_y = end_y_;
RT *this;
}
DVCC
RemovePoint& setWidth(CS IS width_) NE {
this->width = width_;
RT *this;
}
DVCC
RemovePoint& setHeight(CS IS height_) NE {
this->height = height_;
RT *this;
}
DVCC
RemovePoint& setPoint(CS IS point_) NE {
this->start_x = point_;
this->start_y = point_;
RT *this;
}
DVCC
RemovePoint& setPoint(CS IS end_x_, CS IS end_y_) NE {
this->start_x = end_x_;
this->start_y = end_y_;
RT *this;
}
DVCC
RemovePoint& setRange(CS IS end_x_, CS IS end_y_, CS IS length_) NE {
this->start_x = end_x_;
this->start_y = end_y_;
this->width = length_;
this->height = length_;
RT *this;
}
DVCC
RemovePoint& setRange(CS IS end_x_, CS IS end_y_, CS IS width_, CS IS height_) NE {
this->start_x = end_x_;
this->start_y = end_y_;
this->width = width_;
this->height = height_;
RT *this;
}
DVCC
RemovePoint& setRange(CS dtl::base::MatrixRange& matrix_range_) NE {
this->start_x = matrix_range_.x;
this->start_y = matrix_range_.y;
this->width = matrix_range_.w;
this->height = matrix_range_.h;
RT *this;
}
CE RemovePoint() NE = default;
CE explicit RemovePoint(CS dtl::base::MatrixRange& matrix_range_) NE
:start_x(matrix_range_.x), start_y(matrix_range_.y),
width(matrix_range_.w), height(matrix_range_.h) {}
CE explicit RemovePoint(CS IS end_x_, CS IS end_y_, CS IS width_, CS IS height_) NE
:start_x(end_x_), start_y(end_y_),
width(width_), height(height_) {}
};
}
}
#endif 
#endif 
#endif 
#ifndef NOT_IDTL_DTL_SHAPE
#ifndef IDTL_DTL_SHAPE
#define IDTL_DTL_SHAPE
#ifndef IDTL_DTL_SHAPE_ABSOLUTE_MEMBER_RECT
#define IDTL_DTL_SHAPE_ABSOLUTE_MEMBER_RECT
#ifndef IDTL_DTL_SHAPE_ABSOLUTE_RECT
#define IDTL_DTL_SHAPE_ABSOLUTE_RECT
#ifndef IDTL_DTL_UTILITY_DRAW_JAGGED
#define IDTL_DTL_UTILITY_DRAW_JAGGED
#ifndef IDTL_DTL_UTILITY_MATRIX_WRAPPER
#define IDTL_DTL_UTILITY_MATRIX_WRAPPER
#include <cassert>
#include <cstddef>
#include <array>
#include <type_traits>
NS dtl {
inline NS utility {
TP<TN MI, std::size_t max_x_, std::size_t max_y_>
using array2D = std::array<std::array<MI, max_x_>, max_y_>;
TP<TN MI, std::size_t max_l_, std::size_t max_x_, std::size_t max_y_>
using array3D = std::array<std::array<std::array<MI, max_l_>, max_x_>, max_y_>;
TP <class... Types>
struct voidHelper {
using type = void;
};
TP <class... Types>
using void_t = TN voidHelper<Types...>::type;
TP<TN Matrix_>
struct is_Array2D : std::false_type {};
TP<TN MI, std::size_t max_y_, std::size_t max_x_>
struct is_Array2D<array2D<MI, max_x_, max_y_>> : std::true_type {};
TP<TN Matrix_>
struct is_Array3D : std::false_type {};
TP<TN MI, std::size_t max_y_, std::size_t max_x_, std::size_t max_l_>
struct is_Array3D<array3D<MI, max_l_, max_x_, max_y_>> : std::true_type {};
TP<TN Matrix_, TN = void>
struct is_STL2D : std::false_type {};
TP<TN Matrix_>
struct is_STL2D<Matrix_, void_t<TN Matrix_::value_type::value_type>>
: std::conditional<is_Array2D<Matrix_>::value, std::false_type, std::is_integral<TN Matrix_::value_type::value_type>>::type {};
TP<TN Matrix_, TN = void>
struct is_STL3D : std::false_type {};
TP<TN Matrix_>
struct is_STL3D<Matrix_, void_t<TN Matrix_::value_type::value_type::value_type>>
: std::conditional<is_Array3D<Matrix_>::value, std::false_type, std::is_integral<TN Matrix_::value_type::value_type::value_type>>::type {};
TP<TN Matrix_, TN MI, TN IS_>
struct MatrixBase {
DVCC
void set(CS IS_ point_x_, CS IS_ point_y_, CS MI value_) NE {
static_cast<Matrix_&>(*this)(point_x_, point_y_) = value_;
}
TP<TN Function_>
DVCC
void set(CS IS_ point_x_, CS IS_ point_y_, CS MI value_, Function_&& function_) NE {
if (function_(static_cast<Matrix_&>(*this)(point_x_, point_y_)))
static_cast<Matrix_&>(*this)(point_x_, point_y_) = value_;
}
};
TP<TN Matrix_, TN = void>
struct MatrixWrapper;
TP<TN MI, std::size_t max_y_, std::size_t max_x_>
struct MatrixWrapper<MI[max_y_][max_x_]>
: MatrixBase<MatrixWrapper<MI[max_y_][max_x_]>, MI, std::size_t> {
using Matrix = MI[max_y_][max_x_];
using Matrix_Int = MI;
using IS = std::size_t;
using is_jagged = std::false_type;
CE MatrixWrapper(Matrix& mat) NE : mat(mat) {}
DVCC
MatrixWrapper(Matrix& mat, CS IS max_x, CS IS max_y) : mat(mat) { assert(max_x_ == max_x); assert(max_y_ == max_y); }
CE IS getX() CS NE { RT max_x_; }
CE IS getY() CS NE { RT max_y_; }
Matrix& mat;
Matrix_Int& operator()(IS x, IS y) NE { RT mat[y][x]; }
};
TP<TN MI, std::size_t max_x_>
struct MatrixWrapper<MI(*)[max_x_]>
: MatrixBase<MatrixWrapper<MI(*)[max_x_]>, MI, std::size_t> {
using Matrix = MI(*)[max_x_];
using Matrix_Int = MI;
using IS = std::size_t;
using is_jagged = std::false_type;
Matrix mat;
IS max_y_;
DVCC
MatrixWrapper(Matrix mat, CS IS max_x, CS IS max_y) : mat(mat), max_y_(max_y) { assert(max_x_ == max_x); }
CE IS getX() CS NE { RT max_x_; }
CE IS getY() CS NE { RT max_y_; }
Matrix_Int& operator()(IS x, IS y) NE { RT mat[y][x]; }
};
TP<TN MI, std::size_t max_y_, std::size_t max_x_, std::size_t max_l_>
struct MatrixWrapper<MI[max_y_][max_x_][max_l_]>
: MatrixBase<MatrixWrapper<MI[max_y_][max_x_][max_l_]>, MI, std::size_t> {
using Matrix = MI[max_y_][max_x_][max_l_];
using Matrix_Int = MI;
using IS = std::size_t;
using is_jagged = std::false_type;
Matrix& mat;
IS layer_;
CE MatrixWrapper(Matrix& mat, CS IS layer) NE : mat(mat), layer_(layer) {}
DVCC
MatrixWrapper(Matrix& mat, CS IS layer, CS IS max_x, CS IS max_y) : mat(mat), layer_(layer) { assert(max_x_ == max_x); assert(max_y_ == max_y); }
CE IS getX() CS NE { RT max_x_; }
CE IS getY() CS NE { RT max_y_; }
Matrix_Int& operator()(IS x, IS y) NE { RT mat[y][x][layer_]; }
};
TP<TN MI, std::size_t max_x_, std::size_t max_l_>
struct MatrixWrapper<MI(*)[max_x_][max_l_]>
: MatrixBase<MatrixWrapper<MI(*)[max_x_][max_l_]>, MI, std::size_t> {
using Matrix = MI(*)[max_x_][max_l_];
using Matrix_Int = MI;
using IS = std::size_t;
using is_jagged = std::false_type;
Matrix mat;
IS layer_;
IS max_y_;
DVCC
MatrixWrapper(Matrix mat, CS IS layer, CS IS max_x, CS IS max_y) : mat(mat), layer_(layer), max_y_(max_y) { assert(max_x_ == max_x); }
CE IS getX() CS NE { RT max_x_; }
CE IS getY() CS NE { RT max_y_; }
Matrix_Int& operator()(IS x, IS y) NE { RT mat[y][x][layer_]; }
};
TP<TN MI, std::size_t max_y_, std::size_t max_x_>
struct MatrixWrapper<array2D<MI, max_x_, max_y_>>
: MatrixBase<MatrixWrapper<array2D<MI, max_x_, max_y_>>, MI, std::size_t> {
using Matrix = array2D<MI, max_x_, max_y_>;
using Matrix_Int = MI;
using IS = std::size_t;
using is_jagged = std::false_type;
Matrix& mat;
CE MatrixWrapper(Matrix& mat) NE : mat(mat) {}
DVCC
MatrixWrapper(Matrix& mat, CS IS max_x, CS IS max_y) : mat(mat) { assert(max_x_ == max_x); assert(max_y_ == max_y); }
CE IS getX() CS NE { RT max_x_; }
CE IS getY() CS NE { RT max_y_; }
Matrix_Int& operator()(IS x, IS y) NE { RT mat[y][x]; }
};
TP<TN MI, std::size_t max_y_, std::size_t max_x_, std::size_t max_l_>
struct MatrixWrapper<array3D<MI, max_l_, max_x_, max_y_>>
: MatrixBase<MatrixWrapper<array3D<MI, max_l_, max_x_, max_y_>>, MI, std::size_t> {
using Matrix = array3D<MI, max_l_, max_x_, max_y_>;
using Matrix_Int = MI;
using IS = std::size_t;
using is_jagged = std::false_type;
Matrix& mat;
IS layer_;
CE MatrixWrapper(Matrix& mat, CS IS layer) NE : mat(mat), layer_(layer) {}
CE IS getX() CS NE { RT max_x_; }
CE IS getY() CS NE { RT max_y_; }
Matrix_Int& operator()(IS x, IS y) NE { RT mat[y][x][layer_]; }
};
TP<TN MI, std::size_t max_len_>
struct MatrixWrapper<MI[max_len_]>
: MatrixBase<MatrixWrapper<MI[max_len_]>, MI, std::size_t> {
using Matrix = MI[max_len_];
using Matrix_Int = MI;
using IS = std::size_t;
using is_jagged = std::false_type;
Matrix& mat;
IS max_x_;
DVCC
MatrixWrapper(Matrix& mat, CS IS max_x, CS IS max_y) : mat(mat), max_x_(max_x) { assert(max_x * max_y == max_len_); }
CE IS getX() CS NE { RT max_x_; }
CE IS getY() CS NE { RT max_len_ / max_x_; }
Matrix_Int& operator()(IS x, IS y) NE { RT mat[y * max_x_ + x]; }
};
TP<TN MI>
struct MatrixWrapper<MI*>
: MatrixBase<MatrixWrapper<MI*>, MI, std::size_t> {
using Matrix = MI * ;
using Matrix_Int = MI;
using IS = std::size_t;
using is_jagged = std::false_type;
Matrix mat;
IS max_x_;
IS max_y_;
CE MatrixWrapper(Matrix mat, CS IS max_x, CS IS max_y) NE : mat(mat), max_x_(max_x), max_y_(max_y) {}
CE IS getX() CS NE { RT max_x_; }
CE IS getY() CS NE { RT max_y_; }
Matrix_Int& operator()(IS x, IS y) NE { RT mat[y * max_x_ + x]; }
};
TP<TN Matrix_>
struct MatrixWrapper<Matrix_, TN std::enable_if<is_STL2D<Matrix_>::value>::type>
: MatrixBase<MatrixWrapper<Matrix_, TN std::enable_if<is_STL2D<Matrix_>::value>::type>, TN Matrix_::value_type::value_type, TN Matrix_::size_type> {
using Matrix = Matrix_;
using Matrix_Int = TN Matrix_::value_type::value_type;
using IS = TN Matrix_::size_type;
using is_jagged = std::true_type;
Matrix& mat;
CE MatrixWrapper(Matrix& mat) NE : mat(mat) {}
CE IS getX() CS NE { RT mat.size() == 0 ? 0 : mat[0].size(); }
CE IS getX(CS IS i) CS NE { RT i >= mat.size() ? 0 : mat[i].size(); }
CE IS getY() CS NE { RT mat.size(); }
Matrix_Int& operator()(IS x, IS y) NE { RT mat[y][x]; }
};
TP<TN Matrix_>
struct MatrixWrapper<Matrix_, TN std::enable_if<is_STL3D<Matrix_>::value>::type>
: MatrixBase<MatrixWrapper<Matrix_, TN std::enable_if<is_STL3D<Matrix_>::value>::type>, TN Matrix_::value_type::value_type, TN Matrix_::size_type> {
using Matrix = Matrix_;
using Matrix_Int = TN Matrix_::value_type::value_type::value_type;
using IS = TN Matrix::size_type;
using is_jagged = std::true_type;
Matrix& mat;
IS layer_;
CE MatrixWrapper(Matrix& mat, CS IS layer) NE : mat(mat), layer_(layer) {}
CE IS getX() CS NE { RT mat.size() == 0 ? 0 : mat[0].size(); }
CE IS getX(CS IS i) CS NE { RT i >= mat.size() ? 0 : mat[i].size(); }
CE IS getY() CS NE { RT mat.size(); }
Matrix_Int& operator()(IS x, IS y) NE { RT mat[y][x][layer_]; }
};
TP<TN Matrix_, TN... Args_>
CE MatrixWrapper<TN std::remove_reference<Matrix_>::type> makeWrapper(Matrix_&& mat, Args_&&... args_) {
RT MatrixWrapper<TN std::remove_reference<Matrix_>::type>(mat, std::forward<Args_>(args_)...);
}
}
}
#endif 
NS dtl {
inline NS utility {
TP<TN Derived, TN MI>
class DrawJagged {
private:
using IS = dtl::type::size;
public:
TP<TN Matrix_>
CE BL draw(Matrix_ & matrix_) CS NE {
RT static_cast<CS Derived*>(this)->drawNormal(makeWrapper(matrix_));
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ & matrix_, Function_ && function_) CS NE {
RT static_cast<CS Derived*>(this)->drawNormal(makeWrapper(matrix_), function_);
}
TP<TN Matrix_>
CE BL draw(Matrix_ & matrix_, CS IS layer_) CS NE {
RT static_cast<CS Derived*>(this)->drawNormal(makeWrapper(matrix_, layer_));
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ & matrix_, CS IS layer_, Function_ && function_) CS NE {
RT static_cast<CS Derived*>(this)->drawNormal(makeWrapper(matrix_, layer_), function_);
}
TP<TN Matrix_>
CE BL draw(Matrix_ & matrix_, CS IS max_x_, CS IS max_y_) CS NE {
RT static_cast<CS Derived*>(this)->drawNormal(makeWrapper(matrix_, max_x_, max_y_));
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ & matrix_, CS IS max_x_, CS IS max_y_, Function_ && function_) CS NE {
RT static_cast<CS Derived*>(this)->drawNormal(makeWrapper(matrix_, max_x_, max_y_), function_);
}
TP<TN Matrix_>
CE BL draw(Matrix_ & matrix_, CS IS layer_, CS IS max_x_, CS IS max_y_) CS NE {
RT static_cast<CS Derived*>(this)->drawNormal(makeWrapper(matrix_, layer_, max_x_, max_y_));
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ & matrix_, CS IS layer_, CS IS max_x_, CS IS max_y_, Function_ && function_) CS NE {
RT static_cast<CS Derived*>(this)->drawNormal(makeWrapper(matrix_, layer_, max_x_, max_y_), function_);
}
TP<TN Matrix_>
CE BL drawArray(Matrix_ & matrix_, CS IS max_x_, CS IS max_y_) CS NE {
RT static_cast<CS Derived*>(this)->drawNormal(makeWrapper(matrix_, max_x_, max_y_));
}
TP<TN Matrix_, TN Function_>
CE BL drawOperatorArray(Matrix_ & matrix_, CS IS max_x_, CS IS max_y_, Function_ && function_) CS NE {
RT static_cast<CS Derived*>(this)->drawNormal(makeWrapper(matrix_, max_x_, max_y_), function_);
}
TP<TN Matrix_, TN ...Args_>
CE BL operator()(Matrix_& matrix_, Args_&& ... args_) CS NE {
RT this->draw(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& create(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->draw(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createArray(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->drawArray(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createOperator(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->drawOperator(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createOperatorArray(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->drawOperatorArray(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
};
}
}
#endif 
#ifndef IDTL_DTL_UTILITY_RECT_BASE_WITH_VALUE
#define IDTL_DTL_UTILITY_RECT_BASE_WITH_VALUE
NS dtl {
inline NS utility {
TP<TN Derived, TN MI>
class RectBaseWithValue {
private:
using IS = dtl::type::size;
protected:
IS start_x{};
IS start_y{};
IS width{};
IS height{};
MI draw_value{};
CE IS calcEndX(CS IS max_x_) CS NE {
RT (this->width == 0 || this->start_x + this->width >= max_x_)
? max_x_
: this->start_x + this->width;
}
CE IS calcEndY(CS IS max_y_) CS NE {
RT (this->height == 0 || this->start_y + this->height >= max_y_)
? max_y_
: this->start_y + this->height;
}
public:
DVCN
CE IS getPointX() CS NE {
RT this->start_x;
}
DVCN
CE IS getPointY() CS NE {
RT this->start_y;
}
DVCN
CE IS getWidth() CS NE {
RT this->width;
}
DVCN
CE IS getHeight() CS NE {
RT this->height;
}
DVCN
CE MI getValue() CS NE {
RT this->draw_value;
}
DVCC
Derived& clearPointX() NE {
this->start_x = 0;
RT static_cast<Derived&>(*this);
}
DVCC
Derived& clearPointY() NE {
this->start_y = 0;
RT static_cast<Derived&>(*this);
}
DVCC
Derived& clearWidth() NE {
this->width = 0;
RT static_cast<Derived&>(*this);
}
DVCC
Derived& clearHeight() NE {
this->height = 0;
RT static_cast<Derived&>(*this);
}
DVCC
Derived& clearValue() NE {
CS MI new_draw_value{};
this->draw_value = new_draw_value;
RT static_cast<Derived&>(*this);
}
DVCC
Derived& clearPoint() NE {
this->clearPointX();
this->clearPointY();
RT static_cast<Derived&>(*this);
}
DVCC
Derived& clearRange() NE {
this->clearPointX();
this->clearPointY();
this->clearWidth();
this->clearHeight();
RT static_cast<Derived&>(*this);
}
DVCC
Derived& clear() NE {
this->clearRange();
this->clearValue();
RT static_cast<Derived&>(*this);
}
DVCC
Derived& setPointX(CS IS start_x_) NE {
this->start_x = start_x_;
RT static_cast<Derived&>(*this);
}
DVCC
Derived& setPointY(CS IS start_y_) NE {
this->start_y = start_y_;
RT static_cast<Derived&>(*this);
}
DVCC
Derived& setWidth(CS IS width_) NE {
this->width = width_;
RT static_cast<Derived&>(*this);
}
DVCC
Derived& setHeight(CS IS height_) NE {
this->height = height_;
RT static_cast<Derived&>(*this);
}
DVCC
Derived& setValue(CS MI& draw_value_) NE {
this->draw_value = draw_value_;
RT static_cast<Derived&>(*this);
}
DVCC
Derived& setPoint(CS IS point_) NE {
this->start_x = point_;
this->start_y = point_;
RT static_cast<Derived&>(*this);
}
DVCC
Derived& setPoint(CS IS start_x_, CS IS start_y_) NE {
this->start_x = start_x_;
this->start_y = start_y_;
RT static_cast<Derived&>(*this);
}
DVCC
Derived& setRange(CS IS start_x_, CS IS start_y_, CS IS length_) NE {
this->start_x = start_x_;
this->start_y = start_y_;
this->width = length_;
this->height = length_;
RT static_cast<Derived&>(*this);
}
DVCC
Derived& setRange(CS IS start_x_, CS IS start_y_, CS IS width_, CS IS height_) NE {
this->start_x = start_x_;
this->start_y = start_y_;
this->width = width_;
this->height = height_;
RT static_cast<Derived&>(*this);
}
DVCC
Derived& setRange(CS dtl::base::MatrixRange& matrix_range_) NE {
this->start_x = matrix_range_.x;
this->start_y = matrix_range_.y;
this->width = matrix_range_.w;
this->height = matrix_range_.h;
RT static_cast<Derived&>(*this);
}
CE RectBaseWithValue() NE = default;
CE explicit RectBaseWithValue(CS MI & draw_value_) NE
:draw_value(draw_value_) {}
CE explicit RectBaseWithValue(CS dtl::base::MatrixRange & matrix_range_) NE
:start_x(matrix_range_.x), start_y(matrix_range_.y),
width(matrix_range_.w), height(matrix_range_.h) {}
CE explicit RectBaseWithValue(CS dtl::base::MatrixRange & matrix_range_, CS MI & draw_value_) NE
:start_x(matrix_range_.x), start_y(matrix_range_.y),
width(matrix_range_.w), height(matrix_range_.h),
draw_value(draw_value_) {}
CE explicit RectBaseWithValue(CS IS start_x_, CS IS start_y_, CS IS width_, CS IS height_) NE
:start_x(start_x_), start_y(start_y_),
width(width_), height(height_) {}
CE explicit RectBaseWithValue(CS IS start_x_, CS IS start_y_, CS IS width_, CS IS height_, CS MI & draw_value_) NE
:start_x(start_x_), start_y(start_y_),
width(width_), height(height_),
draw_value(draw_value_) {}
};
}
}
#endif 
NS dtl {
inline NS shape {
TP<TN MI>
class AbsoluteRect : public RectBaseWithValue<AbsoluteRect<MI>, MI>,
public DrawJagged<AbsoluteRect<MI>, MI> {
private:
using IS = dtl::type::size;
using ShapeBase_t = RectBaseWithValue<AbsoluteRect<MI>, MI>;
using DrawBase_t = DrawJagged<AbsoluteRect<MI>, MI>;
friend DrawBase_t;
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawNormal(Matrix_ && matrix_, Args_ && ... args_) CS NE {
CS IS end_x_ = this->calcEndX(matrix_.getX());
CS IS end_y_ = this->calcEndY(matrix_.getY());
for (IS i{ this->start_y }; i < end_y_; ++i)
for (IS j{ this->start_x }; j < end_x_; ++j)
matrix_.set(j, i, this->draw_value, args_...);
RT true;
}
public:
using ShapeBase_t::ShapeBase_t;
};
}
}
#endif 
NS dtl {
inline NS shape {
TP<TN MI>
class AbsoluteMemberRect {
private:
using IS = dtl::type::size;
dtl::shape::AbsoluteRect<MI> absoluteRect{};
public:
DVCN
CE IS getPointX() CS NE {
RT this->absoluteRect.getPointX();
}
DVCN
CE IS getPointY() CS NE {
RT this->absoluteRect.getPointY();
}
DVCN
CE IS getWidth() CS NE {
RT this->absoluteRect.getWidth();
}
DVCN
CE IS getHeight() CS NE {
RT this->absoluteRect.getHeight();
}
DVCN
CE MI getValue() CS NE {
RT this->absoluteRect.getValue();
}
TP<TN Matrix_, TN ...Args_>
CE BL draw(Matrix_&& matrix_, Args_&& ... args_) CS NE {
RT this->absoluteRect.draw(DTL_TYPE_FORWARD<Matrix_>(matrix_), DTL_TYPE_FORWARD<Args_>(args_)...);
}
TP<TN Matrix_, TN ...Args_>
CE BL drawOperator(Matrix_&& matrix_, Args_&& ... args_) CS NE {
RT this->absoluteRect.drawOperator(DTL_TYPE_FORWARD<Matrix_>(matrix_), DTL_TYPE_FORWARD<Args_>(args_)...);
}
TP<TN Matrix_, TN ...Args_>
CE BL drawArray(Matrix_&& matrix_, Args_&& ... args_) CS NE {
RT this->absoluteRect.drawArray(DTL_TYPE_FORWARD<Matrix_>(matrix_), DTL_TYPE_FORWARD<Args_>(args_)...);
}
TP<TN Matrix_, TN ...Args_>
CE BL drawOperatorArray(Matrix_&& matrix_, Args_&& ... args_) CS NE {
RT this->absoluteRect.drawOperatorArray(DTL_TYPE_FORWARD<Matrix_>(matrix_), DTL_TYPE_FORWARD<Args_>(args_)...);
}
TP<TN Matrix_, TN ...Args_>
CE BL operator()(Matrix_&& matrix_, Args_&& ... args_) CS NE {
RT this->draw(DTL_TYPE_FORWARD<Matrix_>(matrix_), DTL_TYPE_FORWARD<Args_>(args_)...);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& create(Matrix_&& matrix_, Args_&& ... args_) CS NE {
this->draw(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createArray(Matrix_&& matrix_, Args_&& ... args_) CS NE {
this->drawArray(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createOperator(Matrix_&& matrix_, Args_&& ... args_) CS NE {
this->drawOperator(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createOperatorArray(Matrix_&& matrix_, Args_&& ... args_) CS NE {
this->drawOperatorArray(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
DVCC
AbsoluteMemberRect& clearPointX() NE {
this->absoluteRect.clearPointX();
RT *this;
}
DVCC
AbsoluteMemberRect& clearPointY() NE {
this->absoluteRect.clearPointY();
RT *this;
}
DVCC
AbsoluteMemberRect& clearWidth() NE {
this->absoluteRect.clearWidth();
RT *this;
}
DVCC
AbsoluteMemberRect& clearHeight() NE {
this->absoluteRect.clearHeight();
RT *this;
}
DVCC
AbsoluteMemberRect& clearValue() NE {
this->absoluteRect.clearValue();
RT *this;
}
DVCC
AbsoluteMemberRect& clearPoint() NE {
this->clearPointX();
this->clearPointY();
RT *this;
}
DVCC
AbsoluteMemberRect& clearRange() NE {
this->clearPointX();
this->clearPointY();
this->clearWidth();
this->clearHeight();
RT *this;
}
DVCC
AbsoluteMemberRect& clear() NE {
this->clearRange();
this->clearValue();
RT *this;
}
DVCC
AbsoluteMemberRect& setPointX(CS IS end_x_) NE {
this->absoluteRect.setPointX(end_x_);
RT *this;
}
DVCC
AbsoluteMemberRect& setPointY(CS IS end_y_) NE {
this->absoluteRect.setPointY(end_y_);
RT *this;
}
DVCC
AbsoluteMemberRect& setWidth(CS IS width_) NE {
this->absoluteRect.setWidth(width_);
RT *this;
}
DVCC
AbsoluteMemberRect& setHeight(CS IS height_) NE {
this->absoluteRect.setHeight(height_);
RT *this;
}
DVCC
AbsoluteMemberRect& setValue(CS MI& draw_value_) NE {
this->absoluteRect.setValue(draw_value_);
RT *this;
}
DVCC
AbsoluteMemberRect& setRange(CS dtl::base::MatrixRange& matrix_range_) NE {
this->absoluteRect.setRange(matrix_range_);
RT *this;
}
DVCC
AbsoluteMemberRect& setPoint(CS IS point_) NE {
this->setPointX(point_);
this->setPointY(point_);
RT *this;
}
DVCC
AbsoluteMemberRect& setPoint(CS IS end_x_, CS IS end_y_) NE {
this->setPointX(end_x_);
this->setPointY(end_y_);
RT *this;
}
DVCC
AbsoluteMemberRect& setRange(CS IS end_x_, CS IS end_y_, CS IS length_) NE {
this->setPointX(end_x_);
this->setPointY(end_y_);
this->setWidth(length_);
this->setHeight(length_);
RT *this;
}
DVCC
AbsoluteMemberRect& setRange(CS IS end_x_, CS IS end_y_, CS IS width_, CS IS height_) NE {
this->setPointX(end_x_);
this->setPointY(end_y_);
this->setWidth(width_);
this->setHeight(height_);
RT *this;
}
CE AbsoluteMemberRect() NE = default;
CE explicit AbsoluteMemberRect(CS MI& draw_value_) NE
:absoluteRect(draw_value_) {}
CE explicit AbsoluteMemberRect(CS dtl::base::MatrixRange& matrix_range_) NE
:absoluteRect(matrix_range_) {}
CE explicit AbsoluteMemberRect(CS dtl::base::MatrixRange& matrix_range_, CS MI& draw_value_) NE
:absoluteRect(matrix_range_, draw_value_) {}
CE explicit AbsoluteMemberRect(CS IS end_x_, CS IS end_y_, CS IS width_, CS IS height_) NE
:absoluteRect(end_x_, end_y_, width_, height_) {}
CE explicit AbsoluteMemberRect(CS IS end_x_, CS IS end_y_, CS IS width_, CS IS height_, CS MI& draw_value_) NE
:absoluteRect(end_x_, end_y_, width_, height_, draw_value_) {}
};
}
}
#endif 
#ifndef IDTL_DTL_SHAPE_BORDER
#define IDTL_DTL_SHAPE_BORDER
NS dtl {
inline NS shape {
TP<TN MI>
class Border {
private:
using IS = dtl::type::size;
IS start_x{};
IS start_y{};
IS width{};
IS height{};
MI draw_value{};
TP<TN Matrix_>
DVCC
inline void substitutionSTL(Matrix_&& matrix_, CS IS end_x_, CS IS end_y_) CS NE {
matrix_[end_y_][end_x_] = this->draw_value;
}
TP<TN Matrix_>
DVCC
inline void substitutionArray(Matrix_&& matrix_, CS IS end_x_, CS IS end_y_, CS IS max_x_) CS NE {
matrix_[end_y_ * max_x_ + end_x_] = this->draw_value;
}
TP<TN Matrix_>
DVCC
inline void substitutionLayer(Matrix_&& matrix_, CS IS layer_, CS IS end_x_, CS IS end_y_) CS NE {
matrix_[end_y_][end_x_][layer_] = this->draw_value;
}
TP<TN Matrix_, TN Function_>
DVCC
inline void substitutionSTL(Matrix_&& matrix_, CS IS end_x_, CS IS end_y_, Function_&& function_) CS NE {
if (function_(matrix_[end_y_][end_x_])) matrix_[end_y_][end_x_] = this->draw_value;
}
TP<TN Matrix_, TN Function_>
DVCC
inline void substitutionArray(Matrix_&& matrix_, CS IS end_x_, CS IS end_y_, CS IS max_x_, Function_&& function_) CS NE {
if (function_(matrix_[end_y_ * max_x_ + end_x_])) matrix_[end_y_ * max_x_ + end_x_] = this->draw_value;
}
TP<TN Matrix_, TN Function_>
DVCC
inline void substitutionLayer(Matrix_ && matrix_, CS IS layer_, CS IS end_x_, CS IS end_y_, Function_ && function_) CS NE {
if (function_(matrix_[end_y_][end_x_][layer_])) matrix_[end_y_][end_x_][layer_] = this->draw_value;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawSTL(Matrix_ && matrix_, CS IS end_y_, Args_ && ... args_) CS NE {
if (end_y_ == 0) RT true;
for (IS j{ this->start_x }; j < matrix_[this->start_y].size(); ++j)
this->substitutionSTL(matrix_, j, this->start_y, args_...);
for (IS j{ this->start_x }; j < matrix_[end_y_ - 1].size(); ++j)
this->substitutionSTL(matrix_, j, end_y_ - 1, args_...);
for (IS i{ this->start_y }; i < end_y_; ++i) {
if (matrix_[i].size() == 0) continue;
this->substitutionSTL(matrix_, this->start_x, i, args_...);
this->substitutionSTL(matrix_, matrix_[i].size() - 1, i, DTL_TYPE_FORWARD<Args_>(args_)...);
}
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawWidthSTL(Matrix_ && matrix_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
if (end_y_ == 0) RT true;
for (IS j{ this->start_x }; j < end_x_ && j < matrix_[this->start_y].size(); ++j)
this->substitutionSTL(matrix_, j, this->start_y, args_...);
for (IS j{ this->start_x }; j < end_x_ && j < matrix_[end_y_ - 1].size(); ++j)
this->substitutionSTL(matrix_, j, end_y_ - 1, args_...);
if (end_x_ == 0) RT true;
for (IS i{ this->start_y }; i < end_y_; ++i) {
if (matrix_[i].size() == 0) continue;
this->substitutionSTL(matrix_, this->start_x, i, args_...);
if (matrix_[i].size() <= end_x_) this->substitutionSTL(matrix_, matrix_[i].size() - 1, i, args_...);
else this->substitutionSTL(matrix_, end_x_ - 1, i, DTL_TYPE_FORWARD<Args_>(args_)...);
}
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawLayerSTL(Matrix_ && matrix_, CS IS layer_, CS IS end_y_, Args_ && ... args_) CS NE {
if (end_y_ == 0) RT true;
for (IS j{ this->start_x }; j < matrix_[this->start_y].size(); ++j)
this->substitutionLayer(matrix_, layer_, j, this->start_y, args_...);
for (IS j{ this->start_x }; j < matrix_[end_y_ - 1].size(); ++j)
this->substitutionLayer(matrix_, layer_, j, end_y_ - 1, args_...);
for (IS i{ this->start_y }; i < end_y_; ++i) {
if (matrix_[i].size() == 0) continue;
this->substitutionLayer(matrix_, layer_, this->start_x, i, args_...);
this->substitutionLayer(matrix_, layer_, matrix_[i].size() - 1, i, DTL_TYPE_FORWARD<Args_>(args_)...);
}
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawLayerWidthSTL(Matrix_ && matrix_, CS IS layer_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
if (end_y_ == 0) RT true;
for (IS j{ this->start_x }; j < end_x_ && j < matrix_[this->start_y].size(); ++j)
this->substitutionLayer(matrix_, layer_, j, this->start_y, args_...);
for (IS j{ this->start_x }; j < end_x_ && j < matrix_[end_y_ - 1].size(); ++j)
this->substitutionLayer(matrix_, layer_, j, end_y_ - 1, args_...);
if (end_x_ == 0) RT true;
for (IS i{ this->start_y }; i < end_y_; ++i) {
if (matrix_[i].size() == 0) continue;
this->substitutionLayer(matrix_, layer_, this->start_x, i, args_...);
if (matrix_[i].size() <= end_x_) this->substitutionLayer(matrix_, layer_, matrix_[i].size() - 1, i, args_...);
else this->substitutionLayer(matrix_, layer_, end_x_ - 1, i, DTL_TYPE_FORWARD<Args_>(args_)...);
}
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawNormal(Matrix_ && matrix_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
if (end_x_ == 0 || end_y_ == 0) RT true;
for (IS j{ this->start_x }; j < end_x_; ++j) {
this->substitutionSTL(matrix_, j, this->start_y, args_...);
this->substitutionSTL(matrix_, j, end_y_ - 1, args_...);
}
for (IS i{ this->start_y }; i < end_y_; ++i) {
this->substitutionSTL(matrix_, this->start_x, i, args_...);
this->substitutionSTL(matrix_, end_x_ - 1, i, DTL_TYPE_FORWARD<Args_>(args_)...);
}
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawLayerNormal(Matrix_ && matrix_, CS IS layer_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
if (end_x_ == 0 || end_y_ == 0) RT true;
for (IS j{ this->start_x }; j < end_x_; ++j) {
this->substitutionLayer(matrix_, layer_, j, this->start_y, args_...);
this->substitutionLayer(matrix_, layer_, j, end_y_ - 1, args_...);
}
for (IS i{ this->start_y }; i < end_y_; ++i) {
this->substitutionLayer(matrix_, layer_, this->start_x, i, args_...);
this->substitutionLayer(matrix_, layer_, end_x_ - 1, i, DTL_TYPE_FORWARD<Args_>(args_)...);
}
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawArray(Matrix_ && matrix_, CS IS end_x_, CS IS end_y_, CS IS max_x_, Args_ && ... args_) CS NE {
if (end_x_ == 0 || end_y_ == 0) RT true;
for (IS j{ this->start_x }; j < end_x_; ++j) {
this->substitutionArray(matrix_, j, this->start_y, max_x_, args_...);
this->substitutionArray(matrix_, j, end_y_ - 1, max_x_, args_...);
}
for (IS i{ this->start_y }; i < end_y_; ++i) {
this->substitutionArray(matrix_, this->start_x, i, max_x_, args_...);
this->substitutionArray(matrix_, end_x_ - 1, i, max_x_, DTL_TYPE_FORWARD<Args_>(args_)...);
}
RT true;
}
public:
DVCN
CE IS getPointX() CS NE {
RT this->start_x;
}
DVCN
CE IS getPointY() CS NE {
RT this->start_y;
}
DVCN
CE IS getWidth() CS NE {
RT this->width;
}
DVCN
CE IS getHeight() CS NE {
RT this->height;
}
DVCN
CE MI getValue() CS NE {
RT this->draw_value;
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_) CS NE {
RT (this->width == 0) ? this->drawSTL(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height) : this->drawWidthSTL(matrix_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, Function_ && function_) CS NE {
RT (this->width == 0) ? this->drawSTL(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_) : this->drawWidthSTL(matrix_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_, CS IS layer_) CS NE {
RT (this->width == 0) ? this->drawLayerSTL(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height) : this->drawLayerWidthSTL(matrix_, layer_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, CS IS layer_, Function_ && function_) CS NE {
RT (this->width == 0) ? this->drawLayerSTL(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_) : this->drawLayerWidthSTL(matrix_, layer_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_) CS NE {
RT this->drawNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_, Function_ && function_) CS NE {
RT this->drawNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_, CS IS layer_, CS IS max_x_, CS IS max_y_) CS NE {
RT this->drawLayerNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, CS IS layer_, CS IS max_x_, CS IS max_y_, Function_ && function_) CS NE {
RT this->drawLayerNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL drawArray(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_) CS NE {
RT this->drawArray(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, max_x_);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperatorArray(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_, Function_ && function_) CS NE {
RT this->drawArray(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, max_x_, function_);
}
TP<TN Matrix_, TN ...Args_>
CE BL operator()(Matrix_ && matrix_, Args_ && ... args_) CS NE {
RT this->draw(DTL_TYPE_FORWARD<Matrix_>(matrix_), DTL_TYPE_FORWARD<Args_>(args_)...);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& create(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->draw(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createArray(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->drawArray(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createOperator(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->drawOperator(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createOperatorArray(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->drawOperatorArray(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
DVCC
Border& clearPointX() NE {
this->start_x = 0;
RT *this;
}
DVCC
Border& clearPointY() NE {
this->start_y = 0;
RT *this;
}
DVCC
Border& clearWidth() NE {
this->width = 0;
RT *this;
}
DVCC
Border& clearHeight() NE {
this->height = 0;
RT *this;
}
DVCC
Border& clearValue() NE {
CS MI new_draw_value{};
this->draw_value = new_draw_value;
RT *this;
}
DVCC
Border& clearPoint() NE {
this->clearPointX();
this->clearPointY();
RT *this;
}
DVCC
Border& clearRange() NE {
this->clearPointX();
this->clearPointY();
this->clearWidth();
this->clearHeight();
RT *this;
}
DVCC
Border& clear() NE {
this->clearRange();
this->clearValue();
RT *this;
}
DVCC
Border& setPointX(CS IS end_x_) NE {
this->start_x = end_x_;
RT *this;
}
DVCC
Border& setPointY(CS IS end_y_) NE {
this->start_y = end_y_;
RT *this;
}
DVCC
Border& setWidth(CS IS width_) NE {
this->width = width_;
RT *this;
}
DVCC
Border& setHeight(CS IS height_) NE {
this->height = height_;
RT *this;
}
DVCC
Border& setValue(CS MI & draw_value_) NE {
this->draw_value = draw_value_;
RT *this;
}
DVCC
Border& setPoint(CS IS point_) NE {
this->start_x = point_;
this->start_y = point_;
RT *this;
}
DVCC
Border& setPoint(CS IS end_x_, CS IS end_y_) NE {
this->start_x = end_x_;
this->start_y = end_y_;
RT *this;
}
DVCC
Border& setRange(CS IS end_x_, CS IS end_y_, CS IS length_) NE {
this->start_x = end_x_;
this->start_y = end_y_;
this->width = length_;
this->height = length_;
RT *this;
}
DVCC
Border& setRange(CS IS end_x_, CS IS end_y_, CS IS width_, CS IS height_) NE {
this->start_x = end_x_;
this->start_y = end_y_;
this->width = width_;
this->height = height_;
RT *this;
}
DVCC
Border& setRange(CS dtl::base::MatrixRange & matrix_range_) NE {
this->start_x = matrix_range_.x;
this->start_y = matrix_range_.y;
this->width = matrix_range_.w;
this->height = matrix_range_.h;
RT *this;
}
CE Border() NE = default;
CE explicit Border(CS MI & draw_value_) NE
:draw_value(draw_value_) {}
CE explicit Border(CS dtl::base::MatrixRange & matrix_range_) NE
:start_x(matrix_range_.x), start_y(matrix_range_.y),
width(matrix_range_.w), height(matrix_range_.h) {}
CE explicit Border(CS dtl::base::MatrixRange & matrix_range_, CS MI & draw_value_) NE
:start_x(matrix_range_.x), start_y(matrix_range_.y),
width(matrix_range_.w), height(matrix_range_.h),
draw_value(draw_value_) {}
CE explicit Border(CS IS end_x_, CS IS end_y_, CS IS width_, CS IS height_) NE
:start_x(end_x_), start_y(end_y_),
width(width_), height(height_) {}
CE explicit Border(CS IS end_x_, CS IS end_y_, CS IS width_, CS IS height_, CS MI & draw_value_) NE
:start_x(end_x_), start_y(end_y_),
width(width_), height(height_),
draw_value(draw_value_) {}
};
}
}
#endif 
#ifndef IDTL_DTL_SHAPE_BORDER_ODD
#define IDTL_DTL_SHAPE_BORDER_ODD
NS dtl {
inline NS shape {
TP<TN MI>
class BorderOdd {
private:
using IS = dtl::type::size;
IS start_x{};
IS start_y{};
IS width{};
IS height{};
MI draw_value{};
TP<TN Matrix_>
DVCC
inline void substitutionSTL(Matrix_&& matrix_, CS IS end_x_, CS IS end_y_) CS NE {
matrix_[end_y_][end_x_] = this->draw_value;
}
TP<TN Matrix_>
DVCC
inline void substitutionArray(Matrix_&& matrix_, CS IS end_x_, CS IS end_y_, CS IS max_x_) CS NE {
matrix_[end_y_ * max_x_ + end_x_] = this->draw_value;
}
TP<TN Matrix_>
DVCC
inline void substitutionLayer(Matrix_&& matrix_, CS IS layer_, CS IS end_x_, CS IS end_y_) CS NE {
matrix_[end_y_][end_x_][layer_] = this->draw_value;
}
TP<TN Matrix_, TN Function_>
DVCC
inline void substitutionSTL(Matrix_&& matrix_, CS IS end_x_, CS IS end_y_, Function_&& function_) CS NE {
if (function_(matrix_[end_y_][end_x_])) matrix_[end_y_][end_x_] = this->draw_value;
}
TP<TN Matrix_, TN Function_>
DVCC
inline void substitutionArray(Matrix_&& matrix_, CS IS end_x_, CS IS end_y_, CS IS max_x_, Function_&& function_) CS NE {
if (function_(matrix_[end_y_ * max_x_ + end_x_])) matrix_[end_y_ * max_x_ + end_x_] = this->draw_value;
}
TP<TN Matrix_, TN Function_>
DVCC
inline void substitutionLayer(Matrix_ && matrix_, CS IS layer_, CS IS end_x_, CS IS end_y_, Function_ && function_) CS NE {
if (function_(matrix_[end_y_][end_x_][layer_])) matrix_[end_y_][end_x_][layer_] = this->draw_value;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawSTL(Matrix_ && matrix_, CS IS end_y_, Args_ && ... args_) CS NE {
if (end_y_ == 0) RT true;
for (IS j{ this->start_x }; j < matrix_[this->start_y].size(); ++j)
this->substitutionSTL(matrix_, j, start_y, args_...);
for (IS j{ this->start_x }; j < matrix_[end_y_ - 1].size(); ++j) {
if ((end_y_ - this->start_y) % 2 == 0) this->substitutionSTL(matrix_, j, end_y_ - 2, args_...);
this->substitutionSTL(matrix_, j, end_y_ - 1, args_...);
}
for (IS i{ this->start_y }; i < end_y_; ++i) {
if (matrix_[i].size() == 0) continue;
this->substitutionSTL(matrix_, start_x, i, args_...);
if ((matrix_[i].size() - this->start_x) % 2 == 0) this->substitutionSTL(matrix_, matrix_[i].size() - 2, i, args_...);
this->substitutionSTL(matrix_, matrix_[i].size() - 1, i, DTL_TYPE_FORWARD<Args_>(args_)...);
}
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawWidthSTL(Matrix_ && matrix_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
if (end_y_ < 2) RT true;
for (IS j{ this->start_x }; j < end_x_ && j < matrix_[this->start_y].size(); ++j)
this->substitutionSTL(matrix_, j, start_y, args_...);
for (IS j{ this->start_x }; j < end_x_ && j < matrix_[end_y_ - 1].size(); ++j) {
if ((end_y_ - this->start_y) % 2 == 0) this->substitutionSTL(matrix_, j, end_y_ - 2, args_...);
this->substitutionSTL(matrix_, j, end_y_ - 1, args_...);
}
if (end_x_ < 2) RT true;
for (IS i{ this->start_y }; i < end_y_; ++i) {
if (matrix_[i].size() == 0) continue;
this->substitutionSTL(matrix_, start_x, i, args_...);
if (matrix_[i].size() <= end_x_) {
if ((matrix_[i].size() - this->start_x) % 2 == 0) this->substitutionSTL(matrix_, matrix_[i].size() - 2, i, args_...);
this->substitutionSTL(matrix_, matrix_[i].size() - 1, i, args_...);
}
else {
if ((end_x_ - this->start_x) % 2 == 0) this->substitutionSTL(matrix_, end_x_ - 2, i, args_...);
this->substitutionSTL(matrix_, end_x_ - 1, i, DTL_TYPE_FORWARD<Args_>(args_)...);
}
}
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawLayerSTL(Matrix_ && matrix_, CS IS layer_, CS IS end_y_, Args_ && ... args_) CS NE {
if (end_y_ < 2) RT true;
for (IS j{ this->start_x }; j < matrix_[this->start_y].size(); ++j)
this->substitutionLayer(matrix_, layer_, j, start_y, args_...);
for (IS j{ this->start_x }; j < matrix_[end_y_ - 1].size(); ++j) {
if ((end_y_ - this->start_y) % 2 == 0) this->substitutionLayer(matrix_, layer_, j, end_y_ - 2, args_...);
this->substitutionLayer(matrix_, layer_, j, end_y_ - 1, args_...);
}
for (IS i{ this->start_y }; i < end_y_; ++i) {
if (matrix_[i].size() < 2) continue;
this->substitutionLayer(matrix_, layer_, start_x, i, args_...);
if ((matrix_[i].size() - this->start_x) % 2 == 0) this->substitutionLayer(matrix_, layer_, matrix_[i].size() - 2, i, args_...);
this->substitutionLayer(matrix_, layer_, matrix_[i].size() - 1, i, DTL_TYPE_FORWARD<Args_>(args_)...);
}
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawLayerWidthSTL(Matrix_ && matrix_, CS IS layer_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
if (end_y_ < 2) RT true;
for (IS j{ this->start_x }; j < end_x_ && j < matrix_[this->start_y].size(); ++j)
this->substitutionLayer(matrix_, layer_, j, start_y, args_...);
for (IS j{ this->start_x }; j < end_x_ && j < matrix_[end_y_ - 1].size(); ++j) {
if ((end_y_ - this->start_y) % 2 == 0) this->substitutionLayer(matrix_, layer_, j, end_y_ - 2, args_...);
this->substitutionLayer(matrix_, layer_, j, end_y_ - 1, args_...);
}
if (end_x_ < 2) RT true;
for (IS i{ this->start_y }; i < end_y_; ++i) {
if (matrix_[i].size() == 0) continue;
this->substitutionLayer(matrix_, layer_, start_x, i, args_...);
if (matrix_[i].size() <= end_x_) {
if ((matrix_[i].size() - this->start_x) % 2 == 0) this->substitutionLayer(matrix_, layer_, matrix_[i].size() - 2, i, args_...);
this->substitutionLayer(matrix_, layer_, matrix_[i].size() - 1, i, args_...);
}
else {
if ((end_x_ - this->start_x) % 2 == 0) this->substitutionLayer(matrix_, layer_, end_x_ - 2, i, args_...);
this->substitutionLayer(matrix_, layer_, end_x_ - 1, i, DTL_TYPE_FORWARD<Args_>(args_)...);
}
}
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawNormal(Matrix_ && matrix_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
if (end_x_ < 2 || end_y_ < 2) RT true;
for (IS j{ this->start_x }; j < end_x_; ++j) {
this->substitutionSTL(matrix_, j, start_y, args_...);
if ((end_y_ - this->start_y) % 2 == 0) this->substitutionSTL(matrix_, j, end_y_ - 2, args_...);
this->substitutionSTL(matrix_, j, end_y_ - 1, args_...);
}
for (IS i{ this->start_y }; i < end_y_; ++i) {
this->substitutionSTL(matrix_, start_x, i, args_...);
if ((end_x_ - this->start_x) % 2 == 0) this->substitutionSTL(matrix_, end_x_ - 2, i, args_...);
this->substitutionSTL(matrix_, end_x_ - 1, i, DTL_TYPE_FORWARD<Args_>(args_)...);
}
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawLayerNormal(Matrix_ && matrix_, CS IS layer_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
if (end_x_ < 2 || end_y_ < 2) RT true;
for (IS j{ this->start_x }; j < end_x_; ++j) {
this->substitutionLayer(matrix_, layer_, j, start_y, args_...);
if ((end_y_ - this->start_y) % 2 == 0) this->substitutionLayer(matrix_, layer_, j, end_y_ - 2, args_...);
this->substitutionLayer(matrix_, layer_, j, end_y_ - 1, args_...);
}
for (IS i{ this->start_y }; i < end_y_; ++i) {
this->substitutionLayer(matrix_, layer_, start_x, i, args_...);
if ((end_y_ - this->start_y) % 2 == 0) this->substitutionLayer(matrix_, layer_, end_x_ - 2, i, args_...);
this->substitutionLayer(matrix_, layer_, end_x_ - 1, i, DTL_TYPE_FORWARD<Args_>(args_)...);
}
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawArray(Matrix_ && matrix_, CS IS end_x_, CS IS end_y_, CS IS max_x_, Args_ && ... args_) CS NE {
if (end_x_ < 2 || end_y_ < 2) RT true;
for (IS j{ this->start_x }; j < end_x_; ++j) {
this->substitutionArray(matrix_, j, start_y, max_x_, args_...);
if ((end_y_ - this->start_y) % 2 == 0) this->substitutionArray(matrix_, j, end_y_ - 2, max_x_, args_...);
this->substitutionArray(matrix_, j, end_y_ - 1, max_x_, args_...);
}
for (IS i{ this->start_y }; i < end_y_; ++i) {
this->substitutionArray(matrix_, start_x, i, max_x_, args_...);
if ((end_y_ - this->start_y) % 2 == 0) this->substitutionArray(matrix_, end_x_ - 2, i, max_x_, args_...);
this->substitutionArray(matrix_, end_x_ - 1, i, max_x_, DTL_TYPE_FORWARD<Args_>(args_)...);
}
RT true;
}
public:
DVCN
CE IS getPointX() CS NE {
RT this->start_x;
}
DVCN
CE IS getPointY() CS NE {
RT this->start_y;
}
DVCN
CE IS getWidth() CS NE {
RT this->width;
}
DVCN
CE IS getHeight() CS NE {
RT this->height;
}
DVCN
CE MI getValue() CS NE {
RT this->draw_value;
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_) CS NE {
RT (this->width == 0) ? this->drawSTL(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height) : this->drawWidthSTL(matrix_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, Function_ && function_) CS NE {
RT (this->width == 0) ? this->drawSTL(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_) : this->drawWidthSTL(matrix_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_, CS IS layer_) CS NE {
RT (this->width == 0) ? this->drawLayerSTL(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height) : this->drawLayerWidthSTL(matrix_, layer_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, CS IS layer_, Function_ && function_) CS NE {
RT (this->width == 0) ? this->drawLayerSTL(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_) : this->drawLayerWidthSTL(matrix_, layer_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_) CS NE {
RT this->drawNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_, Function_ && function_) CS NE {
RT this->drawNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_, CS IS layer_, CS IS max_x_, CS IS max_y_) CS NE {
RT this->drawLayerNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, CS IS layer_, CS IS max_x_, CS IS max_y_, Function_ && function_) CS NE {
RT this->drawLayerNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL drawArray(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_) CS NE {
RT this->drawArray(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, max_x_);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperatorArray(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_, Function_ && function_) CS NE {
RT this->drawArray(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, max_x_, function_);
}
TP<TN Matrix_, TN ...Args_>
CE BL operator()(Matrix_ && matrix_, Args_ && ... args_) CS NE {
RT this->draw(DTL_TYPE_FORWARD<Matrix_>(matrix_), DTL_TYPE_FORWARD<Args_>(args_)...);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& create(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->draw(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createArray(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->drawArray(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createOperator(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->drawOperator(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createOperatorArray(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->drawOperatorArray(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
DVCC
BorderOdd& clearPointX() NE {
this->start_x = 0;
RT *this;
}
DVCC
BorderOdd& clearPointY() NE {
this->start_y = 0;
RT *this;
}
DVCC
BorderOdd& clearWidth() NE {
this->width = 0;
RT *this;
}
DVCC
BorderOdd& clearHeight() NE {
this->height = 0;
RT *this;
}
DVCC
BorderOdd& clearValue() NE {
CS MI new_draw_value{};
this->draw_value = new_draw_value;
RT *this;
}
DVCC
BorderOdd& clearPoint() NE {
this->clearPointX();
this->clearPointY();
RT *this;
}
DVCC
BorderOdd& clearRange() NE {
this->clearPointX();
this->clearPointY();
this->clearWidth();
this->clearHeight();
RT *this;
}
DVCC
BorderOdd& clear() NE {
this->clearRange();
this->clearValue();
RT *this;
}
DVCC
BorderOdd& setPointX(CS IS end_x_) NE {
this->start_x = end_x_;
RT *this;
}
DVCC
BorderOdd& setPointY(CS IS end_y_) NE {
this->start_y = end_y_;
RT *this;
}
DVCC
BorderOdd& setWidth(CS IS width_) NE {
this->width = width_;
RT *this;
}
DVCC
BorderOdd& setHeight(CS IS height_) NE {
this->height = height_;
RT *this;
}
DVCC
BorderOdd& setValue(CS MI & draw_value_) NE {
this->draw_value = draw_value_;
RT *this;
}
DVCC
BorderOdd& setPoint(CS IS point_) NE {
this->start_x = point_;
this->start_y = point_;
RT *this;
}
DVCC
BorderOdd& setPoint(CS IS end_x_, CS IS end_y_) NE {
this->start_x = end_x_;
this->start_y = end_y_;
RT *this;
}
DVCC
BorderOdd& setRange(CS IS end_x_, CS IS end_y_, CS IS length_) NE {
this->start_x = end_x_;
this->start_y = end_y_;
this->width = length_;
this->height = length_;
RT *this;
}
DVCC
BorderOdd& setRange(CS IS end_x_, CS IS end_y_, CS IS width_, CS IS height_) NE {
this->start_x = end_x_;
this->start_y = end_y_;
this->width = width_;
this->height = height_;
RT *this;
}
DVCC
BorderOdd& setRange(CS dtl::base::MatrixRange & matrix_range_) NE {
this->start_x = matrix_range_.x;
this->start_y = matrix_range_.y;
this->width = matrix_range_.w;
this->height = matrix_range_.h;
RT *this;
}
CE BorderOdd() NE = default;
CE explicit BorderOdd(CS MI & draw_value_) NE
:draw_value(draw_value_) {}
CE explicit BorderOdd(CS dtl::base::MatrixRange & matrix_range_) NE
:start_x(matrix_range_.x), start_y(matrix_range_.y),
width(matrix_range_.w), height(matrix_range_.h) {}
CE explicit BorderOdd(CS dtl::base::MatrixRange & matrix_range_, CS MI & draw_value_) NE
:start_x(matrix_range_.x), start_y(matrix_range_.y),
width(matrix_range_.w), height(matrix_range_.h),
draw_value(draw_value_) {}
CE explicit BorderOdd(CS IS end_x_, CS IS end_y_, CS IS width_, CS IS height_) NE
:start_x(end_x_), start_y(end_y_),
width(width_), height(height_) {}
CE explicit BorderOdd(CS IS end_x_, CS IS end_y_, CS IS width_, CS IS height_, CS MI & draw_value_) NE
:start_x(end_x_), start_y(end_y_),
width(width_), height(height_),
draw_value(draw_value_) {}
};
}
}
#endif 
#ifndef IDTL_DTL_SHAPE_CELLULAR_AUTOMATON_ISLAND
#define IDTL_DTL_SHAPE_CELLULAR_AUTOMATON_ISLAND
#ifndef IDTL_DTL_SHAPE_RANDOM_RECT
#define IDTL_DTL_SHAPE_RANDOM_RECT
NS dtl {
inline NS shape {
TP<TN MI>
class RandomRect {
private:
using IS = dtl::type::size;
IS start_x{};
IS start_y{};
IS width{};
IS height{};
MI draw_value{};
double probability_value{ 0.5 };
TP<TN Matrix_>
DVCC
inline void substitutionSTL(Matrix_&& matrix_, CS IS end_x_, CS IS end_y_) CS NE {
if (dtl::random::mt32bit.probability(probability_value)) matrix_[end_y_][end_x_] = this->draw_value;
}
TP<TN Matrix_>
DVCC
inline void substitutionArray(Matrix_&& matrix_, CS IS end_x_, CS IS end_y_, CS IS max_x_) CS NE {
if (dtl::random::mt32bit.probability(probability_value)) matrix_[end_y_ * max_x_ + end_x_] = this->draw_value;
}
TP<TN Matrix_>
DVCC
inline void substitutionLayer(Matrix_&& matrix_, CS IS layer_, CS IS end_x_, CS IS end_y_) CS NE {
if (dtl::random::mt32bit.probability(probability_value)) matrix_[end_y_][end_x_][layer_] = this->draw_value;
}
TP<TN Matrix_Value_>
DVCC
inline void substitutionList(Matrix_Value_&& matrix_) CS NE {
if (dtl::random::mt32bit.probability(probability_value)) matrix_ = this->draw_value;
}
TP<TN Matrix_, TN Function_>
DVCC
inline void substitutionSTL(Matrix_&& matrix_, CS IS end_x_, CS IS end_y_, Function_&& function_) CS NE {
if (function_(matrix_[end_y_][end_x_]) && dtl::random::mt32bit.probability(probability_value)) matrix_[end_y_][end_x_] = this->draw_value;
}
TP<TN Matrix_, TN Function_>
DVCC
inline void substitutionArray(Matrix_&& matrix_, CS IS end_x_, CS IS end_y_, CS IS max_x_, Function_&& function_) CS NE {
if (function_(matrix_[end_y_ * max_x_ + end_x_]) && dtl::random::mt32bit.probability(probability_value)) matrix_[end_y_ * max_x_ + end_x_] = this->draw_value;
}
TP<TN Matrix_, TN Function_>
DVCC
inline void substitutionLayer(Matrix_ && matrix_, CS IS layer_, CS IS end_x_, CS IS end_y_, Function_ && function_) CS NE {
if (function_(matrix_[end_y_][end_x_][layer_]) && dtl::random::mt32bit.probability(probability_value)) matrix_[end_y_][end_x_][layer_] = this->draw_value;
}
TP<TN Matrix_Value_, TN Function_>
DVCC
inline void substitutionList(Matrix_Value_&& matrix_, Function_&& function_) CS NE {
if (function_(matrix_) && dtl::random::mt32bit.probability(probability_value)) matrix_ = this->draw_value;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawSTL(Matrix_ && matrix_, CS IS end_y_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i)
for (IS j{ this->start_x }; j < matrix_[i].size(); ++j)
this->substitutionSTL(matrix_, j, i, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawWidthSTL(Matrix_ && matrix_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i)
for (IS j{ this->start_x }; j < matrix_[i].size() && j < end_x_; ++j)
this->substitutionSTL(matrix_, j, i, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawLayerSTL(Matrix_ && matrix_, CS IS layer_, CS IS end_y_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i)
for (IS j{ this->start_x }; j < matrix_[i].size(); ++j)
this->substitutionLayer(matrix_, layer_, j, i, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawLayerWidthSTL(Matrix_ && matrix_, CS IS layer_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i)
for (IS j{ this->start_x }; j < matrix_[i].size() && j < end_x_; ++j)
this->substitutionLayer(matrix_, layer_, j, i, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawNormal(Matrix_ && matrix_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i)
for (IS j{ this->start_x }; j < end_x_; ++j)
this->substitutionSTL(matrix_, j, i, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawLayerNormal(Matrix_ && matrix_, CS IS layer_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i)
for (IS j{ this->start_x }; j < end_x_; ++j)
this->substitutionLayer(matrix_, layer_, j, i, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawArray(Matrix_ && matrix_, CS IS end_x_, CS IS end_y_, CS IS max_x_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i)
for (IS j{ this->start_x }; j < end_x_; ++j)
this->substitutionArray(matrix_, j, i, max_x_, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawList(Matrix_&& matrix_, CS IS end_x_, CS IS end_y_, Args_&& ... args_) CS NE {
dtl::type::size row_count{}, col_count{};
for (auto&& i : matrix_) {
++row_count;
if (row_count <= this->start_y) continue;
if (end_y_ != 1 && row_count >= end_y_) break;
col_count = 0;
for (auto&& j : i) {
++col_count;
if (col_count <= this->start_x) continue;
if (end_x_ != 1 && col_count >= end_x_) break;
this->substitutionList(j, args_...);
}
}
RT true;
}
public:
DVCN
CE IS getPointX() CS NE {
RT this->start_x;
}
DVCN
CE IS getPointY() CS NE {
RT this->start_y;
}
DVCN
CE IS getWidth() CS NE {
RT this->width;
}
DVCN
CE IS getHeight() CS NE {
RT this->height;
}
DVCN
CE MI getValue() CS NE {
RT this->draw_value;
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_) CS NE {
RT (this->width == 0) ? this->drawSTL(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height) : this->drawWidthSTL(matrix_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, Function_ && function_) CS NE {
RT (this->width == 0) ? this->drawSTL(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_) : this->drawWidthSTL(matrix_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_, CS IS layer_) CS NE {
RT (this->width == 0) ? this->drawLayerSTL(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height) : this->drawLayerWidthSTL(matrix_, layer_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, CS IS layer_, Function_ && function_) CS NE {
RT (this->width == 0) ? this->drawLayerSTL(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_) : this->drawLayerWidthSTL(matrix_, layer_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_) CS NE {
RT this->drawNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_, Function_ && function_) CS NE {
RT this->drawNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_, CS IS layer_, CS IS max_x_, CS IS max_y_) CS NE {
RT this->drawLayerNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, CS IS layer_, CS IS max_x_, CS IS max_y_, Function_ && function_) CS NE {
RT this->drawLayerNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL drawArray(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_) CS NE {
RT this->drawArray(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, max_x_);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperatorArray(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_, Function_ && function_) CS NE {
RT this->drawArray(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, max_x_, function_);
}
TP<TN Matrix_>
CE BL drawList(Matrix_&& matrix_) CS NE {
RT this->drawList(DTL_TYPE_FORWARD<Matrix_>(matrix_), this->start_x + this->width + 1, this->start_y + this->height + 1);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperatorList(Matrix_ && matrix_, Function_ && function_) CS NE {
RT this->drawList(DTL_TYPE_FORWARD<Matrix_>(matrix_), this->start_x + this->width + 1, this->start_y + this->height + 1, function_);
}
TP<TN Matrix_, TN ...Args_>
CE BL operator()(Matrix_&& matrix_, Args_&& ... args_) CS NE {
RT this->draw(DTL_TYPE_FORWARD<Matrix_>(matrix_), DTL_TYPE_FORWARD<Args_>(args_)...);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& create(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->draw(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createArray(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->drawArray(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createOperator(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->drawOperator(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createOperatorArray(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->drawOperatorArray(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
DVCC
RandomRect& clearPointX() NE {
this->start_x = 0;
RT *this;
}
DVCC
RandomRect& clearPointY() NE {
this->start_y = 0;
RT *this;
}
DVCC
RandomRect& clearWidth() NE {
this->width = 0;
RT *this;
}
DVCC
RandomRect& clearHeight() NE {
this->height = 0;
RT *this;
}
DVCC
RandomRect& clearValue() NE {
CS MI new_draw_value{};
this->draw_value = new_draw_value;
RT *this;
}
DVCC
RandomRect& clearPoint() NE {
this->clearPointX();
this->clearPointY();
RT *this;
}
DVCC
RandomRect& clearRange() NE {
this->clearPointX();
this->clearPointY();
this->clearWidth();
this->clearHeight();
RT *this;
}
DVCC
RandomRect& clear() NE {
this->clearRange();
this->clearValue();
RT *this;
}
DVCC
RandomRect& setPointX(CS IS end_x_) NE {
this->start_x = end_x_;
RT *this;
}
DVCC
RandomRect& setPointY(CS IS end_y_) NE {
this->start_y = end_y_;
RT *this;
}
DVCC
RandomRect& setWidth(CS IS width_) NE {
this->width = width_;
RT *this;
}
DVCC
RandomRect& setHeight(CS IS height_) NE {
this->height = height_;
RT *this;
}
DVCC
RandomRect& setValue(CS MI& draw_value_) NE {
this->draw_value = draw_value_;
RT *this;
}
DVCC
RandomRect& setPoint(CS IS point_) NE {
this->start_x = point_;
this->start_y = point_;
RT *this;
}
DVCC
RandomRect& setPoint(CS IS end_x_, CS IS end_y_) NE {
this->start_x = end_x_;
this->start_y = end_y_;
RT *this;
}
DVCC
RandomRect& setRange(CS IS end_x_, CS IS end_y_, CS IS length_) NE {
this->start_x = end_x_;
this->start_y = end_y_;
this->width = length_;
this->height = length_;
RT *this;
}
DVCC
RandomRect& setRange(CS IS end_x_, CS IS end_y_, CS IS width_, CS IS height_) NE {
this->start_x = end_x_;
this->start_y = end_y_;
this->width = width_;
this->height = height_;
RT *this;
}
DVCC
RandomRect& setRange(CS dtl::base::MatrixRange& matrix_range_) NE {
this->start_x = matrix_range_.x;
this->start_y = matrix_range_.y;
this->width = matrix_range_.w;
this->height = matrix_range_.h;
RT *this;
}
CE RandomRect() NE = default;
CE explicit RandomRect(CS MI & draw_value_) NE
:draw_value(draw_value_) {}
CE explicit RandomRect(CS MI & draw_value_, CS double probability_) NE
:draw_value(draw_value_), probability_value(probability_) {}
CE explicit RandomRect(CS dtl::base::MatrixRange & matrix_range_) NE
:start_x(matrix_range_.x), start_y(matrix_range_.y),
width(matrix_range_.w), height(matrix_range_.h) {}
CE explicit RandomRect(CS dtl::base::MatrixRange & matrix_range_, CS MI & draw_value_) NE
:start_x(matrix_range_.x), start_y(matrix_range_.y),
width(matrix_range_.w), height(matrix_range_.h),
draw_value(draw_value_) {}
CE explicit RandomRect(CS dtl::base::MatrixRange & matrix_range_, CS MI & draw_value_, CS double probability_) NE
:start_x(matrix_range_.x), start_y(matrix_range_.y),
width(matrix_range_.w), height(matrix_range_.h),
draw_value(draw_value_), probability_value(probability_) {}
CE explicit RandomRect(CS IS end_x_, CS IS end_y_, CS IS width_, CS IS height_) NE
:start_x(end_x_), start_y(end_y_),
width(width_), height(height_) {}
CE explicit RandomRect(CS IS end_x_, CS IS end_y_, CS IS width_, CS IS height_, CS MI & draw_value_) NE
:start_x(end_x_), start_y(end_y_),
width(width_), height(height_),
draw_value(draw_value_) {}
CE explicit RandomRect(CS IS end_x_, CS IS end_y_, CS IS width_, CS IS height_, CS MI & draw_value_, CS double probability_) NE
:start_x(end_x_), start_y(end_y_),
width(width_), height(height_),
draw_value(draw_value_), probability_value(probability_) {}
};
}
}
#endif 
#ifndef IDTL_DTL_UTILITY_CELLULAR_AUTOMATON
#define IDTL_DTL_UTILITY_CELLULAR_AUTOMATON
NS dtl {
inline NS utility {
TP<TN MI>
class CellularAutomation {
private:
using IS = dtl::type::size;
IS start_x{};
IS start_y{};
IS width{};
IS height{};
TP<TN Matrix_>
DVCC
inline void switchSTL(Matrix_&& matrix_, CS IS point_x_, CS IS point_y_) CS NE {
switch (dtl::random::mt64bit_4.get()) {
case 0:matrix_[point_y_][point_x_] = matrix_[point_y_][point_x_ - 1]; break;
case 1:matrix_[point_y_][point_x_] = matrix_[point_y_][point_x_ + 1]; break;
case 2:matrix_[point_y_][point_x_] = matrix_[point_y_ - 1][point_x_]; break;
case 3:matrix_[point_y_][point_x_] = matrix_[point_y_ + 1][point_x_]; break;
}
}
TP<TN Matrix_>
DVCC
inline void switchArray(Matrix_&& matrix_, CS IS point_x_, CS IS point_y_, CS IS max_x_) CS NE {
switch (dtl::random::mt64bit_4.get()) {
case 0:matrix_[point_y_ * max_x_ + point_x_] = matrix_[point_y_ * max_x_ + point_x_ - 1]; break;
case 1:matrix_[point_y_ * max_x_ + point_x_] = matrix_[point_y_ * max_x_ + point_x_ + 1]; break;
case 2:matrix_[point_y_ * max_x_ + point_x_] = matrix_[(point_y_ - 1) * max_x_ + point_x_]; break;
case 3:matrix_[point_y_ * max_x_ + point_x_] = matrix_[(point_y_ + 1) * max_x_ + point_x_]; break;
}
}
TP<TN Matrix_>
DVCC
inline void switchLayer(Matrix_ && matrix_, CS IS layer_, CS IS point_x_, CS IS point_y_) CS NE {
switch (dtl::random::mt64bit_4.get()) {
case 0:matrix_[point_y_][point_x_][layer_] = matrix_[point_y_][point_x_ - 1][layer_]; break;
case 1:matrix_[point_y_][point_x_][layer_] = matrix_[point_y_][point_x_ + 1][layer_]; break;
case 2:matrix_[point_y_][point_x_][layer_] = matrix_[point_y_ - 1][point_x_][layer_]; break;
case 3:matrix_[point_y_][point_x_][layer_] = matrix_[point_y_ + 1][point_x_][layer_]; break;
}
}
TP<TN Matrix_>
DVCC
inline void substitutionSTL(Matrix_ && matrix_, CS IS point_x_, CS IS point_y_) CS NE {
if (matrix_[point_y_][point_x_ - 1] == matrix_[point_y_][point_x_ + 1] && matrix_[point_y_][point_x_ + 1] == matrix_[point_y_ - 1][point_x_] && matrix_[point_y_ - 1][point_x_] == matrix_[point_y_ + 1][point_x_])
matrix_[point_y_][point_x_] = matrix_[point_y_][point_x_ + 1];
else this->switchSTL(matrix_, point_x_, point_y_);
}
TP<TN Matrix_>
DVCC
inline void substitutionArray(Matrix_ && matrix_, CS IS point_x_, CS IS point_y_, CS IS max_x_) CS NE {
if (matrix_[point_y_ * max_x_ + point_x_ - 1] == matrix_[point_y_ * max_x_ + point_x_ + 1] && matrix_[point_y_ * max_x_ + point_x_ + 1] == matrix_[(point_y_ - 1) * max_x_ + point_x_] && matrix_[(point_y_ - 1) * max_x_ + point_x_] == matrix_[(point_y_ + 1) * max_x_ + point_x_])
matrix_[point_y_ * max_x_ + point_x_] = matrix_[point_y_ * max_x_ + point_x_ + 1];
else this->switchArray(matrix_, point_x_, point_y_, max_x_);
}
TP<TN Matrix_>
DVCC
inline void substitutionLayer(Matrix_ && matrix_, CS IS layer_, CS IS point_x_, CS IS point_y_) CS NE {
if (matrix_[point_y_][point_x_ - 1][layer_] == matrix_[point_y_][point_x_ + 1][layer_] && matrix_[point_y_][point_x_ + 1][layer_] == matrix_[point_y_ - 1][point_x_][layer_] && matrix_[point_y_ - 1][point_x_][layer_] == matrix_[point_y_ + 1][point_x_][layer_])
matrix_[point_y_][point_x_][layer_] = matrix_[point_y_][point_x_ + 1][layer_];
else this->switchLayer(matrix_, layer_, point_x_, point_y_);
}
TP<TN Matrix_, TN Function_>
DVCC
inline void substitutionSTL(Matrix_ && matrix_, CS IS point_x_, CS IS point_y_, Function_ && function_) CS NE {
if (matrix_[point_y_][point_x_ - 1] == matrix_[point_y_][point_x_ + 1] && matrix_[point_y_][point_x_ + 1] == matrix_[point_y_ - 1][point_x_] && matrix_[point_y_ - 1][point_x_] == matrix_[point_y_ + 1][point_x_] && function_(matrix_[point_y_][point_x_]))
matrix_[point_y_][point_x_] = matrix_[point_y_][point_x_ + 1];
else this->switchSTL(matrix_, point_x_, point_y_);
}
TP<TN Matrix_, TN Function_>
DVCC
inline void substitutionArray(Matrix_ && matrix_, CS IS point_x_, CS IS point_y_, CS IS max_x_, Function_ && function_) CS NE {
if (matrix_[point_y_ * max_x_ + point_x_ - 1] == matrix_[point_y_ * max_x_ + point_x_ + 1] && matrix_[point_y_ * max_x_ + point_x_ + 1] == matrix_[(point_y_ - 1) * max_x_ + point_x_] && matrix_[(point_y_ - 1) * max_x_ + point_x_] == matrix_[(point_y_ + 1) * max_x_ + point_x_] && function_(matrix_[point_y_][point_x_]))
matrix_[point_y_ * max_x_ + point_x_] = matrix_[point_y_ * max_x_ + point_x_ + 1];
else this->switchArray(matrix_, point_x_, point_y_, max_x_);
}
TP<TN Matrix_, TN Function_>
DVCC
inline void substitutionLayer(Matrix_ && matrix_, CS IS layer_, CS IS point_x_, CS IS point_y_, Function_ && function_) CS NE {
if (matrix_[point_y_][point_x_ - 1][layer_] == matrix_[point_y_][point_x_ + 1][layer_] && matrix_[point_y_][point_x_ + 1][layer_] == matrix_[point_y_ - 1][point_x_][layer_] && matrix_[point_y_ - 1][point_x_][layer_] == matrix_[point_y_ + 1][point_x_][layer_] && function_(matrix_[point_y_][point_x_]))
matrix_[point_y_][point_x_][layer_] = matrix_[point_y_][point_x_ + 1][layer_];
else this->switchLayer(matrix_, layer_, point_x_, point_y_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawSTL(Matrix_ && matrix_, CS IS end_y_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y + 1 }; i < end_y_ - 1; ++i)
for (IS j{ this->start_x + 1 }; j < matrix_[i].size() - 1; ++j)
this->substitutionSTL(matrix_, j, i, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawWidthSTL(Matrix_ && matrix_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y + 1 }; i < end_y_ - 1; ++i)
for (IS j{ this->start_x + 1 }; j < matrix_[i].size() - 1 && j < end_x_ - 1; ++j)
this->substitutionSTL(matrix_, j, i, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawLayerSTL(Matrix_ && matrix_, CS IS layer_, CS IS end_y_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y + 1 }; i < end_y_ - 1; ++i)
for (IS j{ this->start_x + 1 }; j < matrix_[i].size() - 1; ++j)
this->substitutionLayer(matrix_, layer_, j, i, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawLayerWidthSTL(Matrix_ && matrix_, CS IS layer_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y + 1 }; i < end_y_ - 1; ++i)
for (IS j{ this->start_x + 1 }; j < matrix_[i].size() - 1 && j < end_x_ - 1; ++j)
this->substitutionLayer(matrix_, layer_, j, i, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawNormal(Matrix_ && matrix_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y + 1 }; i < end_y_ - 1; ++i)
for (IS j{ this->start_x + 1 }; j < end_x_ - 1; ++j)
this->substitutionSTL(matrix_, j, i, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawLayerNormal(Matrix_ && matrix_, CS IS layer_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y + 1 }; i < end_y_ - 1; ++i)
for (IS j{ this->start_x + 1 }; j < end_x_ - 1; ++j)
this->substitutionLayer(matrix_, layer_, j, i, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawArray(Matrix_ && matrix_, CS IS end_x_, CS IS end_y_, CS IS max_x_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y + 1 }; i < end_y_ - 1; ++i)
for (IS j{ this->start_x + 1 }; j < end_x_ - 1; ++j)
this->substitutionArray(matrix_, j, i, max_x_, args_...);
RT true;
}
public:
DVCN
CE IS getPointX() CS NE {
RT this->start_x;
}
DVCN
CE IS getPointY() CS NE {
RT this->start_y;
}
DVCN
CE IS getWidth() CS NE {
RT this->width;
}
DVCN
CE IS getHeight() CS NE {
RT this->height;
}
DVCN
CE MI getValue() CS NE {
RT this->draw_value;
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_) CS NE {
RT (this->width == 0) ? this->drawSTL(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height) : this->drawWidthSTL(matrix_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, Function_ && function_) CS NE {
RT (this->width == 0) ? this->drawSTL(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_) : this->drawWidthSTL(matrix_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_, CS IS layer_) CS NE {
RT (this->width == 0) ? this->drawLayerSTL(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height) : this->drawLayerWidthSTL(matrix_, layer_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, CS IS layer_, Function_ && function_) CS NE {
RT (this->width == 0) ? this->drawLayerSTL(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_) : this->drawLayerWidthSTL(matrix_, layer_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_) CS NE {
RT this->drawNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_, Function_ && function_) CS NE {
RT this->drawNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_, CS IS layer_, CS IS max_x_, CS IS max_y_) CS NE {
RT this->drawLayerNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, CS IS layer_, CS IS max_x_, CS IS max_y_, Function_ && function_) CS NE {
RT this->drawLayerNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL drawArray(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_) CS NE {
RT this->drawArray(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, max_x_);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperatorArray(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_, Function_ && function_) CS NE {
RT this->drawArray(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, max_x_, function_);
}
TP<TN Matrix_, TN ...Args_>
CE BL operator()(Matrix_ && matrix_, Args_ && ... args_) CS NE {
RT this->draw(DTL_TYPE_FORWARD<Matrix_>(matrix_), DTL_TYPE_FORWARD<Args_>(args_)...);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& create(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->draw(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createArray(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->drawArray(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createOperator(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->drawOperator(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createOperatorArray(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->drawOperatorArray(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
DVCC
CellularAutomation& clearPointX() NE {
this->start_x = 0;
RT *this;
}
DVCC
CellularAutomation& clearPointY() NE {
this->start_y = 0;
RT *this;
}
DVCC
CellularAutomation& clearWidth() NE {
this->width = 0;
RT *this;
}
DVCC
CellularAutomation& clearHeight() NE {
this->height = 0;
RT *this;
}
DVCC
CellularAutomation& clearPoint() NE {
this->clearPointX();
this->clearPointY();
RT *this;
}
DVCC
CellularAutomation& clearRange() NE {
this->clearPointX();
this->clearPointY();
this->clearWidth();
this->clearHeight();
RT *this;
}
DVCC
CellularAutomation& clear() NE {
this->clearRange();
RT *this;
}
DVCC
CellularAutomation& setPointX(CS IS start_x_) NE {
this->start_x = start_x_;
RT *this;
}
DVCC
CellularAutomation& setPointY(CS IS start_y_) NE {
this->start_y = start_y_;
RT *this;
}
DVCC
CellularAutomation& setWidth(CS IS width_) NE {
this->width = width_;
RT *this;
}
DVCC
CellularAutomation& setHeight(CS IS height_) NE {
this->height = height_;
RT *this;
}
DVCC
CellularAutomation& setPoint(CS IS point_) NE {
this->start_x = point_;
this->start_y = point_;
RT *this;
}
DVCC
CellularAutomation& setPoint(CS IS start_x_, CS IS start_y_) NE {
this->start_x = start_x_;
this->start_y = start_y_;
RT *this;
}
DVCC
CellularAutomation& setRange(CS IS start_x_, CS IS start_y_, CS IS length_) NE {
this->start_x = start_x_;
this->start_y = start_y_;
this->width = length_;
this->height = length_;
RT *this;
}
DVCC
CellularAutomation& setRange(CS IS start_x_, CS IS start_y_, CS IS width_, CS IS height_) NE {
this->start_x = start_x_;
this->start_y = start_y_;
this->width = width_;
this->height = height_;
RT *this;
}
DVCC
CellularAutomation& setRange(CS dtl::base::MatrixRange & matrix_range_) NE {
this->start_x = matrix_range_.x;
this->start_y = matrix_range_.y;
this->width = matrix_range_.w;
this->height = matrix_range_.h;
RT *this;
}
CE CellularAutomation() NE = default;
CE explicit CellularAutomation(CS dtl::base::MatrixRange & matrix_range_) NE
:start_x(matrix_range_.x), start_y(matrix_range_.y),
width(matrix_range_.w), height(matrix_range_.h) {}
CE explicit CellularAutomation(CS IS start_x_, CS IS start_y_, CS IS width_, CS IS height_) NE
:start_x(start_x_), start_y(start_y_),
width(width_), height(height_) {}
};
}
}
#endif 
NS dtl {
inline NS shape {
TP<TN MI>
class CellularAutomatonIsland {
private:
using IS = dtl::type::size;
dtl::shape::Border<MI> border{};
dtl::shape::RandomRect<MI> randomRect{};
dtl::utility::CellularAutomation<MI> cellularAutomation{};
IS loop_num{ 1 };
public:
DVCN
CE IS getPointX() CS NE {
RT this->border.getPointX();
}
DVCN
CE IS getPointY() CS NE {
RT this->border.getPointY();
}
DVCN
CE IS getWidth() CS NE {
RT this->border.getWidth();
}
DVCN
CE IS getHeight() CS NE {
RT this->border.getHeight();
}
DVCN
CE MI getValue() CS NE {
RT this->border.getValue();
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL draw(Matrix_&& matrix_, Args_&& ... args_) CS NE {
this->randomRect.draw(matrix_, args_...);
this->border.draw(matrix_, args_...);
for (IS i{}; i < loop_num; ++i)
this->cellularAutomation.draw(matrix_, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawOperator(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->randomRect.drawOperator(matrix_, args_...);
this->border.drawOperator(matrix_, args_...);
for (IS i{}; i < loop_num; ++i)
this->cellularAutomation.draw(matrix_, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawArray(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->randomRect.drawArray(matrix_, args_...);
this->border.drawArray(matrix_, args_...);
for (IS i{}; i < loop_num; ++i)
this->cellularAutomation.draw(matrix_, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawOperatorArray(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->randomRect.drawOperatorArray(matrix_, args_...);
this->border.drawOperatorArray(matrix_, args_...);
for (IS i{}; i < loop_num; ++i)
this->cellularAutomation.draw(matrix_, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
CE BL operator()(Matrix_&& matrix_, Args_&& ... args_) CS NE {
RT this->draw(DTL_TYPE_FORWARD<Matrix_>(matrix_), DTL_TYPE_FORWARD<Args_>(args_)...);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& create(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->draw(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createArray(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->drawArray(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createOperator(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->drawOperator(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createOperatorArray(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->drawOperatorArray(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
DVCC
CellularAutomatonIsland& clearPointX() NE {
this->randomRect.clearPointX();
this->border.clearPointX();
this->cellularAutomation.clearPointX();
RT *this;
}
DVCC
CellularAutomatonIsland& clearPointY() NE {
this->randomRect.clearPointY();
this->border.clearPointY();
this->cellularAutomation.clearPointY();
RT *this;
}
DVCC
CellularAutomatonIsland& clearWidth() NE {
this->randomRect.clearWidth();
this->border.clearWidth();
this->cellularAutomation.clearWidth();
RT *this;
}
DVCC
CellularAutomatonIsland& clearHeight() NE {
this->randomRect.clearHeight();
this->border.clearHeight();
this->cellularAutomation.clearHeight();
RT *this;
}
DVCC
CellularAutomatonIsland& clearValue() NE {
this->randomRect.clearValue();
this->border.clearValue();
this->cellularAutomation.clearValue();
RT *this;
}
DVCC
CellularAutomatonIsland& clearPoint() NE {
this->clearPointX();
this->clearPointY();
RT *this;
}
DVCC
CellularAutomatonIsland& clearRange() NE {
this->clearPointX();
this->clearPointY();
this->clearWidth();
this->clearHeight();
RT *this;
}
DVCC
CellularAutomatonIsland& clear() NE {
this->clearRange();
this->clearValue();
RT *this;
}
DVCC
CellularAutomatonIsland& setPointX(CS IS end_x_) NE {
this->randomRect.setPointX(end_x_);
this->border.setPointX(end_x_);
this->cellularAutomation.setPointX(end_x_);
RT *this;
}
DVCC
CellularAutomatonIsland& setPointY(CS IS end_y_) NE {
this->randomRect.setPointY(end_y_);
this->border.setPointY(end_y_);
this->cellularAutomation.setPointY(end_y_);
RT *this;
}
DVCC
CellularAutomatonIsland& setWidth(CS IS width_) NE {
this->randomRect.setWidth(width_);
this->border.setWidth(width_);
this->cellularAutomation.setWidth(width_);
RT *this;
}
DVCC
CellularAutomatonIsland& setHeight(CS IS height_) NE {
this->randomRect.setHeight(height_);
this->border.setHeight(height_);
this->cellularAutomation.setHeight(height_);
RT *this;
}
DVCC
CellularAutomatonIsland& setValue(CS MI& draw_value_) NE {
this->randomRect.setValue(draw_value_);
this->border.setValue(draw_value_);
this->cellularAutomation.setValue(draw_value_);
RT *this;
}
DVCC
CellularAutomatonIsland& setRange(CS dtl::base::MatrixRange& matrix_range_) NE {
this->randomRect.setRange(matrix_range_);
this->border.setRange(matrix_range_);
this->cellularAutomation.setRange(matrix_range_);
RT *this;
}
DVCC
CellularAutomatonIsland& setPoint(CS IS point_) NE {
this->setPointX(point_);
this->setPointY(point_);
RT *this;
}
DVCC
CellularAutomatonIsland& setPoint(CS IS end_x_, CS IS end_y_) NE {
this->setPointX(end_x_);
this->setPointY(end_y_);
RT *this;
}
DVCC
CellularAutomatonIsland& setRange(CS IS end_x_, CS IS end_y_, CS IS length_) NE {
this->setPointX(end_x_);
this->setPointY(end_y_);
this->setWidth(length_);
this->setHeight(length_);
RT *this;
}
DVCC
CellularAutomatonIsland& setRange(CS IS end_x_, CS IS end_y_, CS IS width_, CS IS height_) NE {
this->setPointX(end_x_);
this->setPointY(end_y_);
this->setWidth(width_);
this->setHeight(height_);
RT *this;
}
CE CellularAutomatonIsland() NE = default;
CE explicit CellularAutomatonIsland(CS MI & draw_value_) NE
:randomRect(draw_value_) {}
CE explicit CellularAutomatonIsland(CS MI & draw_value_, CS MI & draw_value2_) NE
:border(draw_value2_), randomRect(draw_value_) {}
CE explicit CellularAutomatonIsland(CS MI & draw_value_, CS MI & draw_value2_, CS IS & loop_num_) NE
:border(draw_value2_), randomRect(draw_value_), loop_num(loop_num_) {}
CE explicit CellularAutomatonIsland(CS MI & draw_value_, CS MI & draw_value2_, CS IS & loop_num_, CS double probability_) NE
:border(draw_value2_), randomRect(draw_value_, probability_), loop_num(loop_num_) {}
CE explicit CellularAutomatonIsland(CS IS end_x_, CS IS end_y_, CS IS width_, CS IS height_) NE
:border(end_x_, end_y_, width_, height_), randomRect(end_x_, end_y_, width_, height_) {}
CE explicit CellularAutomatonIsland(CS IS end_x_, CS IS end_y_, CS IS width_, CS IS height_, CS MI & draw_value_) NE
:border(end_x_, end_y_, width_, height_), randomRect(end_x_, end_y_, width_, height_, draw_value_) {}
CE explicit CellularAutomatonIsland(CS dtl::base::MatrixRange & matrix_range_) NE
:border(matrix_range_), randomRect(matrix_range_), cellularAutomation(matrix_range_) {}
CE explicit CellularAutomatonIsland(CS dtl::base::MatrixRange & matrix_range_, CS MI & draw_value_) NE
:randomRect(matrix_range_, draw_value_), cellularAutomation(matrix_range_) {}
CE explicit CellularAutomatonIsland(CS dtl::base::MatrixRange & matrix_range_, CS MI & draw_value_, CS MI & draw_value2_) NE
:border(matrix_range_, draw_value2_), randomRect(matrix_range_, draw_value_), cellularAutomation(matrix_range_) {}
CE explicit CellularAutomatonIsland(CS dtl::base::MatrixRange & matrix_range_, CS MI & draw_value_, CS MI & draw_value2_, CS IS & loop_num_) NE
:border(matrix_range_, draw_value2_), randomRect(matrix_range_, draw_value_), cellularAutomation(matrix_range_), loop_num(loop_num_) {}
CE explicit CellularAutomatonIsland(CS dtl::base::MatrixRange & matrix_range_, CS MI & draw_value_, CS MI & draw_value2_, CS IS & loop_num_, CS double probability_) NE
:border(matrix_range_, draw_value2_), randomRect(matrix_range_, draw_value_, probability_), cellularAutomation(matrix_range_), loop_num(loop_num_) {}
};
}
}
#endif 
#ifndef IDTL_DTL_SHAPE_CELLULAR_AUTOMATON_MIX_ISLAND
#define IDTL_DTL_SHAPE_CELLULAR_AUTOMATON_MIX_ISLAND
#ifndef IDTL_DTL_SHAPE_HALF_MIX_RECT
#define IDTL_DTL_SHAPE_HALF_MIX_RECT
#include <vector>
NS dtl {
inline NS shape {
TP<TN MI>
class HalfMixRect {
private:
using IS = dtl::type::size;
IS start_x{};
IS start_y{};
IS width{};
IS height{};
std::vector<MI> draw_value{};
DVCC
void string_String() CS NE {}
TP<TN Int_, TN ...Args_>
DVCC
void string_String(CS Int_& first_, CS Args_& ... args_) NE {
this->draw_value.emplace_back(static_cast<MI>(first_));
this->string_String(args_...);
}
TP<TN Matrix_>
DVCC
inline void substitutionSTL(Matrix_&& matrix_, CS IS end_x_, CS IS end_y_) CS NE {
matrix_[end_y_][end_x_] = ((dtl::random::mt32bit.probability()) ? this->draw_value.front() : this->draw_value[dtl::random::mt32bit.get<dtl::type::size>(draw_value.size())]);
}
TP<TN Matrix_>
DVCC
inline void substitutionArray(Matrix_ && matrix_, CS IS end_x_, CS IS end_y_, CS IS max_x_) CS NE {
matrix_[end_y_ * max_x_ + end_x_] = ((dtl::random::mt32bit.probability()) ? this->draw_value.front() : this->draw_value[dtl::random::mt32bit.get<dtl::type::size>(draw_value.size())]);
}
TP<TN Matrix_>
DVCC
inline void substitutionLayer(Matrix_ && matrix_, CS IS layer_, CS IS end_x_, CS IS end_y_) CS NE {
matrix_[end_y_][end_x_][layer_] = ((dtl::random::mt32bit.probability()) ? this->draw_value.front() : this->draw_value[dtl::random::mt32bit.get<dtl::type::size>(draw_value.size())]);
}
TP<TN Matrix_Value_>
DVCC
inline void substitutionList(Matrix_Value_&& matrix_) CS NE {
matrix_ = ((dtl::random::mt32bit.probability()) ? this->draw_value.front() : this->draw_value[dtl::random::mt32bit.get<dtl::type::size>(draw_value.size())]);
}
TP<TN Matrix_, TN Function_>
DVCC
inline void substitutionSTL(Matrix_ && matrix_, CS IS end_x_, CS IS end_y_, Function_ && function_) CS NE {
if (function_(matrix_[end_y_][end_x_])) matrix_[end_y_][end_x_] = ((dtl::random::mt32bit.probability()) ? this->draw_value.front() : this->draw_value[dtl::random::mt32bit.get<dtl::type::size>(draw_value.size())]);
}
TP<TN Matrix_, TN Function_>
DVCC
inline void substitutionArray(Matrix_ && matrix_, CS IS end_x_, CS IS end_y_, CS IS max_x_, Function_ && function_) CS NE {
if (function_(matrix_[end_y_ * max_x_ + end_x_])) matrix_[end_y_ * max_x_ + end_x_] = ((dtl::random::mt32bit.probability()) ? this->draw_value.front() : this->draw_value[dtl::random::mt32bit.get<dtl::type::size>(draw_value.size())]);
}
TP<TN Matrix_, TN Function_>
DVCC
inline void substitutionLayer(Matrix_ && matrix_, CS IS layer_, CS IS end_x_, CS IS end_y_, Function_ && function_) CS NE {
if (function_(matrix_[end_y_][end_x_][layer_])) matrix_[end_y_][end_x_][layer_] = ((dtl::random::mt32bit.probability()) ? this->draw_value.front() : this->draw_value[dtl::random::mt32bit.get<dtl::type::size>(draw_value.size())]);
}
TP<TN Matrix_Value_, TN Function_>
DVCC
inline void substitutionList(Matrix_Value_&& matrix_, Function_&& function_) CS NE {
if (function_(matrix_)) matrix_ = ((dtl::random::mt32bit.probability()) ? this->draw_value.front() : this->draw_value[dtl::random::mt32bit.get<dtl::type::size>(draw_value.size())]);
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawSTL(Matrix_ && matrix_, CS IS end_y_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i)
for (IS j{ this->start_x }; j < matrix_[i].size(); ++j)
this->substitutionSTL(matrix_, j, i, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawWidthSTL(Matrix_ && matrix_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i)
for (IS j{ this->start_x }; j < matrix_[i].size() && j < end_x_; ++j)
this->substitutionSTL(matrix_, j, i, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawLayerSTL(Matrix_ && matrix_, CS IS layer_, CS IS end_y_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i)
for (IS j{ this->start_x }; j < matrix_[i].size(); ++j)
this->substitutionLayer(matrix_, layer_, j, i, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawLayerWidthSTL(Matrix_ && matrix_, CS IS layer_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i)
for (IS j{ this->start_x }; j < matrix_[i].size() && j < end_x_; ++j)
this->substitutionLayer(matrix_, layer_, j, i, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawNormal(Matrix_ && matrix_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i)
for (IS j{ this->start_x }; j < end_x_; ++j)
this->substitutionSTL(matrix_, j, i, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawLayerNormal(Matrix_ && matrix_, CS IS layer_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i)
for (IS j{ this->start_x }; j < end_x_; ++j)
this->substitutionLayer(matrix_, layer_, j, i, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawArray(Matrix_ && matrix_, CS IS end_x_, CS IS end_y_, CS IS max_x_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i)
for (IS j{ this->start_x }; j < end_x_; ++j)
this->substitutionArray(matrix_, j, i, max_x_, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawList(Matrix_&& matrix_, CS IS end_x_, CS IS end_y_, Args_&& ... args_) CS NE {
dtl::type::size row_count{}, col_count{};
for (auto&& i : matrix_) {
++row_count;
if (row_count <= this->start_y) continue;
if (end_y_ != 1 && row_count >= end_y_) break;
col_count = 0;
for (auto&& j : i) {
++col_count;
if (col_count <= this->start_x) continue;
if (end_x_ != 1 && col_count >= end_x_) break;
this->substitutionList(j, args_...);
}
}
RT true;
}
public:
DVCN
CE IS getPointX() CS NE {
RT this->start_x;
}
DVCN
CE IS getPointY() CS NE {
RT this->start_y;
}
DVCN
CE IS getWidth() CS NE {
RT this->width;
}
DVCN
CE IS getHeight() CS NE {
RT this->height;
}
DVCN
DVCC
std::vector<MI> getValue() CS NE {
RT this->draw_value;
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_) CS NE {
RT (this->width == 0) ? this->drawSTL(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height) : this->drawWidthSTL(matrix_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, Function_ && function_) CS NE {
RT (this->width == 0) ? this->drawSTL(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_) : this->drawWidthSTL(matrix_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_, CS IS layer_) CS NE {
RT (this->width == 0) ? this->drawLayerSTL(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height) : this->drawLayerWidthSTL(matrix_, layer_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, CS IS layer_, Function_ && function_) CS NE {
RT (this->width == 0) ? this->drawLayerSTL(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_) : this->drawLayerWidthSTL(matrix_, layer_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_) CS NE {
RT this->drawNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_, Function_ && function_) CS NE {
RT this->drawNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_, CS IS layer_, CS IS max_x_, CS IS max_y_) CS NE {
RT this->drawLayerNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, CS IS layer_, CS IS max_x_, CS IS max_y_, Function_ && function_) CS NE {
RT this->drawLayerNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL drawArray(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_) CS NE {
RT this->drawArray(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, max_x_);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperatorArray(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_, Function_ && function_) CS NE {
RT this->drawArray(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, max_x_, function_);
}
TP<TN Matrix_>
DVCC
BL drawList(Matrix_&& matrix_) CS NE {
RT this->drawList(DTL_TYPE_FORWARD<Matrix_>(matrix_), this->start_x + this->width + 1, this->start_y + this->height + 1);
}
TP<TN Matrix_, TN Function_>
DVCC
BL drawOperatorList(Matrix_ && matrix_, Function_ && function_) CS NE {
RT this->drawList(DTL_TYPE_FORWARD<Matrix_>(matrix_), this->start_x + this->width + 1, this->start_y + this->height + 1, function_);
}
TP<TN Matrix_, TN ...Args_>
CE BL operator()(Matrix_&& matrix_, Args_&& ... args_) CS NE {
RT this->draw(DTL_TYPE_FORWARD<Matrix_>(matrix_), DTL_TYPE_FORWARD<Args_>(args_)...);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& create(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->draw(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createArray(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->drawArray(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createOperator(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->drawOperator(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createOperatorArray(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->drawOperatorArray(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
DVCC
HalfMixRect& clearPointX() NE {
this->start_x = 0;
RT *this;
}
DVCC
HalfMixRect& clearPointY() NE {
this->start_y = 0;
RT *this;
}
DVCC
HalfMixRect& clearWidth() NE {
this->width = 0;
RT *this;
}
DVCC
HalfMixRect& clearHeight() NE {
this->height = 0;
RT *this;
}
DVCC
HalfMixRect& clearValue() NE {
std::vector<MI> new_draw_value{};
this->draw_value = std::move(new_draw_value);
RT *this;
}
DVCC
HalfMixRect& clearPoint() NE {
this->clearPointX();
this->clearPointY();
RT *this;
}
DVCC
HalfMixRect& clearRange() NE {
this->clearPointX();
this->clearPointY();
this->clearWidth();
this->clearHeight();
RT *this;
}
DVCC
HalfMixRect& clear() NE {
this->clearRange();
this->clearValue();
RT *this;
}
DVCC
HalfMixRect& setPointX(CS IS end_x_) NE {
this->start_x = end_x_;
RT *this;
}
DVCC
HalfMixRect& setPointY(CS IS end_y_) NE {
this->start_y = end_y_;
RT *this;
}
DVCC
HalfMixRect& setWidth(CS IS width_) NE {
this->width = width_;
RT *this;
}
DVCC
HalfMixRect& setHeight(CS IS height_) NE {
this->height = height_;
RT *this;
}
DVCC
HalfMixRect& setValue(CS std::vector<MI>& draw_value_) NE {
this->draw_value = draw_value_;
RT *this;
}
TP<TN ...Args_>
DVCC
HalfMixRect& setValue(CS MI& first_, CS Args_& ... args_) NE {
this->string_String(first_, args_...);
RT *this;
}
DVCC
HalfMixRect& setPoint(CS IS point_) NE {
this->start_x = point_;
this->start_y = point_;
RT *this;
}
DVCC
HalfMixRect& setPoint(CS IS end_x_, CS IS end_y_) NE {
this->start_x = end_x_;
this->start_y = end_y_;
RT *this;
}
DVCC
HalfMixRect& setRange(CS IS end_x_, CS IS end_y_, CS IS length_) NE {
this->start_x = end_x_;
this->start_y = end_y_;
this->width = length_;
this->height = length_;
RT *this;
}
DVCC
HalfMixRect& setRange(CS IS end_x_, CS IS end_y_, CS IS width_, CS IS height_) NE {
this->start_x = end_x_;
this->start_y = end_y_;
this->width = width_;
this->height = height_;
RT *this;
}
DVCC
HalfMixRect& setRange(CS dtl::base::MatrixRange& matrix_range_) NE {
this->start_x = matrix_range_.x;
this->start_y = matrix_range_.y;
this->width = matrix_range_.w;
this->height = matrix_range_.h;
RT *this;
}
CE HalfMixRect() NE = default;
TP<TN ...Args_>
explicit HalfMixRect(CS MI & first_, CS Args_ & ... args_) NE {
this->string_String(first_, args_...);
}
CE explicit HalfMixRect(CS dtl::base::MatrixRange & matrix_range_) NE
:start_x(matrix_range_.x), start_y(matrix_range_.y),
width(matrix_range_.w), height(matrix_range_.h) {}
TP<TN ...Args_>
explicit HalfMixRect(CS dtl::base::MatrixRange & matrix_range_, CS MI & first_, CS Args_ & ... args_) NE
:start_x(matrix_range_.x), start_y(matrix_range_.y),
width(matrix_range_.w), height(matrix_range_.h) {
this->string_String(first_, args_...);
}
};
}
}
#endif 
NS dtl {
inline NS shape {
TP<TN MI>
class CellularAutomatonMixIsland {
private:
using IS = dtl::type::size;
dtl::shape::Border<MI> border{};
dtl::shape::HalfMixRect<MI> mixRect{};
dtl::utility::CellularAutomation<MI> cellularAutomation{};
IS loop_num{ 1 };
public:
DVCN
CE IS getPointX() CS NE {
RT this->border.getPointX();
}
DVCN
CE IS getPointY() CS NE {
RT this->border.getPointY();
}
DVCN
CE IS getWidth() CS NE {
RT this->border.getWidth();
}
DVCN
CE IS getHeight() CS NE {
RT this->border.getHeight();
}
DVCN
CE MI getValue() CS NE {
RT this->border.getValue();
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL draw(Matrix_&& matrix_, Args_&& ... args_) CS NE {
this->mixRect.draw(matrix_, args_...);
this->border.draw(matrix_, args_...);
for (IS i{}; i < this->loop_num; ++i)
this->cellularAutomation.draw(matrix_, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawOperator(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->mixRect.drawOperator(matrix_, args_...);
this->border.drawOperator(matrix_, args_...);
for (IS i{}; i < this->loop_num; ++i)
this->cellularAutomation.draw(matrix_, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawArray(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->mixRect.drawArray(matrix_, args_...);
this->border.drawArray(matrix_, args_...);
for (IS i{}; i < this->loop_num; ++i)
this->cellularAutomation.drawArray(matrix_, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawOperatorArray(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->mixRect.drawOperatorArray(matrix_, args_...);
this->border.drawOperatorArray(matrix_, args_...);
for (IS i{}; i < this->loop_num; ++i)
this->cellularAutomation.drawArray(matrix_, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
CE BL operator()(Matrix_&& matrix_, Args_&& ... args_) CS NE {
RT this->draw(DTL_TYPE_FORWARD<Matrix_>(matrix_), DTL_TYPE_FORWARD<Args_>(args_)...);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& create(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->draw(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createArray(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->drawArray(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createOperator(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->drawOperator(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createOperatorArray(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->drawOperatorArray(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
DVCC
CellularAutomatonMixIsland& clearPointX() NE {
this->mixRect.clearPointX();
this->border.clearPointX();
this->cellularAutomation.clearPointX();
RT *this;
}
DVCC
CellularAutomatonMixIsland& clearPointY() NE {
this->mixRect.clearPointY();
this->border.clearPointY();
this->cellularAutomation.clearPointY();
RT *this;
}
DVCC
CellularAutomatonMixIsland& clearWidth() NE {
this->mixRect.clearWidth();
this->border.clearWidth();
this->cellularAutomation.clearWidth();
RT *this;
}
DVCC
CellularAutomatonMixIsland& clearHeight() NE {
this->mixRect.clearHeight();
this->border.clearHeight();
this->cellularAutomation.clearHeight();
RT *this;
}
DVCC
CellularAutomatonMixIsland& clearValue() NE {
this->mixRect.clearValue();
this->border.clearValue();
this->cellularAutomation.clearValue();
RT *this;
}
DVCC
CellularAutomatonMixIsland& clearPoint() NE {
this->clearPointX();
this->clearPointY();
RT *this;
}
DVCC
CellularAutomatonMixIsland& clearRange() NE {
this->clearPointX();
this->clearPointY();
this->clearWidth();
this->clearHeight();
RT *this;
}
DVCC
CellularAutomatonMixIsland& clear() NE {
this->clearRange();
this->clearValue();
RT *this;
}
DVCC
CellularAutomatonMixIsland& setPointX(CS IS end_x_) NE {
this->mixRect.setPointX(end_x_);
this->border.setPointX(end_x_);
this->cellularAutomation.setPointX(end_x_);
RT *this;
}
DVCC
CellularAutomatonMixIsland& setPointY(CS IS end_y_) NE {
this->mixRect.setPointY(end_y_);
this->border.setPointY(end_y_);
this->cellularAutomation.setPointY(end_y_);
RT *this;
}
DVCC
CellularAutomatonMixIsland& setWidth(CS IS width_) NE {
this->mixRect.setWidth(width_);
this->border.setWidth(width_);
this->cellularAutomation.setWidth(width_);
RT *this;
}
DVCC
CellularAutomatonMixIsland& setHeight(CS IS height_) NE {
this->mixRect.setHeight(height_);
this->border.setHeight(height_);
this->cellularAutomation.setHeight(height_);
RT *this;
}
DVCC
CellularAutomatonMixIsland& setValue(CS MI& draw_value_) NE {
this->mixRect.setValue(draw_value_);
this->border.setValue(draw_value_);
this->cellularAutomation.setValue(draw_value_);
RT *this;
}
DVCC
CellularAutomatonMixIsland& setRange(CS dtl::base::MatrixRange& matrix_range_) NE {
this->mixRect.setRange(matrix_range_);
this->border.setRange(matrix_range_);
this->cellularAutomation.setRange(matrix_range_);
RT *this;
}
DVCC
CellularAutomatonMixIsland& setPoint(CS IS point_) NE {
this->setPointX(point_);
this->setPointY(point_);
RT *this;
}
DVCC
CellularAutomatonMixIsland& setPoint(CS IS end_x_, CS IS end_y_) NE {
this->setPointX(end_x_);
this->setPointY(end_y_);
RT *this;
}
DVCC
CellularAutomatonMixIsland& setRange(CS IS end_x_, CS IS end_y_, CS IS length_) NE {
this->setPointX(end_x_);
this->setPointY(end_y_);
this->setWidth(length_);
this->setHeight(length_);
RT *this;
}
DVCC
CellularAutomatonMixIsland& setRange(CS IS end_x_, CS IS end_y_, CS IS width_, CS IS height_) NE {
this->setPointX(end_x_);
this->setPointY(end_y_);
this->setWidth(width_);
this->setHeight(height_);
RT *this;
}
CE CellularAutomatonMixIsland() NE = default;
TP<TN ...Args_>
explicit CellularAutomatonMixIsland(CS IS & loop_num_, CS MI & first_, CS Args_ & ... args_) NE
:border(first_), mixRect(first_, args_...), loop_num(loop_num_) {}
TP<TN ...Args_>
CE explicit CellularAutomatonMixIsland(CS dtl::base::MatrixRange & matrix_range_, CS IS & loop_num_, CS MI & first_, CS Args_ & ... args_) NE
:border(matrix_range_, first_), mixRect(matrix_range_, first_, args_...), cellularAutomation(matrix_range_), loop_num(loop_num_) {}
};
}
}
#endif 
#ifndef IDTL_DTL_SHAPE_Diamond_CREATE_DIAMOND_SQARE_AVERAGE
#define IDTL_DTL_SHAPE_Diamond_CREATE_DIAMOND_SQARE_AVERAGE
NS dtl {
inline NS shape {
TP<TN MI, TN Matrix_, TN Function_>
DVCC
void createDiamondSquareAverageSTL(Matrix_&& matrix_, CS dtl::type::size start_x_, CS dtl::type::size start_y_, CS dtl::type::size x_, CS dtl::type::size y_, dtl::type::size size_, CS MI& t1_, CS MI& t2_, CS MI& t3_, CS MI& t4_, CS MI& max_value_, CS MI& add_altitude_, Function_&& func_) NE {
if (size_ == 0) RT;
CS MI & vertex_rand{ dtl::random::mt32bit.get<MI>(add_altitude_) };
CS MI & vertex_height{ static_cast<MI>((t1_ / 4 + t2_ / 4 + t3_ / 4 + t4_ / 4)) };
matrix_[start_y_ + y_][start_x_ + x_] = vertex_height + vertex_rand;
CS MI & s1{ static_cast<MI>((t1_ / 2 + t2_ / 2)) };
CS MI & s2{ static_cast<MI>((t1_ / 2 + t3_ / 2)) };
CS MI & s3{ static_cast<MI>((t2_ / 2 + t4_ / 2)) };
CS MI & s4{ static_cast<MI>((t3_ / 2 + t4_ / 2)) };
matrix_[start_y_ + y_ + size_][start_x_ + x_] = s3;
matrix_[start_y_ + y_ - size_][start_x_ + x_] = s2;
matrix_[start_y_ + y_][start_x_ + x_ + size_] = s4;
matrix_[start_y_ + y_][start_x_ + x_ - size_] = s1;
size_ /= 2;
createDiamondSquareAverageSTL<MI, Matrix_, Function_>(matrix_, start_x_, start_y_, x_ - size_, y_ - size_, size_, t1_, s1, s2, matrix_[start_y_ + y_][start_x_ + x_], max_value_, static_cast<MI>(func_(add_altitude_)), func_);
createDiamondSquareAverageSTL<MI, Matrix_, Function_>(matrix_, start_x_, start_y_, x_ - size_, y_ + size_, size_, s1, t2_, matrix_[start_y_ + y_][start_x_ + x_], s3, max_value_, static_cast<MI>(func_(add_altitude_)), func_);
createDiamondSquareAverageSTL<MI, Matrix_, Function_>(matrix_, start_x_, start_y_, x_ + size_, y_ - size_, size_, s2, matrix_[start_y_ + y_][start_x_ + x_], t3_, s4, max_value_, static_cast<MI>(func_(add_altitude_)), func_);
createDiamondSquareAverageSTL<MI, Matrix_, Function_>(matrix_, start_x_, start_y_, x_ + size_, y_ + size_, size_, matrix_[start_y_ + y_][start_x_ + x_], s3, s4, t4_, max_value_, static_cast<MI>(func_(add_altitude_)), func_);
}
TP<TN MI, TN Matrix_, TN Function_>
DVCC
void createDiamondSquareAverageArray(Matrix_ && matrix_, CS dtl::type::size max_x_, CS dtl::type::size start_x_, CS dtl::type::size start_y_, CS dtl::type::size x_, CS dtl::type::size y_, dtl::type::size size_, CS MI & t1_, CS MI & t2_, CS MI & t3_, CS MI & t4_, CS MI & max_value_, CS MI & add_altitude_, Function_ && func_) NE {
if (size_ == 0) RT;
CS MI & vertex_rand{ dtl::random::mt32bit.get<MI>(add_altitude_) };
CS MI & vertex_height{ static_cast<MI>((t1_ / 4 + t2_ / 4 + t3_ / 4 + t4_ / 4)) };
matrix_[(start_y_ + y_) * max_x_ + (start_x_ + x_)] = vertex_height + vertex_rand;
CS MI & s1{ static_cast<MI>((t1_ / 2 + t2_ / 2)) };
CS MI & s2{ static_cast<MI>((t1_ / 2 + t3_ / 2)) };
CS MI & s3{ static_cast<MI>((t2_ / 2 + t4_ / 2)) };
CS MI & s4{ static_cast<MI>((t3_ / 2 + t4_ / 2)) };
matrix_[(start_y_ + y_ + size_) * max_x_ + (start_x_ + x_)] = s3;
matrix_[(start_y_ + y_ - size_) * max_x_ + (start_x_ + x_)] = s2;
matrix_[(start_y_ + y_) * max_x_ + (start_x_ + x_ + size_)] = s4;
matrix_[(start_y_ + y_) * max_x_ + (start_x_ + x_ - size_)] = s1;
size_ /= 2;
createDiamondSquareAverageArray<MI, Matrix_, Function_>(matrix_, max_x_, start_x_, start_y_, x_ - size_, y_ - size_, size_, t1_, s1, s2, matrix_[(start_y_ + y_) * max_x_ + (start_x_ + x_)], max_value_, static_cast<MI>(func_(add_altitude_)), func_);
createDiamondSquareAverageArray<MI, Matrix_, Function_>(matrix_, max_x_, start_x_, start_y_, x_ - size_, y_ + size_, size_, s1, t2_, matrix_[(start_y_ + y_) * max_x_ + (start_x_ + x_)], s3, max_value_, static_cast<MI>(func_(add_altitude_)), func_);
createDiamondSquareAverageArray<MI, Matrix_, Function_>(matrix_, max_x_, start_x_, start_y_, x_ + size_, y_ - size_, size_, s2, matrix_[(start_y_ + y_) * max_x_ + (start_x_ + x_)], t3_, s4, max_value_, static_cast<MI>(func_(add_altitude_)), func_);
createDiamondSquareAverageArray<MI, Matrix_, Function_>(matrix_, max_x_, start_x_, start_y_, x_ + size_, y_ + size_, size_, matrix_[(start_y_ + y_) * max_x_ + (start_x_ + x_)], s3, s4, t4_, max_value_, static_cast<MI>(func_(add_altitude_)), func_);
}
TP<TN MI, TN Matrix_, TN Function_>
DVCC
void createDiamondSquareAverageLayer(Matrix_ && matrix_, CS dtl::type::size layer_, CS dtl::type::size start_x_, CS dtl::type::size start_y_, CS dtl::type::size x_, CS dtl::type::size y_, dtl::type::size size_, CS MI & t1_, CS MI & t2_, CS MI & t3_, CS MI & t4_, CS MI & max_value_, CS MI & add_altitude_, Function_ && func_) NE {
if (size_ == 0) RT;
CS MI & vertex_rand{ dtl::random::mt32bit.get<MI>(add_altitude_) };
CS MI & vertex_height{ static_cast<MI>((t1_ / 4 + t2_ / 4 + t3_ / 4 + t4_ / 4)) };
matrix_[start_y_ + y_][start_x_ + x_][layer_] = vertex_height + vertex_rand;
CS MI & s1{ static_cast<MI>((t1_ / 2 + t2_ / 2)) };
CS MI & s2{ static_cast<MI>((t1_ / 2 + t3_ / 2)) };
CS MI & s3{ static_cast<MI>((t2_ / 2 + t4_ / 2)) };
CS MI & s4{ static_cast<MI>((t3_ / 2 + t4_ / 2)) };
matrix_[start_y_ + y_ + size_][start_x_ + x_][layer_] = s3;
matrix_[start_y_ + y_ - size_][start_x_ + x_][layer_] = s2;
matrix_[start_y_ + y_][start_x_ + x_ + size_][layer_] = s4;
matrix_[start_y_ + y_][start_x_ + x_ - size_][layer_] = s1;
size_ /= 2;
createDiamondSquareAverageLayer<MI, Matrix_, Function_>(matrix_, layer_, start_x_, start_y_, x_ - size_, y_ - size_, size_, t1_, s1, s2, matrix_[start_y_ + y_][start_x_ + x_][layer_], max_value_, static_cast<MI>(func_(add_altitude_)), func_);
createDiamondSquareAverageLayer<MI, Matrix_, Function_>(matrix_, layer_, start_x_, start_y_, x_ - size_, y_ + size_, size_, s1, t2_, matrix_[start_y_ + y_][start_x_ + x_][layer_], s3, max_value_, static_cast<MI>(func_(add_altitude_)), func_);
createDiamondSquareAverageLayer<MI, Matrix_, Function_>(matrix_, layer_, start_x_, start_y_, x_ + size_, y_ - size_, size_, s2, matrix_[start_y_ + y_][start_x_ + x_][layer_], t3_, s4, max_value_, static_cast<MI>(func_(add_altitude_)), func_);
createDiamondSquareAverageLayer<MI, Matrix_, Function_>(matrix_, layer_, start_x_, start_y_, x_ + size_, y_ + size_, size_, matrix_[start_y_ + y_][start_x_ + x_][layer_], s3, s4, t4_, max_value_, static_cast<MI>(func_(add_altitude_)), func_);
}
}
}
#endif 
#ifndef IDTL_DTL_SHAPE_DIAMOND_SQARE_AVERAGE_CORNER_ISLAND
#define IDTL_DTL_SHAPE_DIAMOND_SQARE_AVERAGE_CORNER_ISLAND
#ifndef IDTL_DTL_TYPE_MIN
#define IDTL_DTL_TYPE_MIN
#ifndef DTL_TYPE_MIN
#if defined(SPROUT_ALGORITHM_MIN) 
#define DTL_TYPE_MIN (::sprout::min)
#else
#include <algorithm>
#define DTL_TYPE_MIN (std::min)
#endif
#endif
#endif 
NS dtl {
inline NS shape {
TP<TN MI>
class DiamondSquareAverageCornerIsland {
private:
using IS = dtl::type::size;
IS start_x{};
IS start_y{};
IS width{};
IS height{};
MI min_value{};
MI altitude{};
MI add_altitude{};
DVCN
DVCC
dtl::type::size getMatrixSize(CS IS matrix_size) CS NE {
dtl::type::size map_size{ 2 };
while (true) {
if ((map_size + 1) > matrix_size) RT map_size >>= 1;
map_size <<= 1;
}
RT 0;
}
TP<TN Matrix_, TN Function_>
DVCC
inline void substitutionSTL(Matrix_ && matrix_, CS IS map_size_, Function_ && function_) CS NE {
matrix_[this->start_y][this->start_x] = this->min_value + this->altitude;
matrix_[this->start_y][this->start_x + map_size_] = this->min_value + dtl::random::mt32bit.get<MI>(this->altitude);
matrix_[this->start_y + map_size_][this->start_x] = this->min_value + dtl::random::mt32bit.get<MI>(this->altitude);
matrix_[this->start_y + map_size_][this->start_x + map_size_] = this->min_value + dtl::random::mt32bit.get<MI>(this->altitude);
createDiamondSquareAverageSTL<MI, Matrix_>(matrix_, this->start_x, this->start_y, map_size_ / 2, map_size_ / 2, map_size_ / 2, matrix_[this->start_y][this->start_x], matrix_[this->start_y + map_size_][this->start_x], matrix_[this->start_y][this->start_x + map_size_], matrix_[this->start_y + map_size_][this->start_x + map_size_], this->min_value + this->altitude, this->add_altitude, function_);
}
TP<TN Matrix_, TN Function_>
DVCC
inline void substitutionArray(Matrix_ && matrix_, CS IS map_size_, CS IS max_x_, Function_ && function_) CS NE {
matrix_[(this->start_y)* max_x_ + (this->start_x)] = this->min_value + this->altitude;
matrix_[(this->start_y)* max_x_ + (this->start_x + map_size_)] = this->min_value + dtl::random::mt32bit.get<MI>(this->altitude);
matrix_[(this->start_y + map_size_) * max_x_ + (this->start_x)] = this->min_value + dtl::random::mt32bit.get<MI>(this->altitude);
matrix_[(this->start_y + map_size_) * max_x_ + (this->start_x + map_size_)] = this->min_value + dtl::random::mt32bit.get<MI>(this->altitude);
createDiamondSquareAverageArray<MI, Matrix_>(matrix_, max_x_, this->start_x, this->start_y, map_size_ / 2, map_size_ / 2, map_size_ / 2, matrix_[(this->start_y)* max_x_ + (this->start_x)], matrix_[(this->start_y + map_size_) * max_x_ + (this->start_x)], matrix_[(this->start_y)* max_x_ + (this->start_x + map_size_)], matrix_[(this->start_y + map_size_) * max_x_ + (this->start_x + map_size_)], this->min_value + this->altitude, this->add_altitude, function_);
}
TP<TN Matrix_, TN Function_>
DVCC
inline void substitutionLayer(Matrix_ && matrix_, CS IS layer_, CS IS map_size_, Function_ && function_) CS NE {
matrix_[this->start_y][this->start_x][layer_] = this->min_value + this->altitude;
matrix_[this->start_y][this->start_x + map_size_][layer_] = this->min_value + dtl::random::mt32bit.get<MI>(this->altitude);
matrix_[this->start_y + map_size_][this->start_x][layer_] = this->min_value + dtl::random::mt32bit.get<MI>(this->altitude);
matrix_[this->start_y + map_size_][this->start_x + map_size_][layer_] = this->min_value + dtl::random::mt32bit.get<MI>(this->altitude);
createDiamondSquareAverageLayer<MI, Matrix_>(matrix_, layer_, this->start_x, this->start_y, map_size_ / 2, map_size_ / 2, map_size_ / 2, matrix_[this->start_y][this->start_x][layer_], matrix_[this->start_y + map_size_][this->start_x][layer_], matrix_[this->start_y][this->start_x + map_size_][layer_], matrix_[this->start_y + map_size_][this->start_x + map_size_][layer_], this->min_value + this->altitude, this->add_altitude, function_);
}
TP<TN Matrix_>
DVCC
inline void substitutionSTL(Matrix_ && matrix_, CS IS map_size_) CS NE {
this->substitutionSTL(DTL_TYPE_FORWARD<Matrix_>(matrix_), map_size_, [](CS MI & value_) {RT value_ / 2; });
}
TP<TN Matrix_>
DVCC
inline void substitutionArray(Matrix_ && matrix_, CS IS map_size_, CS IS max_x_) CS NE {
this->substitutionArray(DTL_TYPE_FORWARD<Matrix_>(matrix_), max_x_, map_size_, [](CS MI & value_) {RT value_ / 2; });
}
TP<TN Matrix_>
DVCC
inline void substitutionLayer(Matrix_ && matrix_, CS IS layer_, CS IS map_size_) CS NE {
this->substitutionLayer(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, map_size_, [](CS MI & value_) {RT value_ / 2; });
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawSTL(Matrix_ && matrix_, CS IS end_y_, Args_ && ... args_) CS NE {
if (this->altitude < 2) RT false;
this->substitutionSTL(DTL_TYPE_FORWARD<Matrix_>(matrix_), getMatrixSize((end_y_ > matrix_[0].size()) ? matrix_[0].size() : end_y_), DTL_TYPE_FORWARD<Args_>(args_)...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawWidthSTL(Matrix_ && matrix_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
if (this->altitude < 2) RT false;
this->substitutionSTL(DTL_TYPE_FORWARD<Matrix_>(matrix_), getMatrixSize((end_y_ > DTL_TYPE_MIN(matrix_[0].size(), end_x_)) ? DTL_TYPE_MIN(matrix_[0].size(), end_x_) : end_y_), DTL_TYPE_FORWARD<Args_>(args_)...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawLayerSTL(Matrix_ && matrix_, CS IS layer_, CS IS end_y_, Args_ && ... args_) CS NE {
if (this->altitude < 2) RT false;
this->substitutionLayer(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, getMatrixSize((end_y_ > matrix_[0].size()) ? matrix_[0].size() : end_y_), DTL_TYPE_FORWARD<Args_>(args_)...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawLayerWidthSTL(Matrix_ && matrix_, CS IS layer_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
if (this->altitude < 2) RT false;
this->substitutionLayer(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, getMatrixSize((end_y_ > DTL_TYPE_MIN(matrix_[0].size(), end_x_)) ? DTL_TYPE_MIN(matrix_[0].size(), end_x_) : end_y_), DTL_TYPE_FORWARD<Args_>(args_)...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawNormal(Matrix_ && matrix_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
if (this->altitude < 2) RT false;
this->substitutionSTL(DTL_TYPE_FORWARD<Matrix_>(matrix_), getMatrixSize((end_y_ > end_x_) ? end_x_ : end_y_), DTL_TYPE_FORWARD<Args_>(args_)...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawLayerNormal(Matrix_ && matrix_, CS IS layer_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
if (this->altitude < 2) RT false;
this->substitutionLayer(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, getMatrixSize((end_y_ > end_x_) ? end_x_ : end_y_), DTL_TYPE_FORWARD<Args_>(args_)...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawArray(Matrix_ && matrix_, CS IS end_x_, CS IS end_y_, CS IS max_x_, Args_ && ... args_) CS NE {
if (this->altitude < 2) RT false;
this->substitutionArray(DTL_TYPE_FORWARD<Matrix_>(matrix_), getMatrixSize((end_y_ > end_x_) ? end_x_ : end_y_), max_x_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT true;
}
public:
DVCN
CE IS getPointX() CS NE {
RT this->start_x;
}
DVCN
CE IS getPointY() CS NE {
RT this->start_y;
}
DVCN
CE IS getWidth() CS NE {
RT this->width;
}
DVCN
CE IS getHeight() CS NE {
RT this->height;
}
DVCN
CE MI getMinValue() CS NE {
RT this->min_value;
}
DVCN
CE MI getAltitude() CS NE {
RT this->altitude;
}
DVCN
CE MI getAddAltitude() CS NE {
RT this->add_altitude;
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_) CS NE {
RT (this->width == 0) ? this->drawSTL(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height) : this->drawWidthSTL(matrix_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, Function_ && function_) CS NE {
RT (this->width == 0) ? this->drawSTL(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_) : this->drawWidthSTL(matrix_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_, CS IS layer_) CS NE {
RT (this->width == 0) ? this->drawLayerSTL(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height) : this->drawLayerWidthSTL(matrix_, layer_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, CS IS layer_, Function_ && function_) CS NE {
RT (this->width == 0) ? this->drawLayerSTL(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_) : this->drawLayerWidthSTL(matrix_, layer_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_) CS NE {
RT this->drawNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_, Function_ && function_) CS NE {
RT this->drawNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_, CS IS layer_, CS IS max_x_, CS IS max_y_) CS NE {
RT this->drawLayerNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, CS IS layer_, CS IS max_x_, CS IS max_y_, Function_ && function_) CS NE {
RT this->drawLayerNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL drawArray(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_) CS NE {
RT this->drawArray(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, max_x_);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperatorArray(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_, Function_ && function_) CS NE {
RT this->drawArray(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, max_x_, function_);
}
TP<TN Matrix_, TN ...Args_>
CE BL operator()(Matrix_&& matrix_, Args_&& ... args_) CS NE {
RT this->draw(DTL_TYPE_FORWARD<Matrix_>(matrix_), DTL_TYPE_FORWARD<Args_>(args_)...);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& create(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->draw(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createArray(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->drawArray(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createOperator(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->drawOperator(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createOperatorArray(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->drawOperatorArray(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
CE DiamondSquareAverageCornerIsland() NE = default;
CE explicit DiamondSquareAverageCornerIsland(CS MI & min_value_) NE
:min_value(min_value_) {}
CE explicit DiamondSquareAverageCornerIsland(CS MI & min_value_, CS MI & altitude_) NE
:min_value(min_value_), altitude(altitude_) {}
CE explicit DiamondSquareAverageCornerIsland(CS MI & min_value_, CS MI & altitude_, CS MI & add_altitude_) NE
:min_value(min_value_), altitude(altitude_), add_altitude(add_altitude_) {}
CE explicit DiamondSquareAverageCornerIsland(CS dtl::base::MatrixRange & matrix_range_) NE
:start_x(matrix_range_.x), start_y(matrix_range_.y),
width(matrix_range_.w), height(matrix_range_.h) {}
CE explicit DiamondSquareAverageCornerIsland(CS dtl::base::MatrixRange & matrix_range_, CS MI & min_value_) NE
:start_x(matrix_range_.x), start_y(matrix_range_.y),
width(matrix_range_.w), height(matrix_range_.h),
min_value(min_value_) {}
CE explicit DiamondSquareAverageCornerIsland(CS dtl::base::MatrixRange & matrix_range_, CS MI & min_value_, CS MI & altitude_) NE
:start_x(matrix_range_.x), start_y(matrix_range_.y),
width(matrix_range_.w), height(matrix_range_.h),
min_value(min_value_), altitude(altitude_) {}
CE explicit DiamondSquareAverageCornerIsland(CS dtl::base::MatrixRange & matrix_range_, CS MI & min_value_, CS MI & altitude_, CS MI & add_altitude_) NE
:start_x(matrix_range_.x), start_y(matrix_range_.y),
width(matrix_range_.w), height(matrix_range_.h),
min_value(min_value_), altitude(altitude_), add_altitude(add_altitude_) {}
CE explicit DiamondSquareAverageCornerIsland(CS IS end_x_, CS IS end_y_, CS IS width_, CS IS height_) NE
:start_x(end_x_), start_y(end_y_),
width(width_), height(height_) {}
CE explicit DiamondSquareAverageCornerIsland(CS IS end_x_, CS IS end_y_, CS IS width_, CS IS height_, CS MI & min_value_) NE
:start_x(end_x_), start_y(end_y_),
width(width_), height(height_),
min_value(min_value_) {}
CE explicit DiamondSquareAverageCornerIsland(CS IS end_x_, CS IS end_y_, CS IS width_, CS IS height_, CS MI & min_value_, CS MI & altitude_) NE
:start_x(end_x_), start_y(end_y_),
width(width_), height(height_),
min_value(min_value_), altitude(altitude_) {}
CE explicit DiamondSquareAverageCornerIsland(CS IS end_x_, CS IS end_y_, CS IS width_, CS IS height_, CS MI & min_value_, CS MI & altitude_, CS MI & add_altitude_) NE
:start_x(end_x_), start_y(end_y_),
width(width_), height(height_),
min_value(min_value_), altitude(altitude_), add_altitude(add_altitude_) {}
};
}
}
#endif 
#ifndef IDTL_DTL_SHAPE_DIAMOND_SQARE_AVERAGE_ISLAND
#define IDTL_DTL_SHAPE_DIAMOND_SQARE_AVERAGE_ISLAND
NS dtl {
inline NS shape {
TP<TN MI>
class DiamondSquareAverageIsland {
private:
using IS = dtl::type::size;
IS start_x{};
IS start_y{};
IS width{};
IS height{};
MI min_value{};
MI altitude{};
MI add_altitude{};
DVCN
DVCC
dtl::type::size getMatrixSize(CS IS matrix_size) CS NE {
dtl::type::size map_size{ 2 };
while (true) {
if ((map_size + 1) > matrix_size) RT map_size >>= 1;
map_size <<= 1;
}
RT 0;
}
TP<TN Matrix_, TN Function_>
DVCC
inline void substitutionSTL(Matrix_ && matrix_, CS IS map_size_, Function_ && function_) CS NE {
matrix_[this->start_y][this->start_x] = matrix_[this->start_y + map_size_ / 2][this->start_x] = dtl::random::mt32bit.get<MI>(min_value, min_value + altitude / 2);
matrix_[this->start_y][this->start_x + map_size_] = matrix_[this->start_y][this->start_x + map_size_ / 2] = dtl::random::mt32bit.get<MI>(min_value, min_value + altitude / 2);
matrix_[this->start_y + map_size_][this->start_x] = matrix_[this->start_y + map_size_][this->start_x + map_size_ / 2] = dtl::random::mt32bit.get<MI>(min_value, min_value + altitude / 2);
matrix_[this->start_y + map_size_][this->start_x + map_size_] = matrix_[this->start_y + map_size_][this->start_x + map_size_ / 2] = dtl::random::mt32bit.get<MI>(min_value, min_value + altitude / 2);
matrix_[this->start_y + map_size_ / 2][this->start_x + map_size_ / 2] = this->min_value + this->altitude;
createDiamondSquareAverageSTL<MI, Matrix_>(matrix_, this->start_x, this->start_y, map_size_ / 4, map_size_ / 4, map_size_ / 4, matrix_[this->start_y][this->start_x], matrix_[this->start_y + map_size_ / 2][this->start_x], matrix_[this->start_y][this->start_x + map_size_ / 2], matrix_[this->start_y + map_size_ / 2][this->start_x + map_size_ / 2], this->min_value + this->altitude, this->add_altitude, function_);
createDiamondSquareAverageSTL<MI, Matrix_>(matrix_, this->start_x, this->start_y, map_size_ / 4, map_size_ * 3 / 4, map_size_ / 4, matrix_[this->start_y + map_size_ / 2][this->start_x], matrix_[this->start_y + map_size_][this->start_x], matrix_[this->start_y + map_size_ / 2][this->start_x + map_size_ / 2], matrix_[this->start_y + map_size_][this->start_x + map_size_ / 2], this->min_value + this->altitude, this->add_altitude, function_);
createDiamondSquareAverageSTL<MI, Matrix_>(matrix_, this->start_x, this->start_y, map_size_ * 3 / 4, map_size_ / 4, map_size_ / 4, matrix_[this->start_y][this->start_x + map_size_ / 2], matrix_[this->start_y + map_size_ / 2][this->start_x + map_size_ / 2], matrix_[this->start_y][this->start_x + map_size_], matrix_[this->start_y + map_size_ / 2][this->start_x + map_size_], this->min_value + this->altitude, this->add_altitude, function_);
createDiamondSquareAverageSTL<MI, Matrix_>(matrix_, this->start_x, this->start_y, map_size_ * 3 / 4, map_size_ * 3 / 4, map_size_ / 4, matrix_[this->start_y + map_size_ / 2][this->start_x + map_size_ / 2], matrix_[this->start_y + map_size_][this->start_x + map_size_ / 2], matrix_[this->start_y + map_size_ / 2][this->start_x + map_size_], matrix_[this->start_y + map_size_][this->start_x + map_size_], this->min_value + this->altitude, this->add_altitude, function_);
}
TP<TN Matrix_, TN Function_>
DVCC
inline void substitutionArray(Matrix_ && matrix_, CS IS map_size_, CS IS max_x_, Function_ && function_) CS NE {
matrix_[(this->start_y)* max_x_ + (this->start_x)] = matrix_[(this->start_y + map_size_ / 2) * max_x_ + (this->start_x)] = dtl::random::mt32bit.get<MI>(min_value, min_value + altitude / 2);
matrix_[(this->start_y)* max_x_ + (this->start_x + map_size_)] = matrix_[(this->start_y)* max_x_ + (this->start_x + map_size_ / 2)] = dtl::random::mt32bit.get<MI>(min_value, min_value + altitude / 2);
matrix_[(this->start_y + map_size_) * max_x_ + (this->start_x)] = matrix_[(this->start_y + map_size_) * max_x_ + (this->start_x + map_size_ / 2)] = dtl::random::mt32bit.get<MI>(min_value, min_value + altitude / 2);
matrix_[(this->start_y + map_size_) * max_x_ + (this->start_x + map_size_)] = matrix_[(this->start_y + map_size_) * max_x_ + (this->start_x + map_size_ / 2)] = dtl::random::mt32bit.get<MI>(min_value, min_value + altitude / 2);
matrix_[(this->start_y + map_size_ / 2) * max_x_ + (this->start_x + map_size_ / 2)] = this->min_value + this->altitude;
createDiamondSquareAverageArray<MI, Matrix_>(matrix_, max_x_, this->start_x, this->start_y, map_size_ / 4, map_size_ / 4, map_size_ / 4, matrix_[(this->start_y)* max_x_ + (this->start_x)], matrix_[(this->start_y + map_size_ / 2) * max_x_ + (this->start_x)], matrix_[(this->start_y)* max_x_ + (this->start_x + map_size_ / 2)], matrix_[(this->start_y + map_size_ / 2) * max_x_ + (this->start_x + map_size_ / 2)], this->min_value + this->altitude, this->add_altitude, function_);
createDiamondSquareAverageArray<MI, Matrix_>(matrix_, max_x_, this->start_x, this->start_y, map_size_ / 4, map_size_ * 3 / 4, map_size_ / 4, matrix_[(this->start_y + map_size_ / 2) * max_x_ + (this->start_x)], matrix_[(this->start_y + map_size_) * max_x_ + (this->start_x)], matrix_[(this->start_y + map_size_ / 2) * max_x_ + (this->start_x + map_size_ / 2)], matrix_[(this->start_y + map_size_) * max_x_ + (this->start_x + map_size_ / 2)], this->min_value + this->altitude, this->add_altitude, function_);
createDiamondSquareAverageArray<MI, Matrix_>(matrix_, max_x_, this->start_x, this->start_y, map_size_ * 3 / 4, map_size_ / 4, map_size_ / 4, matrix_[(this->start_y)* max_x_ + (this->start_x + map_size_ / 2)], matrix_[(this->start_y + map_size_ / 2) * max_x_ + (this->start_x + map_size_ / 2)], matrix_[(this->start_y)* max_x_ + (this->start_x + map_size_)], matrix_[(this->start_y + map_size_ / 2) * max_x_ + (this->start_x + map_size_)], this->min_value + this->altitude, this->add_altitude, function_);
createDiamondSquareAverageArray<MI, Matrix_>(matrix_, max_x_, this->start_x, this->start_y, map_size_ * 3 / 4, map_size_ * 3 / 4, map_size_ / 4, matrix_[(this->start_y + map_size_ / 2) * max_x_ + (this->start_x + map_size_ / 2)], matrix_[(this->start_y + map_size_) * max_x_ + (this->start_x + map_size_ / 2)], matrix_[(this->start_y + map_size_ / 2) * max_x_ + (this->start_x + map_size_)], matrix_[(this->start_y + map_size_) * max_x_ + (this->start_x + map_size_)], this->min_value + this->altitude, this->add_altitude, function_);
}
TP<TN Matrix_, TN Function_>
DVCC
inline void substitutionLayer(Matrix_ && matrix_, CS IS layer_, CS IS map_size_, Function_ && function_) CS NE {
matrix_[this->start_y][this->start_x][layer_] = matrix_[this->start_y + map_size_ / 2][this->start_x][layer_] = dtl::random::mt32bit.get<MI>(min_value, min_value + altitude / 2);
matrix_[this->start_y][this->start_x + map_size_][layer_] = matrix_[this->start_y][this->start_x + map_size_ / 2][layer_] = dtl::random::mt32bit.get<MI>(min_value, min_value + altitude / 2);
matrix_[this->start_y + map_size_][this->start_x][layer_] = matrix_[this->start_y + map_size_][this->start_x + map_size_ / 2][layer_] = dtl::random::mt32bit.get<MI>(min_value, min_value + altitude / 2);
matrix_[this->start_y + map_size_][this->start_x + map_size_][layer_] = matrix_[this->start_y + map_size_][this->start_x + map_size_ / 2][layer_] = dtl::random::mt32bit.get<MI>(min_value, min_value + altitude / 2);
matrix_[this->start_y + map_size_ / 2][this->start_x + map_size_ / 2][layer_] = this->min_value + this->altitude;
createDiamondSquareAverageLayer<MI, Matrix_>(matrix_, layer_, this->start_x, this->start_y, map_size_ / 4, map_size_ / 4, map_size_ / 4, matrix_[this->start_y][this->start_x][layer_], matrix_[this->start_y + map_size_ / 2][this->start_x][layer_], matrix_[this->start_y][this->start_x + map_size_ / 2][layer_], matrix_[this->start_y + map_size_ / 2][this->start_x + map_size_ / 2][layer_], this->min_value + this->altitude, this->add_altitude, function_);
createDiamondSquareAverageLayer<MI, Matrix_>(matrix_, layer_, this->start_x, this->start_y, map_size_ / 4, map_size_ * 3 / 4, map_size_ / 4, matrix_[this->start_y + map_size_ / 2][this->start_x][layer_], matrix_[this->start_y + map_size_][this->start_x][layer_], matrix_[this->start_y + map_size_ / 2][this->start_x + map_size_ / 2][layer_], matrix_[this->start_y + map_size_][this->start_x + map_size_ / 2][layer_], this->min_value + this->altitude, this->add_altitude, function_);
createDiamondSquareAverageLayer<MI, Matrix_>(matrix_, layer_, this->start_x, this->start_y, map_size_ * 3 / 4, map_size_ / 4, map_size_ / 4, matrix_[this->start_y][this->start_x + map_size_ / 2][layer_], matrix_[this->start_y + map_size_ / 2][this->start_x + map_size_ / 2][layer_], matrix_[this->start_y][this->start_x + map_size_][layer_], matrix_[this->start_y + map_size_ / 2][this->start_x + map_size_][layer_], this->min_value + this->altitude, this->add_altitude, function_);
createDiamondSquareAverageLayer<MI, Matrix_>(matrix_, layer_, this->start_x, this->start_y, map_size_ * 3 / 4, map_size_ * 3 / 4, map_size_ / 4, matrix_[this->start_y + map_size_ / 2][this->start_x + map_size_ / 2][layer_], matrix_[this->start_y + map_size_][this->start_x + map_size_ / 2][layer_], matrix_[this->start_y + map_size_ / 2][this->start_x + map_size_][layer_], matrix_[this->start_y + map_size_][this->start_x + map_size_][layer_], this->min_value + this->altitude, this->add_altitude, function_);
}
TP<TN Matrix_>
DVCC
inline void substitutionSTL(Matrix_ && matrix_, CS IS map_size_) CS NE {
this->substitutionSTL(DTL_TYPE_FORWARD<Matrix_>(matrix_), map_size_, [](CS MI & value_) {RT value_ / 2; });
}
TP<TN Matrix_>
DVCC
inline void substitutionArray(Matrix_ && matrix_, CS IS map_size_, CS IS max_x_) CS NE {
this->substitutionArray(DTL_TYPE_FORWARD<Matrix_>(matrix_), max_x_, map_size_, [](CS MI & value_) {RT value_ / 2; });
}
TP<TN Matrix_>
DVCC
inline void substitutionLayer(Matrix_ && matrix_, CS IS layer_, CS IS map_size_) CS NE {
this->substitutionLayer(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, map_size_, [](CS MI & value_) {RT value_ / 2; });
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawSTL(Matrix_ && matrix_, CS IS end_y_, Args_ && ... args_) CS NE {
if (this->altitude < 2) RT false;
this->substitutionSTL(DTL_TYPE_FORWARD<Matrix_>(matrix_), getMatrixSize((end_y_ > matrix_[0].size()) ? matrix_[0].size() : end_y_), DTL_TYPE_FORWARD<Args_>(args_)...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawWidthSTL(Matrix_ && matrix_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
if (this->altitude < 2) RT false;
this->substitutionSTL(DTL_TYPE_FORWARD<Matrix_>(matrix_), getMatrixSize((end_y_ > DTL_TYPE_MIN(matrix_[0].size(), end_x_)) ? DTL_TYPE_MIN(matrix_[0].size(), end_x_) : end_y_), DTL_TYPE_FORWARD<Args_>(args_)...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawLayerSTL(Matrix_ && matrix_, CS IS layer_, CS IS end_y_, Args_ && ... args_) CS NE {
if (this->altitude < 2) RT false;
this->substitutionLayer(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, getMatrixSize((end_y_ > matrix_[0].size()) ? matrix_[0].size() : end_y_), DTL_TYPE_FORWARD<Args_>(args_)...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawLayerWidthSTL(Matrix_ && matrix_, CS IS layer_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
if (this->altitude < 2) RT false;
this->substitutionLayer(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, getMatrixSize((end_y_ > DTL_TYPE_MIN(matrix_[0].size(), end_x_)) ? DTL_TYPE_MIN(matrix_[0].size(), end_x_) : end_y_), DTL_TYPE_FORWARD<Args_>(args_)...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawNormal(Matrix_ && matrix_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
if (this->altitude < 2) RT false;
this->substitutionSTL(DTL_TYPE_FORWARD<Matrix_>(matrix_), getMatrixSize((end_y_ > end_x_) ? end_x_ : end_y_), DTL_TYPE_FORWARD<Args_>(args_)...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawLayerNormal(Matrix_ && matrix_, CS IS layer_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
if (this->altitude < 2) RT false;
this->substitutionLayer(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, getMatrixSize((end_y_ > end_x_) ? end_x_ : end_y_), DTL_TYPE_FORWARD<Args_>(args_)...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawArray(Matrix_ && matrix_, CS IS end_x_, CS IS end_y_, CS IS max_x_, Args_ && ... args_) CS NE {
if (this->altitude < 2) RT false;
this->substitutionArray(DTL_TYPE_FORWARD<Matrix_>(matrix_), getMatrixSize((end_y_ > end_x_) ? end_x_ : end_y_), max_x_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT true;
}
public:
DVCN
CE IS getPointX() CS NE {
RT this->start_x;
}
DVCN
CE IS getPointY() CS NE {
RT this->start_y;
}
DVCN
CE IS getWidth() CS NE {
RT this->width;
}
DVCN
CE IS getHeight() CS NE {
RT this->height;
}
DVCN
CE MI getMinValue() CS NE {
RT this->min_value;
}
DVCN
CE MI getAltitude() CS NE {
RT this->altitude;
}
DVCN
CE MI getAddAltitude() CS NE {
RT this->add_altitude;
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_) CS NE {
RT (this->width == 0) ? this->drawSTL(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height) : this->drawWidthSTL(matrix_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, Function_ && function_) CS NE {
RT (this->width == 0) ? this->drawSTL(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_) : this->drawWidthSTL(matrix_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_, CS IS layer_) CS NE {
RT (this->width == 0) ? this->drawLayerSTL(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height) : this->drawLayerWidthSTL(matrix_, layer_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, CS IS layer_, Function_ && function_) CS NE {
RT (this->width == 0) ? this->drawLayerSTL(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_) : this->drawLayerWidthSTL(matrix_, layer_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_) CS NE {
RT this->drawNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_, Function_ && function_) CS NE {
RT this->drawNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_, CS IS layer_, CS IS max_x_, CS IS max_y_) CS NE {
RT this->drawLayerNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, CS IS layer_, CS IS max_x_, CS IS max_y_, Function_ && function_) CS NE {
RT this->drawLayerNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL drawArray(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_) CS NE {
RT this->drawArray(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, max_x_);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperatorArray(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_, Function_ && function_) CS NE {
RT this->drawArray(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, max_x_, function_);
}
TP<TN Matrix_, TN ...Args_>
CE BL operator()(Matrix_&& matrix_, Args_&& ... args_) CS NE {
RT this->draw(DTL_TYPE_FORWARD<Matrix_>(matrix_), DTL_TYPE_FORWARD<Args_>(args_)...);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& create(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->draw(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createArray(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->drawArray(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createOperator(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->drawOperator(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createOperatorArray(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->drawOperatorArray(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
CE DiamondSquareAverageIsland() NE = default;
CE explicit DiamondSquareAverageIsland(CS MI & min_value_) NE
:min_value(min_value_) {}
CE explicit DiamondSquareAverageIsland(CS MI & min_value_, CS MI & altitude_) NE
:min_value(min_value_), altitude(altitude_) {}
CE explicit DiamondSquareAverageIsland(CS MI & min_value_, CS MI & altitude_, CS MI & add_altitude_) NE
:min_value(min_value_), altitude(altitude_), add_altitude(add_altitude_) {}
CE explicit DiamondSquareAverageIsland(CS dtl::base::MatrixRange & matrix_range_) NE
:start_x(matrix_range_.x), start_y(matrix_range_.y),
width(matrix_range_.w), height(matrix_range_.h) {}
CE explicit DiamondSquareAverageIsland(CS dtl::base::MatrixRange & matrix_range_, CS MI & min_value_) NE
:start_x(matrix_range_.x), start_y(matrix_range_.y),
width(matrix_range_.w), height(matrix_range_.h),
min_value(min_value_) {}
CE explicit DiamondSquareAverageIsland(CS dtl::base::MatrixRange & matrix_range_, CS MI & min_value_, CS MI & altitude_) NE
:start_x(matrix_range_.x), start_y(matrix_range_.y),
width(matrix_range_.w), height(matrix_range_.h),
min_value(min_value_), altitude(altitude_) {}
CE explicit DiamondSquareAverageIsland(CS dtl::base::MatrixRange & matrix_range_, CS MI & min_value_, CS MI & altitude_, CS MI & add_altitude_) NE
:start_x(matrix_range_.x), start_y(matrix_range_.y),
width(matrix_range_.w), height(matrix_range_.h),
min_value(min_value_), altitude(altitude_), add_altitude(add_altitude_) {}
CE explicit DiamondSquareAverageIsland(CS IS end_x_, CS IS end_y_, CS IS width_, CS IS height_) NE
:start_x(end_x_), start_y(end_y_),
width(width_), height(height_) {}
CE explicit DiamondSquareAverageIsland(CS IS end_x_, CS IS end_y_, CS IS width_, CS IS height_, CS MI & min_value_) NE
:start_x(end_x_), start_y(end_y_),
width(width_), height(height_),
min_value(min_value_) {}
CE explicit DiamondSquareAverageIsland(CS IS end_x_, CS IS end_y_, CS IS width_, CS IS height_, CS MI & min_value_, CS MI & altitude_) NE
:start_x(end_x_), start_y(end_y_),
width(width_), height(height_),
min_value(min_value_), altitude(altitude_) {}
CE explicit DiamondSquareAverageIsland(CS IS end_x_, CS IS end_y_, CS IS width_, CS IS height_, CS MI & min_value_, CS MI & altitude_, CS MI & add_altitude_) NE
:start_x(end_x_), start_y(end_y_),
width(width_), height(height_),
min_value(min_value_), altitude(altitude_), add_altitude(add_altitude_) {}
};
}
}
#endif 
#ifndef IDTL_DTL_SHAPE_FRACTAL_ISLAND
#define IDTL_DTL_SHAPE_FRACTAL_ISLAND
#include <array>
#ifndef IDTL_DTL_TYPE_NEW
#define IDTL_DTL_TYPE_NEW
#ifndef DTL_TYPE_NEW
#include <new>
#define DTL_TYPE_NEW new(std::nothrow)
#endif
#endif 
#ifndef IDTL_DTL_TYPE_S_SIZE_T
#define IDTL_DTL_TYPE_S_SIZE_T
#if defined(UE_BUILD_FINAL_RELEASE) 
NS dtl { NS type { using ssize = ::SSIZE_T; } }
#else
#include <cstddef>
NS dtl { NS type { using ssize = std::ptrdiff_t; } }
#endif
#endif 
#ifndef IDTL_DTL_TYPE_UNIQUE_PTR
#define IDTL_DTL_TYPE_UNIQUE_PTR
#ifndef DTL_TYPE_UNIQUE_PTR
#if defined(UE_BUILD_FINAL_RELEASE) 
#define DTL_TYPE_UNIQUE_PTR ::TUniquePtr
#else
#include <memory>
#define DTL_TYPE_UNIQUE_PTR std::unique_ptr
#endif
#endif
#endif 
NS dtl {
inline NS shape {
CE dtl::type::size fi_chunk_size{ 16 };
TP<TN MI, TN UniquePtr_ = DTL_TYPE_UNIQUE_PTR<dtl::type::ssize[]>>
class FractalIsland {
private:
using IS = dtl::type::size;
IS start_x{};
IS start_y{};
IS width{};
IS height{};
MI min_value{};
MI altitude{};
MI add_altitude{};
TP<TN Matrix2_, TN Function_>
DVCC
void createWorldMapSimple(Matrix2_&& matrix_, Function_&& function_) CS NE {
createDiamondSquareAverageSTL<MI, Matrix2_>(matrix_, 0, 0, dtl::shape::fi_chunk_size / 2, dtl::shape::fi_chunk_size / 2, dtl::shape::fi_chunk_size / 2, matrix_[0][0], matrix_[dtl::shape::fi_chunk_size][0], matrix_[0][dtl::shape::fi_chunk_size], matrix_[dtl::shape::fi_chunk_size][dtl::shape::fi_chunk_size], this->min_value + this->altitude, this->add_altitude, function_);
}
TP<TN Matrix2_>
DVCC
void createWorldMapSimple(Matrix2_&& matrix_) CS NE {
createWorldMapSimple(matrix_, [](CS MI & value_) {RT value_ / 2; });
}
TP<TN Matrix2_, TN Function_>
DVCC
void createWorldMapSimpleLayer(Matrix2_&& matrix_, CS IS layer_, Function_&& function_) CS NE {
createDiamondSquareAverageLayer<MI, Matrix2_>(matrix_, layer_, 0, 0, dtl::shape::fi_chunk_size / 2, dtl::shape::fi_chunk_size / 2, dtl::shape::fi_chunk_size / 2, matrix_[0][0][layer_], matrix_[dtl::shape::fi_chunk_size][0][layer_], matrix_[0][dtl::shape::fi_chunk_size][layer_], matrix_[dtl::shape::fi_chunk_size][dtl::shape::fi_chunk_size][layer_], this->min_value + this->altitude, this->add_altitude, function_);
}
TP<TN Matrix2_>
DVCC
void createWorldMapSimpleLayer(Matrix2_&& matrix_, CS IS layer_) CS NE {
createWorldMapSimpleLayer(matrix_, layer_, [](CS MI & value_) {RT value_ / 2; });
}
TP<TN Matrix2_, TN Function_>
DVCC
void createWorldMapSimpleArray(Matrix2_&& matrix_, CS IS max_x_, Function_&& function_) CS NE {
createDiamondSquareAverageArray<MI, Matrix2_>(matrix_, max_x_, 0, 0, dtl::shape::fi_chunk_size / 2, dtl::shape::fi_chunk_size / 2, dtl::shape::fi_chunk_size / 2, matrix_[0], matrix_[dtl::shape::fi_chunk_size * max_x_], matrix_[dtl::shape::fi_chunk_size], matrix_[dtl::shape::fi_chunk_size * max_x_ + dtl::shape::fi_chunk_size], this->min_value + this->altitude, this->add_altitude, function_);
}
TP<TN Matrix2_>
DVCC
void createWorldMapSimpleArray(Matrix2_ && matrix_, CS IS max_x_) CS NE {
createWorldMapSimpleArray(matrix_, max_x_, [](CS MI & value_) {RT value_ / 2; });
}
TP<TN Matrix_, TN ...Args_>
BL drawNormal(Matrix_ && matrix_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
if (this->altitude < 2) RT false;
std::array<std::array<MI, dtl::shape::fi_chunk_size + 1>, dtl::shape::fi_chunk_size + 1> chunk_matrix{ {} };
CS dtl::type::size chunk_x{ ((end_x_ - this->start_x) / dtl::shape::fi_chunk_size) };
CS dtl::type::size chunk_y{ ((end_y_ - this->start_y) / dtl::shape::fi_chunk_size) };
UniquePtr_ rand_up{ DTL_TYPE_NEW dtl::type::ssize[chunk_x + 1] };
if (!rand_up) RT false;
UniquePtr_ rand_down{ DTL_TYPE_NEW dtl::type::ssize[chunk_x + 1] };
if (!rand_down) RT false;
for (dtl::type::size j{}; j <= chunk_x; ++j)
rand_up[j] = 0;
for (dtl::type::size i{}; i < chunk_y; ++i) {
if ((i + 1) == chunk_y)
for (dtl::type::size j{}; j <= chunk_x; ++j)
rand_down[j] = 0;
else {
for (dtl::type::size j{ 1 }; j < chunk_x; ++j)
rand_down[j] = dtl::random::mt32bit.get<dtl::type::ssize>(this->altitude);
rand_down[0] = 0;
rand_down[chunk_x] = rand_down[0];
}
for (dtl::type::size j{}; j < chunk_x; ++j) {
chunk_matrix[0][0] = static_cast<MI>(rand_up[j]);
chunk_matrix[dtl::shape::fi_chunk_size][0] = static_cast<MI>(rand_down[j]);
chunk_matrix[0][dtl::shape::fi_chunk_size] = static_cast<MI>(rand_up[j + 1]);
chunk_matrix[dtl::shape::fi_chunk_size][dtl::shape::fi_chunk_size] = static_cast<MI>(rand_down[j + 1]);
createWorldMapSimple(chunk_matrix, args_...);
for (dtl::type::size row2{}; row2 < dtl::shape::fi_chunk_size; ++row2)
for (dtl::type::size col2{}; col2 < dtl::shape::fi_chunk_size; ++col2)
matrix_[this->start_y + i * dtl::shape::fi_chunk_size + row2][this->start_x + j * dtl::shape::fi_chunk_size + col2] = chunk_matrix[row2][col2];
}
for (dtl::type::size j{}; j <= chunk_x; ++j)
rand_up[j] = rand_down[j];
}
RT true;
}
TP<TN Matrix_, TN ...Args_>
BL drawLayerNormal(Matrix_ && matrix_, CS IS layer_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
if (this->altitude < 2) RT false;
std::array<std::array<MI, dtl::shape::fi_chunk_size + 1>, dtl::shape::fi_chunk_size + 1> chunk_matrix{ {} };
CS dtl::type::size chunk_x{ ((end_x_ - this->start_x) / dtl::shape::fi_chunk_size) };
CS dtl::type::size chunk_y{ ((end_y_ - this->start_y) / dtl::shape::fi_chunk_size) };
UniquePtr_ rand_up{ DTL_TYPE_NEW dtl::type::ssize[chunk_x + 1] };
if (!rand_up) RT false;
UniquePtr_ rand_down{ DTL_TYPE_NEW dtl::type::ssize[chunk_x + 1] };
if (!rand_down) RT false;
for (dtl::type::size j{}; j <= chunk_x; ++j)
rand_up[j] = 0;
for (dtl::type::size i{}; i < chunk_y; ++i) {
if ((i + 1) == chunk_y)
for (dtl::type::size j{}; j <= chunk_x; ++j)
rand_down[j] = 0;
else {
for (dtl::type::size j{ 1 }; j < chunk_x; ++j)
rand_down[j] = dtl::random::mt32bit.get<dtl::type::ssize>(this->altitude);
rand_down[0] = 0;
rand_down[chunk_x] = rand_down[0];
}
for (dtl::type::size j{}; j < chunk_x; ++j) {
chunk_matrix[0][0] = static_cast<MI>(rand_up[j]);
chunk_matrix[dtl::shape::fi_chunk_size][0] = static_cast<MI>(rand_down[j]);
chunk_matrix[0][dtl::shape::fi_chunk_size] = static_cast<MI>(rand_up[j + 1]);
chunk_matrix[dtl::shape::fi_chunk_size][dtl::shape::fi_chunk_size] = static_cast<MI>(rand_down[j + 1]);
createWorldMapSimple(chunk_matrix, args_...);
for (dtl::type::size row2{}; row2 < dtl::shape::fi_chunk_size; ++row2)
for (dtl::type::size col2{}; col2 < dtl::shape::fi_chunk_size; ++col2)
matrix_[this->start_y + i * dtl::shape::fi_chunk_size + row2][this->start_x + j * dtl::shape::fi_chunk_size + col2][layer_] = chunk_matrix[row2][col2];
}
for (dtl::type::size j{}; j <= chunk_x; ++j)
rand_up[j] = rand_down[j];
}
RT true;
}
TP<TN Matrix_, TN ...Args_>
BL drawArray(Matrix_ && matrix_, CS IS end_x_, CS IS end_y_, CS IS max_x_, Args_ && ... args_) CS NE {
if (this->altitude < 2) RT false;
std::array<std::array<MI, dtl::shape::fi_chunk_size + 1>, dtl::shape::fi_chunk_size + 1> chunk_matrix{ {} };
CS dtl::type::size chunk_x{ ((end_x_ - this->start_x) / dtl::shape::fi_chunk_size) };
CS dtl::type::size chunk_y{ ((end_y_ - this->start_y) / dtl::shape::fi_chunk_size) };
UniquePtr_ rand_up{ DTL_TYPE_NEW dtl::type::ssize[chunk_x + 1] };
if (!rand_up) RT false;
UniquePtr_ rand_down{ DTL_TYPE_NEW dtl::type::ssize[chunk_x + 1] };
if (!rand_down) RT false;
for (dtl::type::size j{}; j <= chunk_x; ++j)
rand_up[j] = 0;
for (dtl::type::size i{}; i < chunk_y; ++i) {
if ((i + 1) == chunk_y)
for (dtl::type::size j{}; j <= chunk_x; ++j)
rand_down[j] = 0;
else {
for (dtl::type::size j{ 1 }; j < chunk_x; ++j)
rand_down[j] = dtl::random::mt32bit.get<dtl::type::ssize>(this->altitude);
rand_down[0] = 0;
rand_down[chunk_x] = rand_down[0];
}
for (dtl::type::size j{}; j < chunk_x; ++j) {
chunk_matrix[0][0] = static_cast<MI>(rand_up[j]);
chunk_matrix[dtl::shape::fi_chunk_size][0] = static_cast<MI>(rand_down[j]);
chunk_matrix[0][dtl::shape::fi_chunk_size] = static_cast<MI>(rand_up[j + 1]);
chunk_matrix[dtl::shape::fi_chunk_size][dtl::shape::fi_chunk_size] = static_cast<MI>(rand_down[j + 1]);
createWorldMapSimple(chunk_matrix, args_...);
for (dtl::type::size row2{}; row2 < dtl::shape::fi_chunk_size; ++row2)
for (dtl::type::size col2{}; col2 < dtl::shape::fi_chunk_size; ++col2)
matrix_[(this->start_y + i * dtl::shape::fi_chunk_size + row2) * max_x_ + start_x + j * dtl::shape::fi_chunk_size + col2] = chunk_matrix[row2][col2];
}
for (dtl::type::size j{}; j <= chunk_x; ++j)
rand_up[j] = rand_down[j];
}
RT true;
}
public:
DVCN
CE IS getPointX() CS NE {
RT this->start_x;
}
DVCN
CE IS getPointY() CS NE {
RT this->start_y;
}
DVCN
CE IS getWidth() CS NE {
RT this->width;
}
DVCN
CE IS getHeight() CS NE {
RT this->height;
}
DVCN
CE MI getMinValue() CS NE {
RT this->min_value;
}
DVCN
CE MI getAltitude() CS NE {
RT this->altitude;
}
DVCN
CE MI getAddAltitude() CS NE {
RT this->add_altitude;
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_) CS NE {
RT this->drawNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= ((matrix_.size() == 0) ? 0 : matrix_[0].size())) ? ((matrix_.size() == 0) ? 0 : matrix_[0].size()) : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, Function_ && function_) CS NE {
RT this->drawNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= ((matrix_.size() == 0) ? 0 : matrix_[0].size())) ? ((matrix_.size() == 0) ? 0 : matrix_[0].size()) : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_, CS IS layer_) CS NE {
RT this->drawLayerNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->width == 0 || this->start_x + this->width >= ((matrix_.size() == 0) ? 0 : matrix_[0].size())) ? ((matrix_.size() == 0) ? 0 : matrix_[0].size()) : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, CS IS layer_, Function_ && function_) CS NE {
RT this->drawLayerNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->width == 0 || this->start_x + this->width >= ((matrix_.size() == 0) ? 0 : matrix_[0].size())) ? ((matrix_.size() == 0) ? 0 : matrix_[0].size()) : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_) CS NE {
RT this->drawNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_, Function_ && function_) CS NE {
RT this->drawNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_, CS IS layer_, CS IS max_x_, CS IS max_y_) CS NE {
RT this->drawLayerNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, CS IS layer_, CS IS max_x_, CS IS max_y_, Function_ && function_) CS NE {
RT this->drawLayerNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL drawArray(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_) CS NE {
RT this->drawArray(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, max_x_);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperatorArray(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_, Function_ && function_) CS NE {
RT this->drawArray(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, max_x_, function_);
}
TP<TN Matrix_, TN ...Args_>
CE BL operator()(Matrix_ && matrix_, Args_ && ... args_) CS NE {
RT this->draw(DTL_TYPE_FORWARD<Matrix_>(matrix_), DTL_TYPE_FORWARD<Args_>(args_)...);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& create(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->draw(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createArray(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->drawArray(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createOperator(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->drawOperator(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createOperatorArray(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->drawOperatorArray(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
CE FractalIsland() NE = default;
CE explicit FractalIsland(CS MI & min_value_) NE
:min_value(min_value_) {}
CE explicit FractalIsland(CS MI & min_value_, CS MI & altitude_) NE
:min_value(min_value_), altitude(altitude_) {}
CE explicit FractalIsland(CS MI & min_value_, CS MI & altitude_, CS MI & add_altitude_) NE
:min_value(min_value_), altitude(altitude_), add_altitude(add_altitude_) {}
CE explicit FractalIsland(CS dtl::base::MatrixRange & matrix_range_) NE
:start_x(matrix_range_.x), start_y(matrix_range_.y),
width(matrix_range_.w), height(matrix_range_.h) {}
CE explicit FractalIsland(CS dtl::base::MatrixRange & matrix_range_, CS MI & min_value_) NE
:start_x(matrix_range_.x), start_y(matrix_range_.y),
width(matrix_range_.w), height(matrix_range_.h),
min_value(min_value_) {}
CE explicit FractalIsland(CS dtl::base::MatrixRange & matrix_range_, CS MI & min_value_, CS MI & altitude_) NE
:start_x(matrix_range_.x), start_y(matrix_range_.y),
width(matrix_range_.w), height(matrix_range_.h),
min_value(min_value_), altitude(altitude_) {}
CE explicit FractalIsland(CS dtl::base::MatrixRange & matrix_range_, CS MI & min_value_, CS MI & altitude_, CS MI & add_altitude_) NE
:start_x(matrix_range_.x), start_y(matrix_range_.y),
width(matrix_range_.w), height(matrix_range_.h),
min_value(min_value_), altitude(altitude_), add_altitude(add_altitude_) {}
CE explicit FractalIsland(CS IS end_x_, CS IS end_y_, CS IS width_, CS IS height_) NE
:start_x(end_x_), start_y(end_y_),
width(width_), height(height_) {}
CE explicit FractalIsland(CS IS end_x_, CS IS end_y_, CS IS width_, CS IS height_, CS MI & min_value_) NE
:start_x(end_x_), start_y(end_y_),
width(width_), height(height_),
min_value(min_value_) {}
CE explicit FractalIsland(CS IS end_x_, CS IS end_y_, CS IS width_, CS IS height_, CS MI & min_value_, CS MI & altitude_) NE
:start_x(end_x_), start_y(end_y_),
width(width_), height(height_),
min_value(min_value_), altitude(altitude_) {}
CE explicit FractalIsland(CS IS end_x_, CS IS end_y_, CS IS width_, CS IS height_, CS MI & min_value_, CS MI & altitude_, CS MI & add_altitude_) NE
:start_x(end_x_), start_y(end_y_),
width(width_), height(height_),
min_value(min_value_), altitude(altitude_), add_altitude(add_altitude_) {}
};
}
}
#endif 
#ifndef IDTL_DTL_SHAPE_FRACTAL_LOOP_ISLAND
#define IDTL_DTL_SHAPE_FRACTAL_LOOP_ISLAND
#include <array>
NS dtl {
inline NS shape {
CE dtl::type::size fli_chunk_size{ 16 };
TP<TN MI, TN UniquePtr_ = DTL_TYPE_UNIQUE_PTR<dtl::type::ssize[]>>
class FractalLoopIsland {
private:
using IS = dtl::type::size;
IS start_x{};
IS start_y{};
IS width{};
IS height{};
MI min_value{};
MI altitude{};
MI add_altitude{};
TP<TN Matrix2_, TN Function_>
DVCC
void createWorldMapSimple(Matrix2_&& matrix_, Function_&& function_) CS NE {
createDiamondSquareAverageSTL<MI, Matrix2_>(matrix_, 0, 0, dtl::shape::fli_chunk_size / 2, dtl::shape::fli_chunk_size / 2, dtl::shape::fli_chunk_size / 2, matrix_[0][0], matrix_[dtl::shape::fli_chunk_size][0], matrix_[0][dtl::shape::fli_chunk_size], matrix_[dtl::shape::fli_chunk_size][dtl::shape::fli_chunk_size], this->min_value + this->altitude, this->add_altitude, function_);
}
TP<TN Matrix2_>
DVCC
void createWorldMapSimple(Matrix2_&& matrix_) CS NE {
createWorldMapSimple(matrix_, [](CS MI & value_) {RT value_ / 2; });
}
TP<TN Matrix2_, TN Function_>
DVCC
void createWorldMapSimpleLayer(Matrix2_&& matrix_, CS IS layer_, Function_&& function_) CS NE {
createDiamondSquareAverageLayer<MI, Matrix2_>(matrix_, layer_, 0, 0, dtl::shape::fli_chunk_size / 2, dtl::shape::fli_chunk_size / 2, dtl::shape::fli_chunk_size / 2, matrix_[0][0][layer_], matrix_[dtl::shape::fli_chunk_size][0][layer_], matrix_[0][dtl::shape::fli_chunk_size][layer_], matrix_[dtl::shape::fli_chunk_size][dtl::shape::fli_chunk_size][layer_], this->min_value + this->altitude, this->add_altitude, function_);
}
TP<TN Matrix2_>
DVCC
void createWorldMapSimpleLayer(Matrix2_&& matrix_, CS IS layer_) CS NE {
createWorldMapSimpleLayer(matrix_, layer_, [](CS MI & value_) {RT value_ / 2; });
}
TP<TN Matrix2_, TN Function_>
DVCC
void createWorldMapSimpleArray(Matrix2_&& matrix_, CS IS max_x_, Function_&& function_) CS NE {
createDiamondSquareAverageArray<MI, Matrix2_>(matrix_, max_x_, 0, 0, dtl::shape::fli_chunk_size / 2, dtl::shape::fli_chunk_size / 2, dtl::shape::fli_chunk_size / 2, matrix_[0], matrix_[dtl::shape::fli_chunk_size * max_x_], matrix_[dtl::shape::fli_chunk_size], matrix_[dtl::shape::fli_chunk_size * max_x_ + dtl::shape::fli_chunk_size], this->min_value + this->altitude, this->add_altitude, function_);
}
TP<TN Matrix2_>
DVCC
void createWorldMapSimpleArray(Matrix2_ && matrix_, CS IS max_x_) CS NE {
createWorldMapSimpleArray(matrix_, max_x_, [](CS MI & value_) {RT value_ / 2; });
}
TP<TN Matrix_, TN ...Args_>
BL drawNormal(Matrix_ && matrix_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
if (this->altitude < 2) RT false;
std::array<std::array<MI, dtl::shape::fli_chunk_size + 1>, dtl::shape::fli_chunk_size + 1> chunk_matrix{ {} };
CS dtl::type::size chunk_x{ ((end_x_ - this->start_x) / dtl::shape::fli_chunk_size) };
CS dtl::type::size chunk_y{ ((end_y_ - this->start_y) / dtl::shape::fli_chunk_size) };
UniquePtr_ rand_up{ DTL_TYPE_NEW dtl::type::ssize[chunk_x + 1] };
if (!rand_up) RT false;
UniquePtr_ rand_down{ DTL_TYPE_NEW dtl::type::ssize[chunk_x + 1] };
if (!rand_down) RT false;
UniquePtr_ rand_first_row{ DTL_TYPE_NEW dtl::type::ssize[chunk_x + 1] };
if (!rand_first_row) RT false;
for (dtl::type::size j{}; j < chunk_x; ++j) {
rand_up[j] = dtl::random::mt32bit.get<dtl::type::ssize>(this->altitude);
rand_first_row[j] = rand_up[j];
}
rand_first_row[chunk_x] = rand_up[chunk_x] = rand_up[0];
for (dtl::type::size i{}; i < chunk_y; ++i) {
if ((i + 1) == chunk_y) rand_down = std::move(rand_first_row);
else {
for (dtl::type::size j{}; j < chunk_x; ++j)
rand_down[j] = dtl::random::mt32bit.get<dtl::type::ssize>(this->altitude);
rand_down[chunk_x] = rand_down[0];
}
for (dtl::type::size j{}; j < chunk_x; ++j) {
chunk_matrix[0][0] = static_cast<MI>(rand_up[j]);
chunk_matrix[dtl::shape::fli_chunk_size][0] = static_cast<MI>(rand_down[j]);
chunk_matrix[0][dtl::shape::fli_chunk_size] = static_cast<MI>(rand_up[j + 1]);
chunk_matrix[dtl::shape::fli_chunk_size][dtl::shape::fli_chunk_size] = static_cast<MI>(rand_down[j + 1]);
createWorldMapSimple(chunk_matrix, args_...);
for (dtl::type::size row2{}; row2 < dtl::shape::fli_chunk_size; ++row2)
for (dtl::type::size col2{}; col2 < dtl::shape::fli_chunk_size; ++col2)
matrix_[this->start_y + i * dtl::shape::fli_chunk_size + row2][this->start_x + j * dtl::shape::fli_chunk_size + col2] = chunk_matrix[row2][col2];
}
for (dtl::type::size j{}; j <= chunk_x; ++j)
rand_up[j] = rand_down[j];
}
RT true;
}
TP<TN Matrix_, TN ...Args_>
BL drawLayerNormal(Matrix_ && matrix_, CS IS layer_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
if (this->altitude < 2) RT false;
std::array<std::array<MI, dtl::shape::fli_chunk_size + 1>, dtl::shape::fli_chunk_size + 1> chunk_matrix{ {} };
CS dtl::type::size chunk_x{ ((end_x_ - this->start_x) / dtl::shape::fli_chunk_size) };
CS dtl::type::size chunk_y{ ((end_y_ - this->start_y) / dtl::shape::fli_chunk_size) };
UniquePtr_ rand_up{ DTL_TYPE_NEW dtl::type::ssize[chunk_x + 1] };
if (!rand_up) RT false;
UniquePtr_ rand_down{ DTL_TYPE_NEW dtl::type::ssize[chunk_x + 1] };
if (!rand_down) RT false;
UniquePtr_ rand_first_row{ DTL_TYPE_NEW dtl::type::ssize[chunk_x + 1] };
if (!rand_first_row) RT false;
for (dtl::type::size j{}; j < chunk_x; ++j) {
rand_up[j] = dtl::random::mt32bit.get<dtl::type::ssize>(this->altitude);
rand_first_row[j] = rand_up[j];
}
rand_first_row[chunk_x] = rand_up[chunk_x] = rand_up[0];
for (dtl::type::size i{}; i < chunk_y; ++i) {
if ((i + 1) == chunk_y) rand_down = std::move(rand_first_row);
else {
for (dtl::type::size j{}; j < chunk_x; ++j)
rand_down[j] = dtl::random::mt32bit.get<dtl::type::ssize>(this->altitude);
rand_down[chunk_x] = rand_down[0];
}
for (dtl::type::size j{}; j < chunk_x; ++j) {
chunk_matrix[0][0] = static_cast<MI>(rand_up[j]);
chunk_matrix[dtl::shape::fli_chunk_size][0] = static_cast<MI>(rand_down[j]);
chunk_matrix[0][dtl::shape::fli_chunk_size] = static_cast<MI>(rand_up[j + 1]);
chunk_matrix[dtl::shape::fli_chunk_size][dtl::shape::fli_chunk_size] = static_cast<MI>(rand_down[j + 1]);
createWorldMapSimple(chunk_matrix, args_...);
for (dtl::type::size row2{}; row2 < dtl::shape::fli_chunk_size; ++row2)
for (dtl::type::size col2{}; col2 < dtl::shape::fli_chunk_size; ++col2)
matrix_[this->start_y + i * dtl::shape::fli_chunk_size + row2][this->start_x + j * dtl::shape::fli_chunk_size + col2][layer_] = chunk_matrix[row2][col2];
}
for (dtl::type::size j{}; j <= chunk_x; ++j)
rand_up[j] = rand_down[j];
}
RT true;
}
TP<TN Matrix_, TN ...Args_>
BL drawArray(Matrix_ && matrix_, CS IS end_x_, CS IS end_y_, CS IS max_x_, Args_ && ... args_) CS NE {
if (this->altitude < 2) RT false;
std::array<std::array<MI, dtl::shape::fli_chunk_size + 1>, dtl::shape::fli_chunk_size + 1> chunk_matrix{ {} };
CS dtl::type::size chunk_x{ ((end_x_ - this->start_x) / dtl::shape::fli_chunk_size) };
CS dtl::type::size chunk_y{ ((end_y_ - this->start_y) / dtl::shape::fli_chunk_size) };
UniquePtr_ rand_up{ DTL_TYPE_NEW dtl::type::ssize[chunk_x + 1] };
if (!rand_up) RT false;
UniquePtr_ rand_down{ DTL_TYPE_NEW dtl::type::ssize[chunk_x + 1] };
if (!rand_down) RT false;
UniquePtr_ rand_first_row{ DTL_TYPE_NEW dtl::type::ssize[chunk_x + 1] };
if (!rand_first_row) RT false;
for (dtl::type::size j{}; j < chunk_x; ++j) {
rand_up[j] = dtl::random::mt32bit.get<dtl::type::ssize>(this->altitude);
rand_first_row[j] = rand_up[j];
}
rand_first_row[chunk_x] = rand_up[chunk_x] = rand_up[0];
for (dtl::type::size i{}; i < chunk_y; ++i) {
if ((i + 1) == chunk_y) rand_down = std::move(rand_first_row);
else {
for (dtl::type::size j{}; j < chunk_x; ++j)
rand_down[j] = dtl::random::mt32bit.get<dtl::type::ssize>(this->altitude);
rand_down[chunk_x] = rand_down[0];
}
for (dtl::type::size j{}; j < chunk_x; ++j) {
chunk_matrix[0][0] = static_cast<MI>(rand_up[j]);
chunk_matrix[dtl::shape::fli_chunk_size][0] = static_cast<MI>(rand_down[j]);
chunk_matrix[0][dtl::shape::fli_chunk_size] = static_cast<MI>(rand_up[j + 1]);
chunk_matrix[dtl::shape::fli_chunk_size][dtl::shape::fli_chunk_size] = static_cast<MI>(rand_down[j + 1]);
createWorldMapSimple(chunk_matrix, args_...);
for (dtl::type::size row2{}; row2 < dtl::shape::fli_chunk_size; ++row2)
for (dtl::type::size col2{}; col2 < dtl::shape::fli_chunk_size; ++col2)
matrix_[(this->start_y + i * dtl::shape::fli_chunk_size + row2) * max_x_ + start_x + j * dtl::shape::fli_chunk_size + col2] = chunk_matrix[row2][col2];
}
for (dtl::type::size j{}; j <= chunk_x; ++j)
rand_up[j] = rand_down[j];
}
RT true;
}
public:
DVCN
CE IS getPointX() CS NE {
RT this->start_x;
}
DVCN
CE IS getPointY() CS NE {
RT this->start_y;
}
DVCN
CE IS getWidth() CS NE {
RT this->width;
}
DVCN
CE IS getHeight() CS NE {
RT this->height;
}
DVCN
CE MI getMinValue() CS NE {
RT this->min_value;
}
DVCN
CE MI getAltitude() CS NE {
RT this->altitude;
}
DVCN
CE MI getAddAltitude() CS NE {
RT this->add_altitude;
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_) CS NE {
RT this->drawNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= ((matrix_.size() == 0) ? 0 : matrix_[0].size())) ? ((matrix_.size() == 0) ? 0 : matrix_[0].size()) : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, Function_ && function_) CS NE {
RT this->drawNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= ((matrix_.size() == 0) ? 0 : matrix_[0].size())) ? ((matrix_.size() == 0) ? 0 : matrix_[0].size()) : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_, CS IS layer_) CS NE {
RT this->drawLayerNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->width == 0 || this->start_x + this->width >= ((matrix_.size() == 0) ? 0 : matrix_[0].size())) ? ((matrix_.size() == 0) ? 0 : matrix_[0].size()) : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, CS IS layer_, Function_ && function_) CS NE {
RT this->drawLayerNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->width == 0 || this->start_x + this->width >= ((matrix_.size() == 0) ? 0 : matrix_[0].size())) ? ((matrix_.size() == 0) ? 0 : matrix_[0].size()) : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_) CS NE {
RT this->drawNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_, Function_ && function_) CS NE {
RT this->drawNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_, CS IS layer_, CS IS max_x_, CS IS max_y_) CS NE {
RT this->drawLayerNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, CS IS layer_, CS IS max_x_, CS IS max_y_, Function_ && function_) CS NE {
RT this->drawLayerNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL drawArray(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_) CS NE {
RT this->drawArray(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, max_x_);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperatorArray(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_, Function_ && function_) CS NE {
RT this->drawArray(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, max_x_, function_);
}
TP<TN Matrix_, TN ...Args_>
CE BL operator()(Matrix_ && matrix_, Args_ && ... args_) CS NE {
RT this->draw(DTL_TYPE_FORWARD<Matrix_>(matrix_), DTL_TYPE_FORWARD<Args_>(args_)...);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& create(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->draw(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createArray(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->drawArray(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createOperator(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->drawOperator(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createOperatorArray(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->drawOperatorArray(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
CE FractalLoopIsland() NE = default;
CE explicit FractalLoopIsland(CS MI & min_value_) NE
:min_value(min_value_) {}
CE explicit FractalLoopIsland(CS MI & min_value_, CS MI & altitude_) NE
:min_value(min_value_), altitude(altitude_) {}
CE explicit FractalLoopIsland(CS MI & min_value_, CS MI & altitude_, CS MI & add_altitude_) NE
:min_value(min_value_), altitude(altitude_), add_altitude(add_altitude_) {}
CE explicit FractalLoopIsland(CS dtl::base::MatrixRange & matrix_range_) NE
:start_x(matrix_range_.x), start_y(matrix_range_.y),
width(matrix_range_.w), height(matrix_range_.h) {}
CE explicit FractalLoopIsland(CS dtl::base::MatrixRange & matrix_range_, CS MI & min_value_) NE
:start_x(matrix_range_.x), start_y(matrix_range_.y),
width(matrix_range_.w), height(matrix_range_.h),
min_value(min_value_) {}
CE explicit FractalLoopIsland(CS dtl::base::MatrixRange & matrix_range_, CS MI & min_value_, CS MI & altitude_) NE
:start_x(matrix_range_.x), start_y(matrix_range_.y),
width(matrix_range_.w), height(matrix_range_.h),
min_value(min_value_), altitude(altitude_) {}
CE explicit FractalLoopIsland(CS dtl::base::MatrixRange & matrix_range_, CS MI & min_value_, CS MI & altitude_, CS MI & add_altitude_) NE
:start_x(matrix_range_.x), start_y(matrix_range_.y),
width(matrix_range_.w), height(matrix_range_.h),
min_value(min_value_), altitude(altitude_), add_altitude(add_altitude_) {}
CE explicit FractalLoopIsland(CS IS end_x_, CS IS end_y_, CS IS width_, CS IS height_) NE
:start_x(end_x_), start_y(end_y_),
width(width_), height(height_) {}
CE explicit FractalLoopIsland(CS IS end_x_, CS IS end_y_, CS IS width_, CS IS height_, CS MI & min_value_) NE
:start_x(end_x_), start_y(end_y_),
width(width_), height(height_),
min_value(min_value_) {}
CE explicit FractalLoopIsland(CS IS end_x_, CS IS end_y_, CS IS width_, CS IS height_, CS MI & min_value_, CS MI & altitude_) NE
:start_x(end_x_), start_y(end_y_),
width(width_), height(height_),
min_value(min_value_), altitude(altitude_) {}
CE explicit FractalLoopIsland(CS IS end_x_, CS IS end_y_, CS IS width_, CS IS height_, CS MI & min_value_, CS MI & altitude_, CS MI & add_altitude_) NE
:start_x(end_x_), start_y(end_y_),
width(width_), height(height_),
min_value(min_value_), altitude(altitude_), add_altitude(add_altitude_) {}
};
}
}
#endif 
#ifndef IDTL_DTL_SHAPE_MAZE_DIG
#define IDTL_DTL_SHAPE_MAZE_DIG
NS dtl {
inline NS shape {
TP<TN MI, TN UniquePtr_ = DTL_TYPE_UNIQUE_PTR<dtl::type::size[]>>
class MazeDig {
private:
using IS = dtl::type::size;
IS start_x{};
IS start_y{};
IS width{};
IS height{};
MI empty_value{};
MI wall_value{};
TP<TN Matrix_>
DVCC
void mazeDig_Dig(Matrix_&& matrix_, CS dtl::type::size j_max, CS dtl::type::size i_max, dtl::type::size x_, dtl::type::size y_) CS NE {
dtl::type::ssize dx{}, dy{};
for (dtl::type::size random{ dtl::random::mt32bit.get<dtl::type::size>() }, counter{}; counter < 4;) {
switch ((random + counter) & 3) {
case 0:dx = 0; dy = -2; break;
case 1:dx = -2; dy = 0; break;
case 2:dx = 0; dy = 2; break;
case 3:dx = 2; dy = 0; break;
default:dx = 0; dy = 0; break;
}
if (static_cast<dtl::type::ssize>(x_ + dx) <= static_cast<dtl::type::ssize>(start_x) ||
static_cast<dtl::type::ssize>(y_ + dy) <= static_cast<dtl::type::ssize>(start_y) ||
(x_ + dx) >= j_max || (y_ + dy) >= i_max || static_cast<MI>(matrix_[y_ + dy][x_ + dx]) == this->empty_value) {
++counter;
}
else if (matrix_[y_ + dy][x_ + dx] == this->wall_value) {
matrix_[y_ + (dy / 2)][x_ + (dx / 2)] = this->empty_value;
matrix_[y_ + dy][x_ + dx] = this->empty_value;
x_ += dx;
y_ += dy;
counter = 0;
random = dtl::random::mt32bit.get<dtl::type::size>();
}
}
RT;
}
TP<TN Matrix_>
DVCC
void mazeDig_DigLayer(Matrix_&& matrix_, CS IS layer_, CS dtl::type::size j_max, CS dtl::type::size i_max, dtl::type::size x_, dtl::type::size y_) CS NE {
dtl::type::ssize dx{}, dy{};
for (dtl::type::size random{ dtl::random::mt32bit.get<dtl::type::size>() }, counter{}; counter < 4;) {
switch ((random + counter) & 3) {
case 0:dx = 0; dy = -2; break;
case 1:dx = -2; dy = 0; break;
case 2:dx = 0; dy = 2; break;
case 3:dx = 2; dy = 0; break;
default:dx = 0; dy = 0; break;
}
if (x_ + dx <= static_cast<dtl::type::ssize>(start_x) || y_ + dy <= static_cast<dtl::type::ssize>(start_y) || (x_ + dx) >= j_max || (y_ + dy) >= i_max || matrix_[y_ + dy][x_ + dx][layer_] == this->empty_value) {
++counter;
}
else if (matrix_[y_ + dy][x_ + dx][layer_] == this->wall_value) {
matrix_[y_ + (dy / 2)][x_ + (dx / 2)][layer_] = this->empty_value;
matrix_[y_ + dy][x_ + dx][layer_] = this->empty_value;
x_ += dx;
y_ += dy;
counter = 0;
random = dtl::random::mt32bit.get<dtl::type::size>();
}
}
RT;
}
TP<TN Matrix_>
DVCC
void mazeDig_DigArray(Matrix_&& matrix_, CS IS max_x_, CS dtl::type::size j_max, CS dtl::type::size i_max, dtl::type::size x_, dtl::type::size y_) CS NE {
dtl::type::ssize dx{}, dy{};
for (dtl::type::size random{ dtl::random::mt32bit.get<dtl::type::size>() }, counter{}; counter < 4;) {
switch ((random + counter) & 3) {
case 0:dx = 0; dy = -2; break;
case 1:dx = -2; dy = 0; break;
case 2:dx = 0; dy = 2; break;
case 3:dx = 2; dy = 0; break;
default:dx = 0; dy = 0; break;
}
if (x_ + dx <= static_cast<dtl::type::ssize>(start_x) || y_ + dy <= static_cast<dtl::type::ssize>(start_y) || (x_ + dx) >= j_max || (y_ + dy) >= i_max || matrix_[(y_ + dy) * max_x_ + x_ + dx] == this->empty_value) {
++counter;
}
else if (matrix_[(y_ + dy) * max_x_ + x_ + dx] == this->wall_value) {
matrix_[(y_ + (dy / 2)) * max_x_ + x_ + (dx / 2)] = this->empty_value;
matrix_[(y_ + dy) * max_x_ + x_ + dx] = this->empty_value;
x_ += dx;
y_ += dy;
counter = 0;
random = dtl::random::mt32bit.get<dtl::type::size>();
}
}
RT;
}
TP<TN Matrix_>
DVCC
dtl::type::size mazeDig_CreateLoop(CS Matrix_& matrix_, CS dtl::type::size j_max, CS dtl::type::size i_max, UniquePtr_& select_x, UniquePtr_& select_y) CS NE {
dtl::type::size select_id{};
for (dtl::type::size i{ this->start_y + 1 }; i < i_max; i += 2)
for (dtl::type::size j{ this->start_x + 1 }; j < j_max; j += 2) {
if (matrix_[i][j] != this->empty_value) continue;
if ((i >= this->start_y + 2 && matrix_[i - 2][j] == this->wall_value) || (j >= this->start_x + 2 && matrix_[i][j - 2] == this->wall_value)) {
select_x[select_id] = j;
select_y[select_id] = i;
++select_id;
}
else if ((j >= j_max - 1) && (i >= i_max - 1)) break;
else if ((i + 2 < (i_max + 1) && matrix_[i + 2][j] == this->wall_value) || (j + 2 < (j_max + 1) && matrix_[i][j + 2] == this->wall_value)) {
select_x[select_id] = j;
select_y[select_id] = i;
++select_id;
}
}
RT select_id;
}
TP<TN Matrix_>
DVCC
dtl::type::size mazeDig_CreateLoopLayer(CS Matrix_& matrix_, CS IS layer_, CS dtl::type::size j_max, CS dtl::type::size i_max, UniquePtr_& select_x, UniquePtr_& select_y) CS NE {
dtl::type::size select_id{};
for (dtl::type::size i{ this->start_y + 1 }; i < i_max; i += 2)
for (dtl::type::size j{ this->start_x + 1 }; j < j_max; j += 2) {
if (matrix_[i][j][layer_] != this->empty_value) continue;
if ((i >= this->start_y + 2 && matrix_[i - 2][j][layer_] == this->wall_value) || (j >= this->start_x + 2 && matrix_[i][j - 2][layer_] == this->wall_value)) {
select_x[select_id] = j;
select_y[select_id] = i;
++select_id;
}
else if ((j >= j_max - 1) && (i >= i_max - 1)) break;
else if ((i + 2 < (i_max + 1) && matrix_[i + 2][j][layer_] == this->wall_value) || (j + 2 < (j_max + 1) && matrix_[i][j + 2][layer_] == this->wall_value)) {
select_x[select_id] = j;
select_y[select_id] = i;
++select_id;
}
}
RT select_id;
}
TP<TN Matrix_>
DVCC
dtl::type::size mazeDig_CreateLoopArray(CS Matrix_& matrix_, CS IS max_x_, CS dtl::type::size j_max, CS dtl::type::size i_max, UniquePtr_& select_x, UniquePtr_& select_y) CS NE {
dtl::type::size select_id{};
for (dtl::type::size i{ this->start_y + 1 }; i < i_max; i += 2)
for (dtl::type::size j{ this->start_x + 1 }; j < j_max; j += 2) {
if (matrix_[i * max_x_ + j] != this->empty_value) continue;
if ((i >= this->start_y + 2 && matrix_[(i - 2) * max_x_ + j] == this->wall_value) || (j >= this->start_x + 2 && matrix_[i * max_x_ + j - 2] == this->wall_value)) {
select_x[select_id] = j;
select_y[select_id] = i;
++select_id;
}
else if ((j >= j_max - 1) && (i >= i_max - 1)) break;
else if ((i + 2 < (i_max + 1) && matrix_[(i + 2) * max_x_ + j] == this->wall_value) || (j + 2 < (j_max + 1) && matrix_[i * max_x_ + j + 2] == this->wall_value)) {
select_x[select_id] = j;
select_y[select_id] = i;
++select_id;
}
}
RT select_id;
}
TP<TN Matrix_, TN ...Args_>
BL drawNormal(Matrix_ && matrix_, CS IS end_x_, CS IS end_y_, Args_ && ...) CS NE {
matrix_[this->start_y + 1][this->start_x + 1] = this->empty_value;
UniquePtr_ select_x{ DTL_TYPE_NEW dtl::type::size[end_x_ * end_y_] };
if (!select_x) RT false;
UniquePtr_ select_y{ DTL_TYPE_NEW dtl::type::size[end_x_ * end_y_] };
if (!select_y) RT false;
CS dtl::type::size i_max{ ((((end_y_ - this->start_y) & 1) == 0) ? end_y_ - 2 : end_y_ - 1) };
CS dtl::type::size j_max{ ((((end_x_ - this->start_x) & 1) == 0) ? end_x_ - 2 : end_x_ - 1) };
for (dtl::type::size select_id{};;) {
select_id = mazeDig_CreateLoop(matrix_, j_max, i_max, select_x, select_y);
if (select_id == 0) break;
select_id = dtl::random::mt32bit.get<dtl::type::size>(select_id);
mazeDig_Dig(matrix_, j_max, i_max, select_x[select_id], select_y[select_id]);
}
RT true;
}
TP<TN Matrix_, TN ...Args_>
BL drawLayerNormal(Matrix_&& matrix_, CS IS layer_, CS IS end_x_, CS IS end_y_, Args_&& ...) CS NE {
matrix_[this->start_y + 1][this->start_x + 1][layer_] = this->empty_value;
UniquePtr_ select_x{ DTL_TYPE_NEW dtl::type::size[end_x_ * end_y_] };
if (!select_x) RT false;
UniquePtr_ select_y{ DTL_TYPE_NEW dtl::type::size[end_x_ * end_y_] };
if (!select_y) RT false;
CS dtl::type::size i_max{ ((((end_y_ - this->start_y) & 1) == 0) ? end_y_ - 2 : end_y_ - 1) };
CS dtl::type::size j_max{ ((((end_x_ - this->start_x) & 1) == 0) ? end_x_ - 2 : end_x_ - 1) };
for (dtl::type::size select_id{};;) {
select_id = mazeDig_CreateLoopLayer(matrix_, layer_, j_max, i_max, select_x, select_y);
if (select_id == 0) break;
select_id = dtl::random::mt32bit.get<dtl::type::size>(select_id);
mazeDig_DigLayer(matrix_, layer_, j_max, i_max, select_x[select_id], select_y[select_id]);
}
RT true;
}
TP<TN Matrix_, TN ...Args_>
BL drawArray(Matrix_&& matrix_, CS IS end_x_, CS IS end_y_, CS IS max_x_, Args_&& ...) CS NE {
matrix_[(this->start_y + 1) * max_x_ + start_x + 1] = this->empty_value;
UniquePtr_ select_x{ DTL_TYPE_NEW dtl::type::size[end_x_ * end_y_] };
if (!select_x) RT false;
UniquePtr_ select_y{ DTL_TYPE_NEW dtl::type::size[end_x_ * end_y_] };
if (!select_y) RT false;
CS dtl::type::size i_max{ ((((end_y_ - this->start_y) & 1) == 0) ? end_y_ - 2 : end_y_ - 1) };
CS dtl::type::size j_max{ ((((end_x_ - this->start_x) & 1) == 0) ? end_x_ - 2 : end_x_ - 1) };
for (dtl::type::size select_id{};;) {
select_id = mazeDig_CreateLoopArray(matrix_, max_x_, j_max, i_max, select_x, select_y);
if (select_id == 0) break;
select_id = dtl::random::mt32bit.get<dtl::type::size>(select_id);
mazeDig_DigArray(matrix_, max_x_, j_max, i_max, select_x[select_id], select_y[select_id]);
}
RT true;
}
public:
DVCN
CE IS getPointX() CS NE {
RT this->start_x;
}
DVCN
CE IS getPointY() CS NE {
RT this->start_y;
}
DVCN
CE IS getWidth() CS NE {
RT this->width;
}
DVCN
CE IS getHeight() CS NE {
RT this->height;
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_) CS NE {
RT this->drawNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= ((matrix_.size() == 0) ? 0 : matrix_[0].size())) ? ((matrix_.size() == 0) ? 0 : matrix_[0].size()) : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, Function_ && function_) CS NE {
RT this->drawNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= ((matrix_.size() == 0) ? 0 : matrix_[0].size())) ? ((matrix_.size() == 0) ? 0 : matrix_[0].size()) : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_, CS IS layer_) CS NE {
RT this->drawLayerNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->width == 0 || this->start_x + this->width >= ((matrix_.size() == 0) ? 0 : matrix_[0].size())) ? ((matrix_.size() == 0) ? 0 : matrix_[0].size()) : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, CS IS layer_, Function_ && function_) CS NE {
RT this->drawLayerNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->width == 0 || this->start_x + this->width >= ((matrix_.size() == 0) ? 0 : matrix_[0].size())) ? ((matrix_.size() == 0) ? 0 : matrix_[0].size()) : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_) CS NE {
RT this->drawNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_, Function_ && function_) CS NE {
RT this->drawNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_, CS IS layer_, CS IS max_x_, CS IS max_y_) CS NE {
RT this->drawLayerNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, CS IS layer_, CS IS max_x_, CS IS max_y_, Function_ && function_) CS NE {
RT this->drawLayerNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL drawArray(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_) CS NE {
RT this->drawArray(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, max_x_);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperatorArray(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_, Function_ && function_) CS NE {
RT this->drawArray(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, max_x_, function_);
}
TP<TN Matrix_, TN ...Args_>
CE BL operator()(Matrix_ && matrix_, Args_ && ... args_) CS NE {
RT this->draw(DTL_TYPE_FORWARD<Matrix_>(matrix_), DTL_TYPE_FORWARD<Args_>(args_)...);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& create(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->draw(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createArray(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->drawArray(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createOperator(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->drawOperator(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createOperatorArray(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->drawOperatorArray(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
DVCC
MazeDig& clearPointX() NE {
this->start_x = 0;
RT *this;
}
DVCC
MazeDig& clearPointY() NE {
this->start_y = 0;
RT *this;
}
DVCC
MazeDig& clearWidth() NE {
this->width = 0;
RT *this;
}
DVCC
MazeDig& clearHeight() NE {
this->height = 0;
RT *this;
}
DVCC
MazeDig& clearPoint() NE {
this->clearPointX();
this->clearPointY();
RT *this;
}
DVCC
MazeDig& clearRange() NE {
this->clearPointX();
this->clearPointY();
this->clearWidth();
this->clearHeight();
RT *this;
}
DVCC
MazeDig& clear() NE {
this->clearRange();
RT *this;
}
DVCC
MazeDig& setPointX(CS IS end_x_) NE {
this->start_x = end_x_;
RT *this;
}
DVCC
MazeDig& setPointY(CS IS end_y_) NE {
this->start_y = end_y_;
RT *this;
}
DVCC
MazeDig& setWidth(CS IS width_) NE {
this->width = width_;
RT *this;
}
DVCC
MazeDig& setHeight(CS IS height_) NE {
this->height = height_;
RT *this;
}
DVCC
MazeDig& setPoint(CS IS point_) NE {
this->start_x = point_;
this->start_y = point_;
RT *this;
}
DVCC
MazeDig& setPoint(CS IS end_x_, CS IS end_y_) NE {
this->start_x = end_x_;
this->start_y = end_y_;
RT *this;
}
DVCC
MazeDig& setRange(CS IS end_x_, CS IS end_y_, CS IS length_) NE {
this->start_x = end_x_;
this->start_y = end_y_;
this->width = length_;
this->height = length_;
RT *this;
}
DVCC
MazeDig& setRange(CS IS end_x_, CS IS end_y_, CS IS width_, CS IS height_) NE {
this->start_x = end_x_;
this->start_y = end_y_;
this->width = width_;
this->height = height_;
RT *this;
}
DVCC
MazeDig& setRange(CS dtl::base::MatrixRange & matrix_range_) NE {
this->start_x = matrix_range_.x;
this->start_y = matrix_range_.y;
this->width = matrix_range_.w;
this->height = matrix_range_.h;
RT *this;
}
CE MazeDig() NE = default;
CE explicit MazeDig(CS MI & empty_value_) NE
:empty_value(empty_value_) {}
CE explicit MazeDig(CS MI& empty_value_, CS MI& wall_value_) NE
:empty_value(empty_value_), wall_value(wall_value_) {}
CE explicit MazeDig(CS dtl::base::MatrixRange & matrix_range_) NE
:start_x(matrix_range_.x), start_y(matrix_range_.y),
width(matrix_range_.w), height(matrix_range_.h) {}
CE explicit MazeDig(CS dtl::base::MatrixRange & matrix_range_, CS MI & empty_value_) NE
:start_x(matrix_range_.x), start_y(matrix_range_.y),
width(matrix_range_.w), height(matrix_range_.h),
empty_value(empty_value_) {}
CE explicit MazeDig(CS dtl::base::MatrixRange& matrix_range_, CS MI& empty_value_, CS MI& wall_value_) NE
:start_x(matrix_range_.x), start_y(matrix_range_.y),
width(matrix_range_.w), height(matrix_range_.h),
empty_value(empty_value_), wall_value(wall_value_) {}
CE explicit MazeDig(CS IS end_x_, CS IS end_y_, CS IS width_, CS IS height_) NE
:start_x(end_x_), start_y(end_y_),
width(width_), height(height_) {}
CE explicit MazeDig(CS IS end_x_, CS IS end_y_, CS IS width_, CS IS height_, CS MI& empty_value_) NE
:start_x(end_x_), start_y(end_y_),
width(width_), height(height_),
empty_value(empty_value_) {}
CE explicit MazeDig(CS IS end_x_, CS IS end_y_, CS IS width_, CS IS height_, CS MI& empty_value_, CS MI& wall_value_) NE
:start_x(end_x_), start_y(end_y_),
width(width_), height(height_),
empty_value(empty_value_), wall_value(wall_value_) {}
};
}
}
#endif 
#ifndef IDTL_DTL_SHAPE_MIX_RECT
#define IDTL_DTL_SHAPE_MIX_RECT
#include <vector>
NS dtl {
inline NS shape {
TP<TN MI>
class MixRect {
private:
using IS = dtl::type::size;
IS start_x{};
IS start_y{};
IS width{};
IS height{};
std::vector<MI> draw_value{};
DVCC
void string_String() CS NE {}
TP<TN Int_, TN ...Args_>
DVCC
void string_String(CS Int_& first_, CS Args_& ... args_) NE {
this->draw_value.emplace_back(static_cast<MI>(first_));
this->string_String(args_...);
}
TP<TN Matrix_>
DVCC
inline void substitutionSTL(Matrix_&& matrix_, CS IS end_x_, CS IS end_y_) CS NE {
matrix_[end_y_][end_x_] = this->draw_value[dtl::random::mt32bit.get<dtl::type::size>(draw_value.size())];
}
TP<TN Matrix_>
DVCC
inline void substitutionArray(Matrix_&& matrix_, CS IS end_x_, CS IS end_y_, CS IS max_x_) CS NE {
matrix_[end_y_ * max_x_ + end_x_] = this->draw_value[dtl::random::mt32bit.get<dtl::type::size>(draw_value.size())];
}
TP<TN Matrix_>
DVCC
inline void substitutionLayer(Matrix_&& matrix_, CS IS layer_, CS IS end_x_, CS IS end_y_) CS NE {
matrix_[end_y_][end_x_][layer_] = this->draw_value[dtl::random::mt32bit.get<dtl::type::size>(draw_value.size())];
}
TP<TN Matrix_Value_>
DVCC
inline void substitutionList(Matrix_Value_&& matrix_) CS NE {
matrix_ = this->draw_value[dtl::random::mt32bit.get<dtl::type::size>(draw_value.size())];
}
TP<TN Matrix_, TN Function_>
DVCC
inline void substitutionSTL(Matrix_&& matrix_, CS IS end_x_, CS IS end_y_, Function_&& function_) CS NE {
if (function_(matrix_[end_y_][end_x_])) matrix_[end_y_][end_x_] = this->draw_value[dtl::random::mt32bit.get<dtl::type::size>(draw_value.size())];
}
TP<TN Matrix_, TN Function_>
DVCC
inline void substitutionArray(Matrix_&& matrix_, CS IS end_x_, CS IS end_y_, CS IS max_x_, Function_&& function_) CS NE {
if (function_(matrix_[end_y_ * max_x_ + end_x_])) matrix_[end_y_ * max_x_ + end_x_] = this->draw_value[dtl::random::mt32bit.get<dtl::type::size>(draw_value.size())];
}
TP<TN Matrix_, TN Function_>
DVCC
inline void substitutionLayer(Matrix_ && matrix_, CS IS layer_, CS IS end_x_, CS IS end_y_, Function_ && function_) CS NE {
if (function_(matrix_[end_y_][end_x_][layer_])) matrix_[end_y_][end_x_][layer_] = this->draw_value[dtl::random::mt32bit.get<dtl::type::size>(draw_value.size())];
}
TP<TN Matrix_Value_, TN Function_>
DVCC
inline void substitutionList(Matrix_Value_&& matrix_, Function_&& function_) CS NE {
if (function_(matrix_)) matrix_ = this->draw_value[dtl::random::mt32bit.get<dtl::type::size>(draw_value.size())];
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawSTL(Matrix_ && matrix_, CS IS end_y_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i)
for (IS j{ this->start_x }; j < matrix_[i].size(); ++j)
this->substitutionSTL(matrix_, j, i, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawWidthSTL(Matrix_ && matrix_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i)
for (IS j{ this->start_x }; j < matrix_[i].size() && j < end_x_; ++j)
this->substitutionSTL(matrix_, j, i, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawLayerSTL(Matrix_ && matrix_, CS IS layer_, CS IS end_y_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i)
for (IS j{ this->start_x }; j < matrix_[i].size(); ++j)
this->substitutionLayer(matrix_, layer_, j, i, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawLayerWidthSTL(Matrix_ && matrix_, CS IS layer_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i)
for (IS j{ this->start_x }; j < matrix_[i].size() && j < end_x_; ++j)
this->substitutionLayer(matrix_, layer_, j, i, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawNormal(Matrix_ && matrix_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i)
for (IS j{ this->start_x }; j < end_x_; ++j)
this->substitutionSTL(matrix_, j, i, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawLayerNormal(Matrix_ && matrix_, CS IS layer_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i)
for (IS j{ this->start_x }; j < end_x_; ++j)
this->substitutionLayer(matrix_, layer_, j, i, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawArray(Matrix_ && matrix_, CS IS end_x_, CS IS end_y_, CS IS max_x_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i)
for (IS j{ this->start_x }; j < end_x_; ++j)
this->substitutionArray(matrix_, j, i, max_x_, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawList(Matrix_&& matrix_, CS IS end_x_, CS IS end_y_, Args_&& ... args_) CS NE {
dtl::type::size row_count{}, col_count{};
for (auto&& i : matrix_) {
++row_count;
if (row_count <= this->start_y) continue;
if (end_y_ != 1 && row_count >= end_y_) break;
col_count = 0;
for (auto&& j : i) {
++col_count;
if (col_count <= this->start_x) continue;
if (end_x_ != 1 && col_count >= end_x_) break;
this->substitutionList(j, args_...);
}
}
RT true;
}
public:
DVCN
CE IS getPointX() CS NE {
RT this->start_x;
}
DVCN
CE IS getPointY() CS NE {
RT this->start_y;
}
DVCN
CE IS getWidth() CS NE {
RT this->width;
}
DVCN
CE IS getHeight() CS NE {
RT this->height;
}
DVCN
DVCC
std::vector<MI> getValue() CS NE {
RT this->draw_value;
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_) CS NE {
RT (this->width == 0) ? this->drawSTL(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height) : this->drawWidthSTL(matrix_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, Function_ && function_) CS NE {
RT (this->width == 0) ? this->drawSTL(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_) : this->drawWidthSTL(matrix_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_, CS IS layer_) CS NE {
RT (this->width == 0) ? this->drawLayerSTL(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height) : this->drawLayerWidthSTL(matrix_, layer_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, CS IS layer_, Function_ && function_) CS NE {
RT (this->width == 0) ? this->drawLayerSTL(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_) : this->drawLayerWidthSTL(matrix_, layer_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_) CS NE {
RT this->drawNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_, Function_ && function_) CS NE {
RT this->drawNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_, CS IS layer_, CS IS max_x_, CS IS max_y_) CS NE {
RT this->drawLayerNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, CS IS layer_, CS IS max_x_, CS IS max_y_, Function_ && function_) CS NE {
RT this->drawLayerNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL drawArray(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_) CS NE {
RT this->drawArray(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, max_x_);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperatorArray(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_, Function_ && function_) CS NE {
RT this->drawArray(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, max_x_, function_);
}
TP<TN Matrix_>
CE BL drawList(Matrix_&& matrix_) CS NE {
RT this->drawList(DTL_TYPE_FORWARD<Matrix_>(matrix_), this->start_x + this->width + 1, this->start_y + this->height + 1);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperatorList(Matrix_ && matrix_, Function_ && function_) CS NE {
RT this->drawList(DTL_TYPE_FORWARD<Matrix_>(matrix_), this->start_x + this->width + 1, this->start_y + this->height + 1, function_);
}
TP<TN Matrix_, TN ...Args_>
CE BL operator()(Matrix_&& matrix_, Args_&& ... args_) CS NE {
RT this->draw(DTL_TYPE_FORWARD<Matrix_>(matrix_), DTL_TYPE_FORWARD<Args_>(args_)...);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& create(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->draw(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createArray(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->drawArray(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createOperator(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->drawOperator(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createOperatorArray(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->drawOperatorArray(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
DVCC
MixRect& clearPointX() NE {
this->start_x = 0;
RT *this;
}
DVCC
MixRect& clearPointY() NE {
this->start_y = 0;
RT *this;
}
DVCC
MixRect& clearWidth() NE {
this->width = 0;
RT *this;
}
DVCC
MixRect& clearHeight() NE {
this->height = 0;
RT *this;
}
DVCC
MixRect& clearValue() NE {
std::vector<MI> new_draw_value{};
this->draw_value = std::move(new_draw_value);
RT *this;
}
DVCC
MixRect& clearPoint() NE {
this->clearPointX();
this->clearPointY();
RT *this;
}
DVCC
MixRect& clearRange() NE {
this->clearPointX();
this->clearPointY();
this->clearWidth();
this->clearHeight();
RT *this;
}
DVCC
MixRect& clear() NE {
this->clearRange();
this->clearValue();
RT *this;
}
DVCC
MixRect& setPointX(CS IS end_x_) NE {
this->start_x = end_x_;
RT *this;
}
DVCC
MixRect& setPointY(CS IS end_y_) NE {
this->start_y = end_y_;
RT *this;
}
DVCC
MixRect& setWidth(CS IS width_) NE {
this->width = width_;
RT *this;
}
DVCC
MixRect& setHeight(CS IS height_) NE {
this->height = height_;
RT *this;
}
DVCC
MixRect& setValue(CS std::vector<MI>& draw_value_) NE {
this->draw_value = draw_value_;
RT *this;
}
TP<TN ...Args_>
DVCC
MixRect& setValue(CS MI& first_, CS Args_& ... args_) NE {
this->string_String(first_, args_...);
RT *this;
}
DVCC
MixRect& setPoint(CS IS point_) NE {
this->start_x = point_;
this->start_y = point_;
RT *this;
}
DVCC
MixRect& setPoint(CS IS end_x_, CS IS end_y_) NE {
this->start_x = end_x_;
this->start_y = end_y_;
RT *this;
}
DVCC
MixRect& setRange(CS IS end_x_, CS IS end_y_, CS IS length_) NE {
this->start_x = end_x_;
this->start_y = end_y_;
this->width = length_;
this->height = length_;
RT *this;
}
DVCC
MixRect& setRange(CS IS end_x_, CS IS end_y_, CS IS width_, CS IS height_) NE {
this->start_x = end_x_;
this->start_y = end_y_;
this->width = width_;
this->height = height_;
RT *this;
}
DVCC
MixRect& setRange(CS dtl::base::MatrixRange& matrix_range_) NE {
this->start_x = matrix_range_.x;
this->start_y = matrix_range_.y;
this->width = matrix_range_.w;
this->height = matrix_range_.h;
RT *this;
}
CE MixRect() NE = default;
TP<TN ...Args_>
explicit MixRect(CS MI & first_, CS Args_ & ... args_) NE {
this->string_String(first_, args_...);
}
CE explicit MixRect(CS dtl::base::MatrixRange & matrix_range_) NE
:start_x(matrix_range_.x), start_y(matrix_range_.y),
width(matrix_range_.w), height(matrix_range_.h) {}
TP<TN ...Args_>
explicit MixRect(CS dtl::base::MatrixRange & matrix_range_, CS MI & first_, CS Args_ & ... args_) NE
:start_x(matrix_range_.x), start_y(matrix_range_.y),
width(matrix_range_.w), height(matrix_range_.h) {
this->string_String(first_, args_...);
}
};
}
}
#endif 
#ifndef IDTL_DTL_SHAPE_POINT
#define IDTL_DTL_SHAPE_POINT
NS dtl {
inline NS shape {
NS stl {
TP<TN Matrix_>
DVCC
void createPoint(Matrix_& matrix_, CS dtl::type::size set_x_, CS dtl::type::size set_y_) NE {
if (matrix_.size() <= set_y_ || matrix_[set_y_].size() <= set_x_) RT;
matrix_[set_y_][set_x_] = 1;
}
TP<TN MI, TN Matrix_>
DVCC
void createPoint(Matrix_& matrix_, CS dtl::type::size set_x_, CS dtl::type::size set_y_, CS MI value_) NE {
if (matrix_.size() <= set_y_ || matrix_[set_y_].size() <= set_x_) RT;
matrix_[set_y_][set_x_] = value_;
}
TP<TN MI>
class PointUnique {
private:
dtl::type::size x{}, y{};
MI value{ 1 };
public:
CE explicit PointUnique(CS dtl::type::size x_, CS dtl::type::size y_) NE :x(x_), y(y_) {}
CE explicit PointUnique(CS dtl::type::size x_, CS dtl::type::size y_, CS MI value_) NE :x(x_), y(y_), value(value_) {}
TP<TN Matrix_>
DVCC
void draw(Matrix_& matrix_) CS NE {
dtl::shape::stl::createPoint(matrix_, x, y, value);
}
};
TP<TN MI>
class Point {
private:
public:
CE Point() NE = default;
TP<TN Matrix_>
DVCC
void draw(Matrix_& matrix_, CS dtl::type::size x_, CS dtl::type::size y_) CS NE {
dtl::shape::stl::createPoint(matrix_, x_, y_);
}
TP<TN Matrix_>
DVCC
void draw(Matrix_& matrix_, CS dtl::type::size x_, CS dtl::type::size y_, CS MI value_) CS NE {
dtl::shape::stl::createPoint(matrix_, x_, y_, value_);
}
};
}
}
}
NS dtl {
inline NS shape {
NS normal {
TP<TN Matrix_>
DVCC
void createPoint(Matrix_& matrix_, CS dtl::type::size set_x_, CS dtl::type::size set_y_) NE {
matrix_[set_y_][set_x_] = 1;
}
TP<TN MI, TN Matrix_>
DVCC
void createPoint(Matrix_& matrix_, CS dtl::type::size set_x_, CS dtl::type::size set_y_, CS MI value_) NE {
matrix_[set_y_][set_x_] = value_;
}
TP<TN Matrix_>
DVCC
void createPoint(Matrix_& matrix_, CS dtl::type::size x_, CS dtl::type::size y_, CS dtl::type::size set_x_, CS dtl::type::size set_y_) NE {
if (x_ <= set_x_ || y_ <= set_y_) RT;
matrix_[set_y_][set_x_] = 1;
}
TP<TN MI, TN Matrix_>
DVCC
void createPoint(Matrix_& matrix_, CS dtl::type::size x_, CS dtl::type::size y_, CS dtl::type::size set_x_, CS dtl::type::size set_y_, CS MI value_) NE {
if (x_ <= set_x_ || y_ <= set_y_) RT;
matrix_[set_y_][set_x_] = value_;
}
TP<TN MI>
class PointUnique {
private:
dtl::type::size x{}, y{};
MI value{ 1 };
public:
CE explicit PointUnique(CS dtl::type::size x_, CS dtl::type::size y_) NE :x(x_), y(y_) {}
CE explicit PointUnique(CS dtl::type::size x_, CS dtl::type::size y_, CS MI value_) NE :x(x_), y(y_), value(value_) {}
TP<TN Matrix_>
DVCC
void draw(Matrix_& matrix_) CS NE {
dtl::shape::normal::createPoint(matrix_, x, y, value);
}
TP<TN Matrix_>
DVCC
void draw(Matrix_& matrix_, CS dtl::type::size size_x_, CS dtl::type::size size_y_) CS NE {
dtl::shape::normal::createPoint(matrix_, size_x_, size_y_, x, y, value);
}
TP<TN Matrix_>
DVCC
void draw(Matrix_& matrix_, CS dtl::type::size size_) CS NE {
dtl::shape::normal::createPoint(matrix_, size_, size_, x, y, value);
}
};
TP<TN MI>
class Point {
private:
public:
CE Point() NE = default;
};
}
}
}
NS  dtl {
inline NS shape {
NS array {
TP<TN Matrix_>
DVCC
void createPoint(Matrix_& matrix_, CS dtl::type::size x_, CS dtl::type::size y_, CS dtl::type::size set_x_, CS dtl::type::size set_y_) NE {
if (x_ <= set_x_ || y_ <= set_y_) RT;
matrix_[set_y_*x_ + set_x_] = 1;
}
TP<TN MI, TN Matrix_>
DVCC
void createPoint(Matrix_& matrix_, CS dtl::type::size x_, CS dtl::type::size y_, CS dtl::type::size set_x_, CS dtl::type::size set_y_, CS MI value_) NE {
if (x_ <= set_x_ || y_ <= set_y_) RT;
matrix_[set_y_*x_ + set_x_] = value_;
}
TP<TN MI>
class PointUnique {
private:
dtl::type::size x{}, y{};
MI value{ 1 };
public:
CE explicit PointUnique(CS dtl::type::size x_, CS dtl::type::size y_) NE :x(x_), y(y_) {}
CE explicit PointUnique(CS dtl::type::size x_, CS dtl::type::size y_, CS MI value_) NE :x(x_), y(y_), value(value_) {}
TP<TN Matrix_>
DVCC
void draw(Matrix_& matrix_, CS dtl::type::size size_x_, CS dtl::type::size size_y_) CS NE {
dtl::shape::array::createPoint(matrix_, size_x_, size_y_, x, y, value);
}
TP<TN Matrix_>
DVCC
void draw(Matrix_& matrix_, CS dtl::type::size size_) CS NE {
dtl::shape::array::createPoint(matrix_, size_, size_, x, y, value);
}
};
}
}
}
NS  dtl {
inline NS shape {
NS layer {
NS stl {
TP<TN Matrix_>
DVCC
void createPoint(Matrix_& matrix_, CS dtl::type::size layer_, dtl::type::size set_x_, CS dtl::type::size set_y_) NE {
if (matrix_.size() <= set_y_ || matrix_[set_y_].size() <= set_x_) RT;
matrix_[set_y_][set_x_][layer_] = 1;
}
TP<TN MI, TN Matrix_>
DVCC
void createPoint(Matrix_ & matrix_, CS dtl::type::size layer_, CS dtl::type::size set_x_, CS dtl::type::size set_y_, CS MI value_) NE {
if (matrix_.size() <= set_y_ || matrix_[set_y_].size() <= set_x_) RT;
matrix_[set_y_][set_x_][layer_] = value_;
}
TP<TN MI>
class PointUnique {
private:
dtl::type::size x{}, y{};
MI value{ 1 };
public:
CE explicit PointUnique(CS dtl::type::size x_, CS dtl::type::size y_) NE :x(x_), y(y_) {}
CE explicit PointUnique(CS dtl::type::size x_, CS dtl::type::size y_, CS MI value_) NE :x(x_), y(y_), value(value_) {}
TP<TN Matrix_>
DVCC
void draw(Matrix_& matrix_, CS dtl::type::size layer_) CS NE {
dtl::shape::layer::stl::createPoint(matrix_, layer_, x, y, value);
}
};
}
}
}
}
NS  dtl {
inline NS shape {
NS layer {
NS normal {
TP<TN Matrix_>
DVCC
void createPoint(Matrix_& matrix_, CS dtl::type::size layer_, CS dtl::type::size set_x_, CS dtl::type::size set_y_) NE {
matrix_[set_y_][set_x_][layer_] = 1;
}
TP<TN MI, TN Matrix_>
DVCC
void createPoint(Matrix_& matrix_, CS dtl::type::size layer_, CS dtl::type::size set_x_, CS dtl::type::size set_y_, CS MI value_) NE {
matrix_[set_y_][set_x_][layer_] = value_;
}
TP<TN Matrix_>
DVCC
void createPoint(Matrix_& matrix_, CS dtl::type::size layer_, CS dtl::type::size x_, CS dtl::type::size y_, CS dtl::type::size set_x_, CS dtl::type::size set_y_) NE {
if (x_ <= set_x_ || y_ <= set_y_) RT;
matrix_[set_y_][set_x_][layer_] = 1;
}
TP<TN MI, TN Matrix_>
DVCC
void createPoint(Matrix_ & matrix_, CS dtl::type::size layer_, CS dtl::type::size x_, CS dtl::type::size y_, CS dtl::type::size set_x_, CS dtl::type::size set_y_, CS MI value_) NE {
if (x_ <= set_x_ || y_ <= set_y_) RT;
matrix_[set_y_][set_x_][layer_] = value_;
}
TP<TN MI>
class PointUnique {
private:
dtl::type::size x{}, y{};
MI value{ 1 };
public:
CE explicit PointUnique(CS dtl::type::size x_, CS dtl::type::size y_) NE :x(x_), y(y_) {}
CE explicit PointUnique(CS dtl::type::size x_, CS dtl::type::size y_, CS MI value_) NE :x(x_), y(y_), value(value_) {}
TP<TN Matrix_>
DVCC
void draw(Matrix_& matrix_, CS dtl::type::size layer_) CS NE {
dtl::shape::layer::normal::createPoint(matrix_, layer_, x, y, value);
}
TP<TN Matrix_>
DVCC
void draw(Matrix_& matrix_, CS dtl::type::size layer_, CS dtl::type::size size_x_, CS dtl::type::size size_y_) CS NE {
dtl::shape::layer::normal::createPoint(matrix_, layer_, size_x_, size_y_, x, y, value);
}
TP<TN Matrix_>
DVCC
void draw(Matrix_& matrix_, CS dtl::type::size layer_, CS dtl::type::size size_) CS NE {
dtl::shape::layer::normal::createPoint(matrix_, layer_, size_, size_, x, y, value);
}
};
}
}
}
}
#endif 
#ifndef IDTL_DTL_SHAPE_POINT_GRID
#define IDTL_DTL_SHAPE_POINT_GRID
NS dtl {
inline NS shape {
TP<TN MI>
class PointGrid {
private:
using IS = dtl::type::size;
IS start_x{};
IS start_y{};
IS width{};
IS height{};
MI draw_value{};
TP<TN Matrix_>
DVCC
inline void substitutionSTL(Matrix_&& matrix_, CS IS end_x_, CS IS end_y_) CS NE {
matrix_[end_y_][end_x_] = this->draw_value;
}
TP<TN Matrix_>
DVCC
inline void substitutionArray(Matrix_&& matrix_, CS IS end_x_, CS IS end_y_, CS IS max_x_) CS NE {
matrix_[end_y_ * max_x_ + end_x_] = this->draw_value;
}
TP<TN Matrix_>
DVCC
inline void substitutionLayer(Matrix_&& matrix_, CS IS layer_, CS IS end_x_, CS IS end_y_) CS NE {
matrix_[end_y_][end_x_][layer_] = this->draw_value;
}
TP<TN Matrix_, TN Function_>
DVCC
inline void substitutionSTL(Matrix_&& matrix_, CS IS end_x_, CS IS end_y_, Function_&& function_) CS NE {
if (function_(matrix_[end_y_][end_x_])) matrix_[end_y_][end_x_] = this->draw_value;
}
TP<TN Matrix_, TN Function_>
DVCC
inline void substitutionArray(Matrix_&& matrix_, CS IS end_x_, CS IS end_y_, CS IS max_x_, Function_&& function_) CS NE {
if (function_(matrix_[end_y_ * max_x_ + end_x_])) matrix_[end_y_ * max_x_ + end_x_] = this->draw_value;
}
TP<TN Matrix_, TN Function_>
DVCC
inline void substitutionLayer(Matrix_ && matrix_, CS IS layer_, CS IS end_x_, CS IS end_y_, Function_ && function_) CS NE {
if (function_(matrix_[end_y_][end_x_][layer_])) matrix_[end_y_][end_x_][layer_] = this->draw_value;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawSTL(Matrix_ && matrix_, CS IS end_y_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y }; i < end_y_; i += 2)
for (IS j{ this->start_x }; j < matrix_[i].size(); j += 2)
this->substitutionSTL(matrix_, j, i, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawWidthSTL(Matrix_ && matrix_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y }; i < end_y_; i += 2)
for (IS j{ this->start_x }; j < matrix_[i].size() && j < end_x_; j += 2)
this->substitutionSTL(matrix_, j, i, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawLayerSTL(Matrix_ && matrix_, CS IS layer_, CS IS end_y_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y }; i < end_y_; i += 2)
for (IS j{ this->start_x }; j < matrix_[i].size(); j += 2)
this->substitutionLayer(matrix_, layer_, j, i, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawLayerWidthSTL(Matrix_ && matrix_, CS IS layer_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y }; i < end_y_; i += 2)
for (IS j{ this->start_x }; j < matrix_[i].size() && j < end_x_; j += 2)
this->substitutionLayer(matrix_, layer_, j, i, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawNormal(Matrix_ && matrix_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y }; i < end_y_; i += 2)
for (IS j{ this->start_x }; j < end_x_; j += 2)
this->substitutionSTL(matrix_, j, i, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawLayerNormal(Matrix_ && matrix_, CS IS layer_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y }; i < end_y_; i += 2)
for (IS j{ this->start_x }; j < end_x_; j += 2)
this->substitutionLayer(matrix_, layer_, j, i, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawArray(Matrix_ && matrix_, CS IS end_x_, CS IS end_y_, CS IS max_x_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y }; i < end_y_; i += 2)
for (IS j{ this->start_x }; j < end_x_; j += 2)
this->substitutionArray(matrix_, j, i, max_x_, args_...);
RT true;
}
public:
DVCN
CE IS getPointX() CS NE {
RT this->start_x;
}
DVCN
CE IS getPointY() CS NE {
RT this->start_y;
}
DVCN
CE IS getWidth() CS NE {
RT this->width;
}
DVCN
CE IS getHeight() CS NE {
RT this->height;
}
DVCN
CE MI getValue() CS NE {
RT this->draw_value;
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_) CS NE {
RT (this->width == 0) ? this->drawSTL(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height) : this->drawWidthSTL(matrix_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, Function_ && function_) CS NE {
RT (this->width == 0) ? this->drawSTL(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_) : this->drawWidthSTL(matrix_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_, CS IS layer_) CS NE {
RT (this->width == 0) ? this->drawLayerSTL(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height) : this->drawLayerWidthSTL(matrix_, layer_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, CS IS layer_, Function_ && function_) CS NE {
RT (this->width == 0) ? this->drawLayerSTL(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_) : this->drawLayerWidthSTL(matrix_, layer_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_) CS NE {
RT this->drawNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_, Function_ && function_) CS NE {
RT this->drawNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_, CS IS layer_, CS IS max_x_, CS IS max_y_) CS NE {
RT this->drawLayerNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, CS IS layer_, CS IS max_x_, CS IS max_y_, Function_ && function_) CS NE {
RT this->drawLayerNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL drawArray(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_) CS NE {
RT this->drawArray(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, max_x_);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperatorArray(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_, Function_ && function_) CS NE {
RT this->drawArray(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, max_x_, function_);
}
TP<TN Matrix_, TN ...Args_>
CE BL operator()(Matrix_ && matrix_, Args_ && ... args_) CS NE {
RT this->draw(DTL_TYPE_FORWARD<Matrix_>(matrix_), DTL_TYPE_FORWARD<Args_>(args_)...);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& create(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->draw(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createArray(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->drawArray(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createOperator(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->drawOperator(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createOperatorArray(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->drawOperatorArray(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
DVCC
PointGrid& clearPointX() NE {
this->start_x = 0;
RT *this;
}
DVCC
PointGrid& clearPointY() NE {
this->start_y = 0;
RT *this;
}
DVCC
PointGrid& clearWidth() NE {
this->width = 0;
RT *this;
}
DVCC
PointGrid& clearHeight() NE {
this->height = 0;
RT *this;
}
DVCC
PointGrid& clearValue() NE {
CS MI new_draw_value{};
this->draw_value = new_draw_value;
RT *this;
}
DVCC
PointGrid& clearPoint() NE {
this->clearPointX();
this->clearPointY();
RT *this;
}
DVCC
PointGrid& clearRange() NE {
this->clearPointX();
this->clearPointY();
this->clearWidth();
this->clearHeight();
RT *this;
}
DVCC
PointGrid& clear() NE {
this->clearRange();
this->clearValue();
RT *this;
}
DVCC
PointGrid& setPointX(CS IS end_x_) NE {
this->start_x = end_x_;
RT *this;
}
DVCC
PointGrid& setPointY(CS IS end_y_) NE {
this->start_y = end_y_;
RT *this;
}
DVCC
PointGrid& setWidth(CS IS width_) NE {
this->width = width_;
RT *this;
}
DVCC
PointGrid& setHeight(CS IS height_) NE {
this->height = height_;
RT *this;
}
DVCC
PointGrid& setValue(CS MI & draw_value_) NE {
this->draw_value = draw_value_;
RT *this;
}
DVCC
PointGrid& setPoint(CS IS point_) NE {
this->start_x = point_;
this->start_y = point_;
RT *this;
}
DVCC
PointGrid& setPoint(CS IS end_x_, CS IS end_y_) NE {
this->start_x = end_x_;
this->start_y = end_y_;
RT *this;
}
DVCC
PointGrid& setRange(CS IS end_x_, CS IS end_y_, CS IS length_) NE {
this->start_x = end_x_;
this->start_y = end_y_;
this->width = length_;
this->height = length_;
RT *this;
}
DVCC
PointGrid& setRange(CS IS end_x_, CS IS end_y_, CS IS width_, CS IS height_) NE {
this->start_x = end_x_;
this->start_y = end_y_;
this->width = width_;
this->height = height_;
RT *this;
}
DVCC
PointGrid& setRange(CS dtl::base::MatrixRange & matrix_range_) NE {
this->start_x = matrix_range_.x;
this->start_y = matrix_range_.y;
this->width = matrix_range_.w;
this->height = matrix_range_.h;
RT *this;
}
CE PointGrid() NE = default;
CE explicit PointGrid(CS MI & draw_value_) NE
:draw_value(draw_value_) {}
CE explicit PointGrid(CS dtl::base::MatrixRange & matrix_range_) NE
:start_x(matrix_range_.x), start_y(matrix_range_.y),
width(matrix_range_.w), height(matrix_range_.h) {}
CE explicit PointGrid(CS dtl::base::MatrixRange & matrix_range_, CS MI & draw_value_) NE
:start_x(matrix_range_.x), start_y(matrix_range_.y),
width(matrix_range_.w), height(matrix_range_.h),
draw_value(draw_value_) {}
CE explicit PointGrid(CS IS end_x_, CS IS end_y_, CS IS width_, CS IS height_) NE
:start_x(end_x_), start_y(end_y_),
width(width_), height(height_) {}
CE explicit PointGrid(CS IS end_x_, CS IS end_y_, CS IS width_, CS IS height_, CS MI & draw_value_) NE
:start_x(end_x_), start_y(end_y_),
width(width_), height(height_),
draw_value(draw_value_) {}
};
}
}
#endif 
#ifndef IDTL_DTL_SHAPE_POINT_GRID_AND_SOME_BLOCKS_WITH_BORDER
#define IDTL_DTL_SHAPE_POINT_GRID_AND_SOME_BLOCKS_WITH_BORDER
NS dtl {
inline NS shape {
TP<TN MI>
class PointGridAndSomeBlocksWithBorder {
private:
using IS = dtl::type::size;
dtl::shape::RandomRect<MI> randomRect{};
dtl::shape::BorderOdd<MI> borderOdd{};
dtl::shape::PointGrid<MI> pointGrid{};
public:
DVCN
CE IS getPointX() CS NE {
RT this->borderOdd.getPointX();
}
DVCN
CE IS getPointY() CS NE {
RT this->borderOdd.getPointY();
}
DVCN
CE IS getWidth() CS NE {
RT this->borderOdd.getWidth();
}
DVCN
CE IS getHeight() CS NE {
RT this->borderOdd.getHeight();
}
DVCN
CE MI getValue() CS NE {
RT this->borderOdd.getValue();
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL draw(Matrix_&& matrix_, Args_&& ... args_) CS NE {
this->randomRect.draw(matrix_, args_...);
this->pointGrid.draw(matrix_, args_...);
this->borderOdd.draw(DTL_TYPE_FORWARD<Matrix_>(matrix_), DTL_TYPE_FORWARD<Args_>(args_)...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawOperator(Matrix_&& matrix_, Args_&& ... args_) CS NE {
this->randomRect.draw(matrix_, args_...);
this->pointGrid.drawOperator(matrix_, args_...);
this->borderOdd.drawOperator(DTL_TYPE_FORWARD<Matrix_>(matrix_), DTL_TYPE_FORWARD<Args_>(args_)...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawArray(Matrix_&& matrix_, Args_&& ... args_) CS NE {
this->randomRect.drawArray(matrix_, args_...);
this->pointGrid.drawArray(matrix_, args_...);
this->borderOdd.drawArray(DTL_TYPE_FORWARD<Matrix_>(matrix_), DTL_TYPE_FORWARD<Args_>(args_)...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawOperatorArray(Matrix_&& matrix_, Args_&& ... args_) CS NE {
this->randomRect.drawOperatorArray(matrix_, args_...);
this->pointGrid.drawOperatorArray(matrix_, args_...);
this->borderOdd.drawOperatorArray(DTL_TYPE_FORWARD<Matrix_>(matrix_), DTL_TYPE_FORWARD<Args_>(args_)...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
CE BL operator()(Matrix_&& matrix_, Args_&& ... args_) CS NE {
RT this->draw(DTL_TYPE_FORWARD<Matrix_>(matrix_), DTL_TYPE_FORWARD<Args_>(args_)...);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& create(Matrix_&& matrix_, Args_&& ... args_) CS NE {
this->draw(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createArray(Matrix_&& matrix_, Args_&& ... args_) CS NE {
this->drawArray(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createOperator(Matrix_&& matrix_, Args_&& ... args_) CS NE {
this->drawOperator(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createOperatorArray(Matrix_&& matrix_, Args_&& ... args_) CS NE {
this->drawOperatorArray(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
DVCC
PointGridAndSomeBlocksWithBorder& clearPointX() NE {
this->randomRect.clearPointX();
this->borderOdd.clearPointX();
this->pointGrid.clearPointX();
RT *this;
}
DVCC
PointGridAndSomeBlocksWithBorder& clearPointY() NE {
this->randomRect.clearPointY();
this->borderOdd.clearPointY();
this->pointGrid.clearPointY();
RT *this;
}
DVCC
PointGridAndSomeBlocksWithBorder& clearWidth() NE {
this->randomRect.clearWidth();
this->borderOdd.clearWidth();
this->pointGrid.clearWidth();
RT *this;
}
DVCC
PointGridAndSomeBlocksWithBorder& clearHeight() NE {
this->randomRect.clearHeight();
this->borderOdd.clearHeight();
this->pointGrid.clearHeight();
RT *this;
}
DVCC
PointGridAndSomeBlocksWithBorder& clearValue() NE {
this->randomRect.clearValue();
this->borderOdd.clearValue();
this->pointGrid.clearValue();
RT *this;
}
DVCC
PointGridAndSomeBlocksWithBorder& clearPoint() NE {
this->clearPointX();
this->clearPointY();
RT *this;
}
DVCC
PointGridAndSomeBlocksWithBorder& clearRange() NE {
this->clearPointX();
this->clearPointY();
this->clearWidth();
this->clearHeight();
RT *this;
}
DVCC
PointGridAndSomeBlocksWithBorder& clear() NE {
this->clearRange();
this->clearValue();
RT *this;
}
DVCC
PointGridAndSomeBlocksWithBorder& setPointX(CS IS end_x_) NE {
this->randomRect.setPointX(end_x_);
this->borderOdd.setPointX(end_x_);
this->pointGrid.setPointX(end_x_);
RT *this;
}
DVCC
PointGridAndSomeBlocksWithBorder& setPointY(CS IS end_y_) NE {
this->randomRect.setPointY(end_y_);
this->borderOdd.setPointY(end_y_);
this->pointGrid.setPointY(end_y_);
RT *this;
}
DVCC
PointGridAndSomeBlocksWithBorder& setWidth(CS IS width_) NE {
this->randomRect.setWidth(width_);
this->borderOdd.setWidth(width_);
this->pointGrid.setWidth(width_);
RT *this;
}
DVCC
PointGridAndSomeBlocksWithBorder& setHeight(CS IS height_) NE {
this->randomRect.setHeight(height_);
this->borderOdd.setHeight(height_);
this->pointGrid.setHeight(height_);
RT *this;
}
DVCC
PointGridAndSomeBlocksWithBorder& setValue(CS MI& draw_value_) NE {
this->randomRect.setValue(draw_value_);
this->borderOdd.setValue(draw_value_);
this->pointGrid.setValue(draw_value_);
RT *this;
}
DVCC
PointGridAndSomeBlocksWithBorder& setRange(CS dtl::base::MatrixRange& matrix_range_) NE {
this->randomRect.setRange(matrix_range_);
this->borderOdd.setRange(matrix_range_);
this->pointGrid.setRange(matrix_range_);
RT *this;
}
DVCC
PointGridAndSomeBlocksWithBorder& setPoint(CS IS point_) NE {
this->setPointX(point_);
this->setPointY(point_);
RT *this;
}
DVCC
PointGridAndSomeBlocksWithBorder& setPoint(CS IS end_x_, CS IS end_y_) NE {
this->setPointX(end_x_);
this->setPointY(end_y_);
RT *this;
}
DVCC
PointGridAndSomeBlocksWithBorder& setRange(CS IS end_x_, CS IS end_y_, CS IS length_) NE {
this->setPointX(end_x_);
this->setPointY(end_y_);
this->setWidth(length_);
this->setHeight(length_);
RT *this;
}
DVCC
PointGridAndSomeBlocksWithBorder& setRange(CS IS end_x_, CS IS end_y_, CS IS width_, CS IS height_) NE {
this->setPointX(end_x_);
this->setPointY(end_y_);
this->setWidth(width_);
this->setHeight(height_);
RT *this;
}
CE PointGridAndSomeBlocksWithBorder() NE = default;
CE explicit PointGridAndSomeBlocksWithBorder(CS MI& draw_value_) NE
:randomRect(draw_value_), borderOdd(draw_value_), pointGrid(draw_value_) {}
CE explicit PointGridAndSomeBlocksWithBorder(CS MI& draw_value_, CS MI& draw_value2_) NE
:borderOdd(draw_value2_), pointGrid(draw_value_) {}
CE explicit PointGridAndSomeBlocksWithBorder(CS MI& draw_value_, CS MI& draw_value2_, CS MI& draw_value3_) NE
:randomRect(draw_value3_), borderOdd(draw_value2_), pointGrid(draw_value_) {}
CE explicit PointGridAndSomeBlocksWithBorder(CS MI& draw_value_, CS MI& draw_value2_, CS MI& draw_value3_, CS double probability_) NE
:randomRect(draw_value3_, probability_), borderOdd(draw_value2_), pointGrid(draw_value_) {}
CE explicit PointGridAndSomeBlocksWithBorder(CS dtl::base::MatrixRange& matrix_range_) NE
:randomRect(matrix_range_), borderOdd(matrix_range_), pointGrid(matrix_range_) {}
CE explicit PointGridAndSomeBlocksWithBorder(CS dtl::base::MatrixRange& matrix_range_, CS MI& draw_value_) NE
:randomRect(matrix_range_, draw_value_), borderOdd(matrix_range_, draw_value_), pointGrid(matrix_range_, draw_value_) {}
CE explicit PointGridAndSomeBlocksWithBorder(CS dtl::base::MatrixRange& matrix_range_, CS MI& draw_value_, CS MI& draw_value2_) NE
:borderOdd(matrix_range_, draw_value2_), pointGrid(matrix_range_, draw_value_) {}
CE explicit PointGridAndSomeBlocksWithBorder(CS dtl::base::MatrixRange& matrix_range_, CS MI& draw_value_, CS MI& draw_value2_, CS MI& draw_value3_) NE
:randomRect(matrix_range_, draw_value3_), borderOdd(matrix_range_, draw_value2_), pointGrid(matrix_range_, draw_value_) {}
CE explicit PointGridAndSomeBlocksWithBorder(CS dtl::base::MatrixRange& matrix_range_, CS MI& draw_value_, CS MI& draw_value2_, CS MI& draw_value3_, CS double probability_) NE
:randomRect(matrix_range_, draw_value3_, probability_), borderOdd(matrix_range_, draw_value2_), pointGrid(matrix_range_, draw_value_) {}
};
}
}
#endif 
#ifndef IDTL_DTL_SHAPE_POINT_GRID_WITH_BORDER
#define IDTL_DTL_SHAPE_POINT_GRID_WITH_BORDER
NS dtl {
inline NS shape {
TP<TN MI>
class PointGridWithBorder {
private:
using IS = dtl::type::size;
dtl::shape::BorderOdd<MI> borderOdd{};
dtl::shape::PointGrid<MI> pointGrid{};
public:
DVCN
CE IS getPointX() CS NE {
RT this->borderOdd.getPointX();
}
DVCN
CE IS getPointY() CS NE {
RT this->borderOdd.getPointY();
}
DVCN
CE IS getWidth() CS NE {
RT this->borderOdd.getWidth();
}
DVCN
CE IS getHeight() CS NE {
RT this->borderOdd.getHeight();
}
DVCN
CE MI getValue() CS NE {
RT this->borderOdd.getValue();
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL draw(Matrix_&& matrix_, Args_&& ... args_) CS NE {
this->pointGrid.draw(matrix_, args_...);
this->borderOdd.draw(DTL_TYPE_FORWARD<Matrix_>(matrix_), DTL_TYPE_FORWARD<Args_>(args_)...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawOperator(Matrix_&& matrix_, Args_&& ... args_) CS NE {
this->pointGrid.drawOperator(matrix_, args_...);
this->borderOdd.drawOperator(DTL_TYPE_FORWARD<Matrix_>(matrix_), DTL_TYPE_FORWARD<Args_>(args_)...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawArray(Matrix_&& matrix_, Args_&& ... args_) CS NE {
this->pointGrid.drawArray(matrix_, args_...);
this->borderOdd.drawArray(DTL_TYPE_FORWARD<Matrix_>(matrix_), DTL_TYPE_FORWARD<Args_>(args_)...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawOperatorArray(Matrix_&& matrix_, Args_&& ... args_) CS NE {
this->pointGrid.drawOperatorArray(matrix_, args_...);
this->borderOdd.drawOperatorArray(DTL_TYPE_FORWARD<Matrix_>(matrix_), DTL_TYPE_FORWARD<Args_>(args_)...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
CE BL operator()(Matrix_&& matrix_, Args_&& ... args_) CS NE {
RT this->draw(DTL_TYPE_FORWARD<Matrix_>(matrix_), DTL_TYPE_FORWARD<Args_>(args_)...);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& create(Matrix_&& matrix_, Args_&& ... args_) CS NE {
this->draw(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createArray(Matrix_&& matrix_, Args_&& ... args_) CS NE {
this->drawArray(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createOperator(Matrix_&& matrix_, Args_&& ... args_) CS NE {
this->drawOperator(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createOperatorArray(Matrix_&& matrix_, Args_&& ... args_) CS NE {
this->drawOperatorArray(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
DVCC
PointGridWithBorder& clearPointX() NE {
this->borderOdd.clearPointX();
this->pointGrid.clearPointX();
RT *this;
}
DVCC
PointGridWithBorder& clearPointY() NE {
this->borderOdd.clearPointY();
this->pointGrid.clearPointY();
RT *this;
}
DVCC
PointGridWithBorder& clearWidth() NE {
this->borderOdd.clearWidth();
this->pointGrid.clearWidth();
RT *this;
}
DVCC
PointGridWithBorder& clearHeight() NE {
this->borderOdd.clearHeight();
this->pointGrid.clearHeight();
RT *this;
}
DVCC
PointGridWithBorder& clearValue() NE {
this->borderOdd.clearValue();
this->pointGrid.clearValue();
RT *this;
}
DVCC
PointGridWithBorder& clearPoint() NE {
this->clearPointX();
this->clearPointY();
RT *this;
}
DVCC
PointGridWithBorder& clearRange() NE {
this->clearPointX();
this->clearPointY();
this->clearWidth();
this->clearHeight();
RT *this;
}
DVCC
PointGridWithBorder& clear() NE {
this->clearRange();
this->clearValue();
RT *this;
}
DVCC
PointGridWithBorder& setPointX(CS IS end_x_) NE {
this->borderOdd.setPointX(end_x_);
this->pointGrid.setPointX(end_x_);
RT *this;
}
DVCC
PointGridWithBorder& setPointY(CS IS end_y_) NE {
this->borderOdd.setPointY(end_y_);
this->pointGrid.setPointY(end_y_);
RT *this;
}
DVCC
PointGridWithBorder& setWidth(CS IS width_) NE {
this->borderOdd.setWidth(width_);
this->pointGrid.setWidth(width_);
RT *this;
}
DVCC
PointGridWithBorder& setHeight(CS IS height_) NE {
this->borderOdd.setHeight(height_);
this->pointGrid.setHeight(height_);
RT *this;
}
DVCC
PointGridWithBorder& setValue(CS MI& draw_value_) NE {
this->borderOdd.setValue(draw_value_);
this->pointGrid.setValue(draw_value_);
RT *this;
}
DVCC
PointGridWithBorder& setRange(CS dtl::base::MatrixRange& matrix_range_) NE {
this->borderOdd.setRange(matrix_range_);
this->pointGrid.setRange(matrix_range_);
RT *this;
}
DVCC
PointGridWithBorder& setPoint(CS IS point_) NE {
this->setPointX(point_);
this->setPointY(point_);
RT *this;
}
DVCC
PointGridWithBorder& setPoint(CS IS end_x_, CS IS end_y_) NE {
this->setPointX(end_x_);
this->setPointY(end_y_);
RT *this;
}
DVCC
PointGridWithBorder& setRange(CS IS end_x_, CS IS end_y_, CS IS length_) NE {
this->setPointX(end_x_);
this->setPointY(end_y_);
this->setWidth(length_);
this->setHeight(length_);
RT *this;
}
DVCC
PointGridWithBorder& setRange(CS IS end_x_, CS IS end_y_, CS IS width_, CS IS height_) NE {
this->setPointX(end_x_);
this->setPointY(end_y_);
this->setWidth(width_);
this->setHeight(height_);
RT *this;
}
CE PointGridWithBorder() NE = default;
CE explicit PointGridWithBorder(CS MI& draw_value_) NE
:borderOdd(draw_value_), pointGrid(draw_value_) {}
CE explicit PointGridWithBorder(CS MI& draw_value_, CS MI& draw_value2_) NE
:borderOdd(draw_value2_), pointGrid(draw_value_) {}
CE explicit PointGridWithBorder(CS IS end_x_, CS IS end_y_, CS IS width_, CS IS height_) NE
:borderOdd(end_x_, end_y_, width_, height_), pointGrid(end_x_, end_y_, width_, height_) {}
CE explicit PointGridWithBorder(CS IS end_x_, CS IS end_y_, CS IS width_, CS IS height_, CS MI& draw_value_) NE
:borderOdd(end_x_, end_y_, width_, height_, draw_value_), pointGrid(end_x_, end_y_, width_, height_, draw_value_) {}
CE explicit PointGridWithBorder(CS dtl::base::MatrixRange& matrix_range_) NE
:borderOdd(matrix_range_), pointGrid(matrix_range_) {}
CE explicit PointGridWithBorder(CS dtl::base::MatrixRange& matrix_range_, CS MI& draw_value_) NE
:borderOdd(matrix_range_, draw_value_), pointGrid(matrix_range_, draw_value_) {}
CE explicit PointGridWithBorder(CS dtl::base::MatrixRange& matrix_range_, CS MI& draw_value_, CS MI& draw_value2_) NE
:borderOdd(matrix_range_, draw_value2_), pointGrid(matrix_range_, draw_value_) {}
};
}
}
#endif 
#ifndef IDTL_DTL_SHAPE_RANDOM_VORONOI
#define IDTL_DTL_SHAPE_RANDOM_VORONOI
#ifndef IDTL_DTL_UTILITY_VORONOI_DIAGRAM
#define IDTL_DTL_UTILITY_VORONOI_DIAGRAM
#ifndef IDTL_DTL_TYPE_NUMERIC_LIMITS
#define IDTL_DTL_TYPE_NUMERIC_LIMITS
#ifndef DTL_TYPE_NUMERIC_LIMITS
#if defined(UE_BUILD_FINAL_RELEASE) 
#define DTL_TYPE_NUMERIC_LIMITS ::TNumericLimits
#else
#include <limits>
#define DTL_TYPE_NUMERIC_LIMITS std::numeric_limits
#endif
#endif
#ifndef DTL_TYPE_NUMERIC_LIMITS_MIN
#if defined(UE_BUILD_FINAL_RELEASE) 
#define DTL_TYPE_NUMERIC_LIMITS_MIN Min
#else
#define DTL_TYPE_NUMERIC_LIMITS_MIN min
#endif
#endif
#ifndef DTL_TYPE_NUMERIC_LIMITS_MAX
#if defined(UE_BUILD_FINAL_RELEASE) 
#define DTL_TYPE_NUMERIC_LIMITS_MAX Max
#else
#define DTL_TYPE_NUMERIC_LIMITS_MAX max
#endif
#endif
#endif 
NS dtl {
inline NS utility {
TP<TN MI, TN UniquePair_ = DTL_TYPE_UNIQUE_PTR<std::pair<dtl::type::ssize, dtl::type::ssize>[]>, TN UniqueInt_ = DTL_TYPE_UNIQUE_PTR<MI[]>>
class VoronoiDiagram {
private:
using IS = dtl::type::size;
IS start_x{};
IS start_y{};
IS width{};
IS height{};
dtl::type::size draw_value{};
using Point_Pair_ = std::pair<dtl::type::ssize, dtl::type::ssize>;
TP<TN Function_>
DVCC
void createPoint(UniquePair_& point_, UniqueInt_& color_, CS dtl::type::ssize w_, CS dtl::type::ssize h_, Function_&& function_) CS NE {
for (dtl::type::size i{}, array_num{}; i < this->draw_value; ++i, ++array_num) {
point_[array_num] = Point_Pair_(dtl::random::mt32bit.get<dtl::type::ssize>(w_), dtl::random::mt32bit.get<dtl::type::ssize>(h_));
function_(point_[array_num], color_[array_num], static_cast<dtl::type::ssize>(start_x), static_cast<dtl::type::ssize>(start_x), w_, h_);
}
}
DVCC
dtl::type::ssize distanceSqrd(CS Point_Pair_& point_, dtl::type::ssize x_, dtl::type::ssize y_) CS NE {
x_ -= point_.first;
y_ -= point_.second;
RT x_ * x_ + y_ * y_;
}
DVCC
BL createSitesDistance(CS UniquePair_& point_, dtl::type::size& ind, dtl::type::ssize& dist, dtl::type::ssize& ds, CS dtl::type::ssize ww, CS dtl::type::ssize hh) CS NE {
ind = (DTL_TYPE_NUMERIC_LIMITS<dtl::type::size>::DTL_TYPE_NUMERIC_LIMITS_MAX)();
dist = (DTL_TYPE_NUMERIC_LIMITS<dtl::type::ssize>::DTL_TYPE_NUMERIC_LIMITS_MAX)();
for (dtl::type::size it{}; it < this->draw_value; ++it) {
if ((ds = this->distanceSqrd(point_[it], ww, hh)) >= dist) continue;
dist = ds;
ind = it;
}
RT (ind != (DTL_TYPE_NUMERIC_LIMITS<dtl::type::size>::DTL_TYPE_NUMERIC_LIMITS_MAX)());
}
TP<TN Matrix_>
DVCC
void createSites(CS UniquePair_& point_, CS UniqueInt_& color_, Matrix_& matrix_, CS dtl::type::size w_, CS dtl::type::size h_) CS NE {
dtl::type::ssize ds{}, dist{};
for (dtl::type::size hh{}, ind{}; hh < h_; ++hh)
for (dtl::type::size ww{}; ww < w_; ++ww)
if (createSitesDistance(point_, ind, dist, ds, static_cast<dtl::type::ssize>(ww), static_cast<dtl::type::ssize>(hh)))
matrix_[hh][ww] = color_[ind];
}
TP<TN Matrix_>
DVCC
void createSitesLayer(CS UniquePair_& point_, CS UniqueInt_& color_, Matrix_& matrix_, CS IS layer_, CS dtl::type::size w_, CS dtl::type::size h_) CS NE {
dtl::type::ssize ds{}, dist{};
for (dtl::type::size hh{}, ind{}; hh < h_; ++hh)
for (dtl::type::size ww{}; ww < w_; ++ww)
if (createSitesDistance(point_, ind, dist, ds, static_cast<dtl::type::ssize>(ww), static_cast<dtl::type::ssize>(hh)))
matrix_[hh][ww][layer_] = color_[ind];
}
TP<TN Matrix_>
DVCC
void createSitesArray(CS UniquePair_& point_, CS UniqueInt_& color_, Matrix_& matrix_, CS IS max_x_, CS dtl::type::size w_, CS dtl::type::size h_) CS NE {
dtl::type::ssize ds{}, dist{};
for (dtl::type::size hh{}, ind{}; hh < h_; ++hh)
for (dtl::type::size ww{}; ww < w_; ++ww)
if (createSitesDistance(point_, ind, dist, ds, static_cast<dtl::type::ssize>(ww), static_cast<dtl::type::ssize>(hh)))
matrix_[hh * max_x_ + ww] = color_[ind];
}
TP<TN Matrix_, TN Function_>
inline void substitutionSTL(Matrix_&& matrix_, CS IS end_x_, CS IS end_y_, Function_&& function_) CS NE {
UniquePair_ point{ DTL_TYPE_NEW Point_Pair_[this->draw_value] };
if (!point) RT;
UniqueInt_ color{ DTL_TYPE_NEW MI[this->draw_value] };
if (!color) RT;
createPoint(point, color, static_cast<dtl::type::ssize>(end_x_), static_cast<dtl::type::ssize>(end_y_), function_);
createSites(point, color, matrix_, end_x_, end_y_);
}
TP<TN Matrix_, TN Function_>
inline void substitutionArray(Matrix_&& matrix_, CS IS end_x_, CS IS end_y_, CS IS max_x_, Function_&& function_) CS NE {
UniquePair_ point{ DTL_TYPE_NEW Point_Pair_[this->draw_value] };
if (!point) RT;
UniqueInt_ color{ DTL_TYPE_NEW MI[this->draw_value] };
if (!color) RT;
createPoint(point, color, static_cast<dtl::type::ssize>(end_x_), static_cast<dtl::type::ssize>(end_y_), function_);
createSitesArray(point, color, matrix_, max_x_, end_x_, end_y_);
}
TP<TN Matrix_, TN Function_>
inline void substitutionLayer(Matrix_ && matrix_, CS IS layer_, CS IS end_x_, CS IS end_y_, Function_ && function_) CS NE {
UniquePair_ point{ DTL_TYPE_NEW Point_Pair_[this->draw_value] };
if (!point) RT;
UniqueInt_ color{ DTL_TYPE_NEW MI[this->draw_value] };
if (!color) RT;
createPoint(point, color, static_cast<dtl::type::ssize>(end_x_), static_cast<dtl::type::ssize>(end_y_), function_);
createSitesLayer(point, color, matrix_, layer_, end_x_, end_y_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawNormal(Matrix_&& matrix_, CS IS end_x_, CS IS end_y_, Args_&& ... args_) CS NE {
this->substitutionSTL(matrix_, end_x_, end_y_, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawLayerNormal(Matrix_&& matrix_, CS IS layer_, CS IS end_x_, CS IS end_y_, Args_&& ... args_) CS NE {
this->substitutionLayer(matrix_, layer_, end_x_, end_y_, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawArray(Matrix_&& matrix_, CS IS end_x_, CS IS end_y_, CS IS max_x_, Args_&& ... args_) CS NE {
this->substitutionArray(matrix_, end_x_, end_y_, max_x_, args_...);
RT true;
}
public:
DVCN
CE IS getPointX() CS NE {
RT this->start_x;
}
DVCN
CE IS getPointY() CS NE {
RT this->start_y;
}
DVCN
CE IS getWidth() CS NE {
RT this->width;
}
DVCN
CE IS getHeight() CS NE {
RT this->height;
}
DVCN
CE dtl::type::size getValue() CS NE {
RT this->draw_value;
}
TP<TN Matrix_, TN Function_>
CE BL draw(Matrix_ && matrix_, Function_ && function_) CS NE {
RT this->drawNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= ((matrix_.size() == 0) ? 0 : matrix_[0].size())) ? ((matrix_.size() == 0) ? 0 : matrix_[0].size()) : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_);
}
TP<TN Matrix_, TN Function_>
CE BL draw(Matrix_ && matrix_, CS IS layer_, Function_ && function_) CS NE {
RT this->drawLayerNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->width == 0 || this->start_x + this->width >= ((matrix_.size() == 0) ? 0 : matrix_[0].size())) ? ((matrix_.size() == 0) ? 0 : matrix_[0].size()) : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_);
}
TP<TN Matrix_, TN Function_>
CE BL draw(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_, Function_ && function_) CS NE {
RT this->drawNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, function_);
}
TP<TN Matrix_, TN Function_>
CE BL draw(Matrix_ && matrix_, CS IS layer_, CS IS max_x_, CS IS max_y_, Function_ && function_) CS NE {
RT this->drawLayerNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, function_);
}
TP<TN Matrix_, TN Function_>
CE BL drawArray(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_, Function_ && function_) CS NE {
RT this->drawArray(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, max_x_, function_);
}
TP<TN Matrix_, TN ...Args_>
CE BL operator()(Matrix_ && matrix_, Args_ && ... args_) CS NE {
RT this->draw(DTL_TYPE_FORWARD<Matrix_>(matrix_), DTL_TYPE_FORWARD<Args_>(args_)...);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& create(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->draw(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createArray(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->drawArray(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
DVCC
VoronoiDiagram& clearPointX() NE {
this->start_x = 0;
RT *this;
}
DVCC
VoronoiDiagram& clearPointY() NE {
this->start_y = 0;
RT *this;
}
DVCC
VoronoiDiagram& clearWidth() NE {
this->width = 0;
RT *this;
}
DVCC
VoronoiDiagram& clearHeight() NE {
this->height = 0;
RT *this;
}
DVCC
VoronoiDiagram& clearValue() NE {
this->draw_value = 0;
RT *this;
}
DVCC
VoronoiDiagram& clearPoint() NE {
this->clearPointX();
this->clearPointY();
RT *this;
}
DVCC
VoronoiDiagram& clearRange() NE {
this->clearPointX();
this->clearPointY();
this->clearWidth();
this->clearHeight();
RT *this;
}
DVCC
VoronoiDiagram& clear() NE {
this->clearRange();
this->clearValue();
RT *this;
}
DVCC
VoronoiDiagram& setPointX(CS IS start_x_) NE {
this->start_x = start_x_;
RT *this;
}
DVCC
VoronoiDiagram& setPointY(CS IS start_y_) NE {
this->start_y = start_y_;
RT *this;
}
DVCC
VoronoiDiagram& setWidth(CS IS width_) NE {
this->width = width_;
RT *this;
}
DVCC
VoronoiDiagram& setHeight(CS IS height_) NE {
this->height = height_;
RT *this;
}
DVCC
VoronoiDiagram& setValue(CS dtl::type::size draw_value_) NE {
this->draw_value = draw_value_;
RT *this;
}
DVCC
VoronoiDiagram& setPoint(CS IS point_) NE {
this->start_x = point_;
this->start_y = point_;
RT *this;
}
DVCC
VoronoiDiagram& setPoint(CS IS start_x_, CS IS start_y_) NE {
this->start_x = start_x_;
this->start_y = start_y_;
RT *this;
}
DVCC
VoronoiDiagram& setRange(CS IS start_x_, CS IS start_y_, CS IS length_) NE {
this->start_x = start_x_;
this->start_y = start_y_;
this->width = length_;
this->height = length_;
RT *this;
}
DVCC
VoronoiDiagram& setRange(CS IS start_x_, CS IS start_y_, CS IS width_, CS IS height_) NE {
this->start_x = start_x_;
this->start_y = start_y_;
this->width = width_;
this->height = height_;
RT *this;
}
DVCC
VoronoiDiagram& setRange(CS dtl::base::MatrixRange& matrix_range_) NE {
this->start_x = matrix_range_.x;
this->start_y = matrix_range_.y;
this->width = matrix_range_.w;
this->height = matrix_range_.h;
RT *this;
}
CE VoronoiDiagram() NE = default;
CE explicit VoronoiDiagram(CS dtl::type::size draw_value_) NE
:draw_value(draw_value_) {}
CE explicit VoronoiDiagram(CS dtl::base::MatrixRange& matrix_range_) NE
:start_x(matrix_range_.x), start_y(matrix_range_.y),
width(matrix_range_.w), height(matrix_range_.h) {}
CE explicit VoronoiDiagram(CS dtl::base::MatrixRange& matrix_range_, CS dtl::type::size draw_value_) NE
:start_x(matrix_range_.x), start_y(matrix_range_.y),
width(matrix_range_.w), height(matrix_range_.h),
draw_value(draw_value_) {}
CE explicit VoronoiDiagram(CS IS start_x_, CS IS start_y_, CS IS width_, CS IS height_) NE
:start_x(start_x_), start_y(start_y_),
width(width_), height(height_) {}
CE explicit VoronoiDiagram(CS IS start_x_, CS IS start_y_, CS IS width_, CS IS height_, CS dtl::type::size draw_value_) NE
:start_x(start_x_), start_y(start_y_),
width(width_), height(height_),
draw_value(draw_value_) {}
};
}
}
#endif 
NS dtl {
inline NS shape {
TP<TN MI, TN UniquePair_ = DTL_TYPE_UNIQUE_PTR<std::pair<dtl::type::ssize, dtl::type::ssize>[]>, TN UniqueInt_ = DTL_TYPE_UNIQUE_PTR<MI[]>>
class RandomVoronoi {
private:
using IS = dtl::type::size;
dtl::utility::VoronoiDiagram<MI, UniquePair_, UniqueInt_> voronoiDiagram{};
double probability_value{ 0.5 };
MI true_color{};
MI false_color{};
public:
DVCN
CE IS getPointX() CS NE {
RT this->voronoiDiagram.getPointX();
}
DVCN
CE IS getPointY() CS NE {
RT this->voronoiDiagram.getPointY();
}
DVCN
CE IS getWidth() CS NE {
RT this->voronoiDiagram.getWidth();
}
DVCN
CE IS getHeight() CS NE {
RT this->voronoiDiagram.getHeight();
}
DVCN
CE dtl::type::size getValue() CS NE {
RT this->voronoiDiagram.getValue();
}
TP<TN Matrix_>
CE BL draw(Matrix_&& matrix_) CS NE {
RT this->voronoiDiagram.draw(matrix_,
[this](CS std::pair<dtl::type::ssize, dtl::type::ssize>&, MI & color_, CS dtl::type::ssize, CS dtl::type::ssize, CS dtl::type::ssize, CS dtl::type::ssize) {
if (dtl::random::mt32bit.probability(this->probability_value)) color_ = this->true_color;
else color_ = this->false_color;
});
}
TP<TN Matrix_>
CE BL draw(Matrix_&& matrix_, CS IS layer_) CS NE {
RT this->voronoiDiagram.draw(matrix_, layer_,
[this](CS std::pair<dtl::type::ssize, dtl::type::ssize>&, MI & color_, CS dtl::type::ssize, CS dtl::type::ssize, CS dtl::type::ssize, CS dtl::type::ssize) {
if (dtl::random::mt32bit.probability(this->probability_value)) color_ = this->true_color;
else color_ = this->false_color;
});
}
TP<TN Matrix_>
CE BL draw(Matrix_&& matrix_, CS IS max_x_, CS IS max_y_) CS NE {
RT this->voronoiDiagram.draw(matrix_, max_x_, max_y_,
[this](CS std::pair<dtl::type::ssize, dtl::type::ssize>&, MI & color_, CS dtl::type::ssize, CS dtl::type::ssize, CS dtl::type::ssize, CS dtl::type::ssize) {
if (dtl::random::mt32bit.probability(this->probability_value)) color_ = this->true_color;
else color_ = this->false_color;
});
}
TP<TN Matrix_>
CE BL draw(Matrix_&& matrix_, CS IS layer_, CS IS max_x_, CS IS max_y_) CS NE {
RT this->voronoiDiagram.draw(matrix_, layer_, max_x_, max_y_,
[this](CS std::pair<dtl::type::ssize, dtl::type::ssize>&, MI & color_, CS dtl::type::ssize, CS dtl::type::ssize, CS dtl::type::ssize, CS dtl::type::ssize) {
if (dtl::random::mt32bit.probability(this->probability_value)) color_ = this->true_color;
else color_ = this->false_color;
});
}
TP<TN Matrix_>
CE BL drawArray(Matrix_&& matrix_, CS IS max_x_, CS IS max_y_) CS NE {
RT this->voronoiDiagram.drawArray(matrix_, max_x_, max_y_,
[this](CS std::pair<dtl::type::ssize, dtl::type::ssize>&, MI & color_, CS dtl::type::ssize, CS dtl::type::ssize, CS dtl::type::ssize, CS dtl::type::ssize) {
if (dtl::random::mt32bit.probability(this->probability_value)) color_ = this->true_color;
else color_ = this->false_color;
});
}
TP<TN Matrix_, TN ...Args_>
CE BL operator()(Matrix_&& matrix_, Args_&& ... args_) CS NE {
RT this->draw(DTL_TYPE_FORWARD<Matrix_>(matrix_), DTL_TYPE_FORWARD<Args_>(args_)...);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& create(Matrix_&& matrix_, Args_&& ... args_) CS NE {
this->draw(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createArray(Matrix_&& matrix_, Args_&& ... args_) CS NE {
this->drawArray(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createOperator(Matrix_&& matrix_, Args_&& ... args_) CS NE {
this->drawOperator(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createOperatorArray(Matrix_&& matrix_, Args_&& ... args_) CS NE {
this->drawOperatorArray(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
DVCC
RandomVoronoi& clearPointX() NE {
this->voronoiDiagram.clearPointX();
RT *this;
}
DVCC
RandomVoronoi& clearPointY() NE {
this->voronoiDiagram.clearPointY();
RT *this;
}
DVCC
RandomVoronoi& clearWidth() NE {
this->voronoiDiagram.clearWidth();
RT *this;
}
DVCC
RandomVoronoi& clearHeight() NE {
this->voronoiDiagram.clearHeight();
RT *this;
}
DVCC
RandomVoronoi& clearValue() NE {
this->voronoiDiagram.clearValue();
RT *this;
}
DVCC
RandomVoronoi& clearPoint() NE {
this->clearPointX();
this->clearPointY();
RT *this;
}
DVCC
RandomVoronoi& clearRange() NE {
this->clearPointX();
this->clearPointY();
this->clearWidth();
this->clearHeight();
RT *this;
}
DVCC
RandomVoronoi& clear() NE {
this->clearRange();
this->clearValue();
RT *this;
}
DVCC
RandomVoronoi& setPointX(CS IS end_x_) NE {
this->voronoiDiagram.setPointX(end_x_);
RT *this;
}
DVCC
RandomVoronoi& setPointY(CS IS end_y_) NE {
this->voronoiDiagram.setPointY(end_y_);
RT *this;
}
DVCC
RandomVoronoi& setWidth(CS IS width_) NE {
this->voronoiDiagram.setWidth(width_);
RT *this;
}
DVCC
RandomVoronoi& setHeight(CS IS height_) NE {
this->voronoiDiagram.setHeight(height_);
RT *this;
}
DVCC
RandomVoronoi& setValue(CS dtl::type::size draw_value_) NE {
this->voronoiDiagram.setValue(draw_value_);
RT *this;
}
DVCC
RandomVoronoi& setRange(CS dtl::base::MatrixRange& matrix_range_) NE {
this->voronoiDiagram.setRange(matrix_range_);
RT *this;
}
DVCC
RandomVoronoi& setPoint(CS IS point_) NE {
this->setPointX(point_);
this->setPointY(point_);
RT *this;
}
DVCC
RandomVoronoi& setPoint(CS IS end_x_, CS IS end_y_) NE {
this->setPointX(end_x_);
this->setPointY(end_y_);
RT *this;
}
DVCC
RandomVoronoi& setRange(CS IS end_x_, CS IS end_y_, CS IS length_) NE {
this->setPointX(end_x_);
this->setPointY(end_y_);
this->setWidth(length_);
this->setHeight(length_);
RT *this;
}
DVCC
RandomVoronoi& setRange(CS IS end_x_, CS IS end_y_, CS IS width_, CS IS height_) NE {
this->setPointX(end_x_);
this->setPointY(end_y_);
this->setWidth(width_);
this->setHeight(height_);
RT *this;
}
CE RandomVoronoi() NE = default;
CE explicit RandomVoronoi(CS dtl::type::size draw_value_) NE
:voronoiDiagram(draw_value_) {}
CE explicit RandomVoronoi(CS dtl::type::size draw_value_, CS double probability_value_) NE
:voronoiDiagram(draw_value_), probability_value(probability_value_) {}
CE explicit RandomVoronoi(CS dtl::type::size draw_value_, CS double probability_value_, CS MI& true_color_) NE
:voronoiDiagram(draw_value_), probability_value(probability_value_), true_color(true_color_) {}
CE explicit RandomVoronoi(CS dtl::type::size draw_value_, CS double probability_value_, CS MI& true_color_, CS MI& false_color_) NE
:voronoiDiagram(draw_value_), probability_value(probability_value_), true_color(true_color_), false_color(false_color_) {}
CE explicit RandomVoronoi(CS dtl::base::MatrixRange& matrix_range_) NE
:voronoiDiagram(matrix_range_) {}
CE explicit RandomVoronoi(CS dtl::base::MatrixRange& matrix_range_, CS dtl::type::size draw_value_) NE
:voronoiDiagram(matrix_range_, draw_value_) {}
CE explicit RandomVoronoi(CS dtl::base::MatrixRange& matrix_range_, CS dtl::type::size draw_value_, CS double probability_value_) NE
:voronoiDiagram(matrix_range_, draw_value_), probability_value(probability_value_) {}
CE explicit RandomVoronoi(CS dtl::base::MatrixRange& matrix_range_, CS dtl::type::size draw_value_, CS double probability_value_, CS MI& true_color_) NE
:voronoiDiagram(matrix_range_, draw_value_), probability_value(probability_value_), true_color(true_color_) {}
CE explicit RandomVoronoi(CS dtl::base::MatrixRange& matrix_range_, CS dtl::type::size draw_value_, CS double probability_value_, CS MI& true_color_, CS MI& false_color_) NE
:voronoiDiagram(matrix_range_, draw_value_), probability_value(probability_value_), true_color(true_color_), false_color(false_color_) {}
};
}
}
#endif 
#ifndef IDTL_DTL_SHAPE_RECT
#define IDTL_DTL_SHAPE_RECT
NS dtl {
inline NS shape {
TP<TN MI>
class Rect {
private:
using IS = dtl::type::size;
IS start_x{};
IS start_y{};
IS width{};
IS height{};
MI draw_value{};
TP<TN Matrix_>
DVCC
inline void substitutionSTL(Matrix_&& matrix_, CS IS end_x_, CS IS end_y_) CS NE {
matrix_[end_y_][end_x_] = this->draw_value;
}
TP<TN Matrix_>
DVCC
inline void substitutionArray(Matrix_&& matrix_, CS IS end_x_, CS IS end_y_, CS IS max_x_) CS NE {
matrix_[end_y_ * max_x_ + end_x_] = this->draw_value;
}
TP<TN Matrix_>
DVCC
inline void substitutionLayer(Matrix_&& matrix_, CS IS layer_, CS IS end_x_, CS IS end_y_) CS NE {
matrix_[end_y_][end_x_][layer_] = this->draw_value;
}
TP<TN Matrix_, TN Function_>
DVCC
inline void substitutionSTL(Matrix_&& matrix_, CS IS end_x_, CS IS end_y_, Function_&& function_) CS NE {
if (function_(matrix_[end_y_][end_x_])) matrix_[end_y_][end_x_] = this->draw_value;
}
TP<TN Matrix_, TN Function_>
DVCC
inline void substitutionArray(Matrix_&& matrix_, CS IS end_x_, CS IS end_y_, CS IS max_x_, Function_&& function_) CS NE {
if (function_(matrix_[end_y_ * max_x_ + end_x_])) matrix_[end_y_ * max_x_ + end_x_] = this->draw_value;
}
TP<TN Matrix_, TN Function_>
DVCC
inline void substitutionLayer(Matrix_ && matrix_, CS IS layer_, CS IS end_x_, CS IS end_y_, Function_ && function_) CS NE {
if (function_(matrix_[end_y_][end_x_][layer_])) matrix_[end_y_][end_x_][layer_] = this->draw_value;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawSTL(Matrix_ && matrix_, CS IS end_y_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i)
for (IS j{ this->start_x }; j < matrix_[i].size(); ++j)
this->substitutionSTL(matrix_, j, i, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawWidthSTL(Matrix_ && matrix_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i)
for (IS j{ this->start_x }; j < matrix_[i].size() && j < end_x_; ++j)
this->substitutionSTL(matrix_, j, i, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawLayerSTL(Matrix_ && matrix_, CS IS layer_, CS IS end_y_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i)
for (IS j{ this->start_x }; j < matrix_[i].size(); ++j)
this->substitutionLayer(matrix_, layer_, j, i, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawLayerWidthSTL(Matrix_ && matrix_, CS IS layer_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i)
for (IS j{ this->start_x }; j < matrix_[i].size() && j < end_x_; ++j)
this->substitutionLayer(matrix_, layer_, j, i, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawNormal(Matrix_ && matrix_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i)
for (IS j{ this->start_x }; j < end_x_; ++j)
this->substitutionSTL(matrix_, j, i, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawLayerNormal(Matrix_ && matrix_, CS IS layer_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i)
for (IS j{ this->start_x }; j < end_x_; ++j)
this->substitutionLayer(matrix_, layer_, j, i, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawArray(Matrix_ && matrix_, CS IS end_x_, CS IS end_y_, CS IS max_x_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i)
for (IS j{ this->start_x }; j < end_x_; ++j)
this->substitutionArray(matrix_, j, i, max_x_, args_...);
RT true;
}
public:
DVCN
CE IS getPointX() CS NE {
RT this->start_x;
}
DVCN
CE IS getPointY() CS NE {
RT this->start_y;
}
DVCN
CE IS getWidth() CS NE {
RT this->width;
}
DVCN
CE IS getHeight() CS NE {
RT this->height;
}
DVCN
CE MI getValue() CS NE {
RT this->draw_value;
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_) CS NE {
RT (this->width == 0) ? this->drawSTL(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height) : this->drawWidthSTL(matrix_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, Function_ && function_) CS NE {
RT (this->width == 0) ? this->drawSTL(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_) : this->drawWidthSTL(matrix_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_, CS IS layer_) CS NE {
RT (this->width == 0) ? this->drawLayerSTL(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height) : this->drawLayerWidthSTL(matrix_, layer_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, CS IS layer_, Function_ && function_) CS NE {
RT (this->width == 0) ? this->drawLayerSTL(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_) : this->drawLayerWidthSTL(matrix_, layer_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_) CS NE {
RT this->drawNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_, Function_ && function_) CS NE {
RT this->drawNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_, CS IS layer_, CS IS max_x_, CS IS max_y_) CS NE {
RT this->drawLayerNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, CS IS layer_, CS IS max_x_, CS IS max_y_, Function_ && function_) CS NE {
RT this->drawLayerNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL drawArray(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_) CS NE {
RT this->drawArray(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, max_x_);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperatorArray(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_, Function_ && function_) CS NE {
RT this->drawArray(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, max_x_, function_);
}
TP<TN Matrix_, TN ...Args_>
CE BL operator()(Matrix_ && matrix_, Args_ && ... args_) CS NE {
RT this->draw(DTL_TYPE_FORWARD<Matrix_>(matrix_), DTL_TYPE_FORWARD<Args_>(args_)...);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& create(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->draw(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createArray(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->drawArray(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createOperator(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->drawOperator(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createOperatorArray(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->drawOperatorArray(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
DVCC
Rect& clearPointX() NE {
this->start_x = 0;
RT *this;
}
DVCC
Rect& clearPointY() NE {
this->start_y = 0;
RT *this;
}
DVCC
Rect& clearWidth() NE {
this->width = 0;
RT *this;
}
DVCC
Rect& clearHeight() NE {
this->height = 0;
RT *this;
}
DVCC
Rect& clearValue() NE {
CS MI new_draw_value{};
this->draw_value = new_draw_value;
RT *this;
}
DVCC
Rect& clearPoint() NE {
this->clearPointX();
this->clearPointY();
RT *this;
}
DVCC
Rect& clearRange() NE {
this->clearPointX();
this->clearPointY();
this->clearWidth();
this->clearHeight();
RT *this;
}
DVCC
Rect& clear() NE {
this->clearRange();
this->clearValue();
RT *this;
}
DVCC
Rect& setPointX(CS IS end_x_) NE {
this->start_x = end_x_;
RT *this;
}
DVCC
Rect& setPointY(CS IS end_y_) NE {
this->start_y = end_y_;
RT *this;
}
DVCC
Rect& setWidth(CS IS width_) NE {
this->width = width_;
RT *this;
}
DVCC
Rect& setHeight(CS IS height_) NE {
this->height = height_;
RT *this;
}
DVCC
Rect& setValue(CS MI & draw_value_) NE {
this->draw_value = draw_value_;
RT *this;
}
DVCC
Rect& setPoint(CS IS point_) NE {
this->start_x = point_;
this->start_y = point_;
RT *this;
}
DVCC
Rect& setPoint(CS IS end_x_, CS IS end_y_) NE {
this->start_x = end_x_;
this->start_y = end_y_;
RT *this;
}
DVCC
Rect& setRange(CS IS end_x_, CS IS end_y_, CS IS length_) NE {
this->start_x = end_x_;
this->start_y = end_y_;
this->width = length_;
this->height = length_;
RT *this;
}
DVCC
Rect& setRange(CS IS end_x_, CS IS end_y_, CS IS width_, CS IS height_) NE {
this->start_x = end_x_;
this->start_y = end_y_;
this->width = width_;
this->height = height_;
RT *this;
}
DVCC
Rect& setRange(CS dtl::base::MatrixRange & matrix_range_) NE {
this->start_x = matrix_range_.x;
this->start_y = matrix_range_.y;
this->width = matrix_range_.w;
this->height = matrix_range_.h;
RT *this;
}
CE Rect() NE = default;
CE explicit Rect(CS MI & draw_value_) NE
:draw_value(draw_value_) {}
CE explicit Rect(CS dtl::base::MatrixRange & matrix_range_) NE
:start_x(matrix_range_.x), start_y(matrix_range_.y),
width(matrix_range_.w), height(matrix_range_.h) {}
CE explicit Rect(CS dtl::base::MatrixRange & matrix_range_, CS MI & draw_value_) NE
:start_x(matrix_range_.x), start_y(matrix_range_.y),
width(matrix_range_.w), height(matrix_range_.h),
draw_value(draw_value_) {}
CE explicit Rect(CS IS end_x_, CS IS end_y_, CS IS width_, CS IS height_) NE
:start_x(end_x_), start_y(end_y_),
width(width_), height(height_) {}
CE explicit Rect(CS IS end_x_, CS IS end_y_, CS IS width_, CS IS height_, CS MI & draw_value_) NE
:start_x(end_x_), start_y(end_y_),
width(width_), height(height_),
draw_value(draw_value_) {}
};
}
}
#endif 
#ifndef IDTL_DTL_SHAPE_REVERSI
#define IDTL_DTL_SHAPE_REVERSI
NS dtl {
inline NS shape {
TP<TN MI>
class Reversi {
private:
using IS = dtl::type::size;
IS start_x{};
IS start_y{};
IS width{};
IS height{};
MI black_value{};
MI white_value{};
TP<TN Matrix_>
DVCC
inline void substitutionSTL(Matrix_&& matrix_, CS IS end_x_, CS IS end_y_) CS NE {
matrix_[end_y_ - 1][end_x_ - 1] = this->white_value;
matrix_[end_y_ - 1][end_x_] = this->black_value;
matrix_[end_y_][end_x_ - 1] = this->black_value;
matrix_[end_y_][end_x_] = this->white_value;
}
TP<TN Matrix_>
DVCC
inline void substitutionArray(Matrix_&& matrix_, CS IS end_x_, CS IS end_y_, CS IS max_x_) CS NE {
matrix_[(end_y_ - 1) * max_x_ + end_x_ - 1] = this->white_value;
matrix_[(end_y_ - 1) * max_x_ + end_x_] = this->black_value;
matrix_[(end_y_)* max_x_ + end_x_ - 1] = this->black_value;
matrix_[(end_y_)* max_x_ + end_x_] = this->white_value;
}
TP<TN Matrix_>
DVCC
inline void substitutionLayer(Matrix_&& matrix_, CS IS layer_, CS IS end_x_, CS IS end_y_) CS NE {
matrix_[end_y_ - 1][end_x_ - 1][layer_] = this->white_value;
matrix_[end_y_ - 1][end_x_][layer_] = this->black_value;
matrix_[end_y_][end_x_ - 1][layer_] = this->black_value;
matrix_[end_y_][end_x_][layer_] = this->white_value;
}
TP<TN Matrix_, TN Function_>
DVCC
inline void substitutionSTL(Matrix_&& matrix_, CS IS end_x_, CS IS end_y_, Function_&& function_) CS NE {
if (!function_(matrix_[end_y_][end_x_])) RT;
matrix_[end_y_ - 1][end_x_ - 1] = this->white_value;
matrix_[end_y_ - 1][end_x_] = this->black_value;
matrix_[end_y_][end_x_ - 1] = this->black_value;
matrix_[end_y_][end_x_] = this->white_value;
}
TP<TN Matrix_, TN Function_>
DVCC
inline void substitutionArray(Matrix_&& matrix_, CS IS end_x_, CS IS end_y_, CS IS max_x_, Function_&& function_) CS NE {
if (!function_(matrix_[end_y_ * max_x_ + end_x_])) RT;
matrix_[(end_y_ - 1) * max_x_ + end_x_ - 1] = this->white_value;
matrix_[(end_y_ - 1) * max_x_ + end_x_] = this->black_value;
matrix_[(end_y_)* max_x_ + end_x_ - 1] = this->black_value;
matrix_[(end_y_)* max_x_ + end_x_] = this->white_value;
}
TP<TN Matrix_, TN Function_>
DVCC
inline void substitutionLayer(Matrix_ && matrix_, CS IS layer_, CS IS end_x_, CS IS end_y_, Function_ && function_) CS NE {
if (!function_(matrix_[end_y_][end_x_][layer_])) RT;
matrix_[end_y_ - 1][end_x_ - 1][layer_] = this->white_value;
matrix_[end_y_ - 1][end_x_][layer_] = this->black_value;
matrix_[end_y_][end_x_ - 1][layer_] = this->black_value;
matrix_[end_y_][end_x_][layer_] = this->white_value;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawSTL(Matrix_&& matrix_, CS IS end_y_, Args_&& ... args_) CS NE {
CS dtl::type::size set_y{ end_y_ / 2 };
CS dtl::type::size set_x{ matrix_[set_y].size() / 2 };
this->substitutionSTL(matrix_, set_x, set_y, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawWidthSTL(Matrix_ && matrix_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
CS dtl::type::size set_y{ end_y_ / 2 };
CS dtl::type::size set_x{ ((matrix_[set_y].size() / 2 < end_x_ / 2) ? matrix_[set_y].size() / 2 : end_x_ / 2) };
this->substitutionSTL(matrix_, set_x, set_y, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawLayerSTL(Matrix_&& matrix_, CS IS layer_, CS IS end_y_, Args_&& ... args_) CS NE {
CS dtl::type::size set_y{ end_y_ / 2 };
CS dtl::type::size set_x{ matrix_[set_y].size() / 2 };
this->substitutionLayer(matrix_, layer_, set_x, set_y, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawLayerWidthSTL(Matrix_ && matrix_, CS IS layer_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
CS dtl::type::size set_y{ end_y_ / 2 };
CS dtl::type::size set_x{ ((matrix_[set_y].size() / 2 < end_x_ / 2) ? matrix_[set_y].size() / 2 : end_x_ / 2) };
this->substitutionLayer(matrix_, layer_, set_x, set_y, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawNormal(Matrix_ && matrix_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
CS dtl::type::size set_y{ end_y_ / 2 };
CS dtl::type::size set_x{ end_x_ / 2 };
this->substitutionSTL(matrix_, set_x, set_y, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawLayerNormal(Matrix_ && matrix_, CS IS layer_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
CS dtl::type::size set_y{ end_y_ / 2 };
CS dtl::type::size set_x{ end_x_ / 2 };
this->substitutionLayer(matrix_, layer_, set_x, set_y, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawArray(Matrix_ && matrix_, CS IS end_x_, CS IS end_y_, CS IS max_x_, Args_ && ... args_) CS NE {
CS dtl::type::size set_y{ end_y_ / 2 };
CS dtl::type::size set_x{ end_x_ / 2 };
this->substitutionArray(matrix_, set_x, set_y, max_x_, args_...);
RT true;
}
public:
DVCN
CE IS getPointX() CS NE {
RT this->start_x;
}
DVCN
CE IS getPointY() CS NE {
RT this->start_y;
}
DVCN
CE IS getWidth() CS NE {
RT this->width;
}
DVCN
CE IS getHeight() CS NE {
RT this->height;
}
DVCN
CE MI getValue() CS NE {
RT this->black_value;
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_) CS NE {
RT (this->width == 0) ? this->drawSTL(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height) : this->drawWidthSTL(matrix_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, Function_ && function_) CS NE {
RT (this->width == 0) ? this->drawSTL(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_) : this->drawWidthSTL(matrix_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_, CS IS layer_) CS NE {
RT (this->width == 0) ? this->drawLayerSTL(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height) : this->drawLayerWidthSTL(matrix_, layer_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, CS IS layer_, Function_ && function_) CS NE {
RT (this->width == 0) ? this->drawLayerSTL(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_) : this->drawLayerWidthSTL(matrix_, layer_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_) CS NE {
RT this->drawNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_, Function_ && function_) CS NE {
RT this->drawNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_, CS IS layer_, CS IS max_x_, CS IS max_y_) CS NE {
RT this->drawLayerNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, CS IS layer_, CS IS max_x_, CS IS max_y_, Function_ && function_) CS NE {
RT this->drawLayerNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL drawArray(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_) CS NE {
RT this->drawArray(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, max_x_);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperatorArray(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_, Function_ && function_) CS NE {
RT this->drawArray(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, max_x_, function_);
}
TP<TN Matrix_, TN ...Args_>
CE BL operator()(Matrix_ && matrix_, Args_ && ... args_) CS NE {
RT this->draw(DTL_TYPE_FORWARD<Matrix_>(matrix_), DTL_TYPE_FORWARD<Args_>(args_)...);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& create(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->draw(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createArray(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->drawArray(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createOperator(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->drawOperator(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createOperatorArray(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->drawOperatorArray(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
DVCC
Reversi& clearPointX() NE {
this->start_x = 0;
RT *this;
}
DVCC
Reversi& clearPointY() NE {
this->start_y = 0;
RT *this;
}
DVCC
Reversi& clearWidth() NE {
this->width = 0;
RT *this;
}
DVCC
Reversi& clearHeight() NE {
this->height = 0;
RT *this;
}
DVCC
Reversi& clearValue() NE {
CS MI new_draw_value{};
this->black_value = new_draw_value;
RT *this;
}
DVCC
Reversi& clearPoint() NE {
this->clearPointX();
this->clearPointY();
RT *this;
}
DVCC
Reversi& clearRange() NE {
this->clearPointX();
this->clearPointY();
this->clearWidth();
this->clearHeight();
RT *this;
}
DVCC
Reversi& clear() NE {
this->clearRange();
this->clearValue();
RT *this;
}
DVCC
Reversi& setPointX(CS IS end_x_) NE {
this->start_x = end_x_;
RT *this;
}
DVCC
Reversi& setPointY(CS IS end_y_) NE {
this->start_y = end_y_;
RT *this;
}
DVCC
Reversi& setWidth(CS IS width_) NE {
this->width = width_;
RT *this;
}
DVCC
Reversi& setHeight(CS IS height_) NE {
this->height = height_;
RT *this;
}
DVCC
Reversi& setValue(CS MI & black_value_) NE {
this->black_value = black_value_;
RT *this;
}
DVCC
Reversi& setPoint(CS IS point_) NE {
this->start_x = point_;
this->start_y = point_;
RT *this;
}
DVCC
Reversi& setPoint(CS IS end_x_, CS IS end_y_) NE {
this->start_x = end_x_;
this->start_y = end_y_;
RT *this;
}
DVCC
Reversi& setRange(CS IS end_x_, CS IS end_y_, CS IS length_) NE {
this->start_x = end_x_;
this->start_y = end_y_;
this->width = length_;
this->height = length_;
RT *this;
}
DVCC
Reversi& setRange(CS IS end_x_, CS IS end_y_, CS IS width_, CS IS height_) NE {
this->start_x = end_x_;
this->start_y = end_y_;
this->width = width_;
this->height = height_;
RT *this;
}
DVCC
Reversi& setRange(CS dtl::base::MatrixRange & matrix_range_) NE {
this->start_x = matrix_range_.x;
this->start_y = matrix_range_.y;
this->width = matrix_range_.w;
this->height = matrix_range_.h;
RT *this;
}
CE Reversi() NE = default;
CE explicit Reversi(CS MI & black_value_) NE
:black_value(black_value_) {}
CE explicit Reversi(CS MI& black_value_, CS MI& white_value_) NE
:black_value(black_value_), white_value(white_value_) {}
CE explicit Reversi(CS dtl::base::MatrixRange & matrix_range_) NE
:start_x(matrix_range_.x), start_y(matrix_range_.y),
width(matrix_range_.w), height(matrix_range_.h) {}
CE explicit Reversi(CS dtl::base::MatrixRange & matrix_range_, CS MI & black_value_) NE
:start_x(matrix_range_.x), start_y(matrix_range_.y),
width(matrix_range_.w), height(matrix_range_.h),
black_value(black_value_) {}
CE explicit Reversi(CS dtl::base::MatrixRange& matrix_range_, CS MI& black_value_, CS MI& white_value_) NE
:start_x(matrix_range_.x), start_y(matrix_range_.y),
width(matrix_range_.w), height(matrix_range_.h),
black_value(black_value_), white_value(white_value_) {}
CE explicit Reversi(CS IS end_x_, CS IS end_y_, CS IS width_, CS IS height_) NE
:start_x(end_x_), start_y(end_y_),
width(width_), height(height_) {}
CE explicit Reversi(CS IS end_x_, CS IS end_y_, CS IS width_, CS IS height_, CS MI & black_value_) NE
:start_x(end_x_), start_y(end_y_),
width(width_), height(height_),
black_value(black_value_) {}
CE explicit Reversi(CS IS end_x_, CS IS end_y_, CS IS width_, CS IS height_, CS MI& black_value_, CS MI& white_value_) NE
:start_x(end_x_), start_y(end_y_),
width(width_), height(height_),
black_value(black_value_), white_value(white_value_) {}
};
}
}
#endif 
#ifndef IDTL_DTL_SHAPE_SIMPLE_ROGUE_LIKE
#define IDTL_DTL_SHAPE_SIMPLE_ROGUE_LIKE
#include <array>
#include <vector>
NS dtl {
inline NS shape {
TP<TN MI>
class SimpleRogueLike {
private:
TP<TN Int_>
CE Int_ absTemplate(CS Int_& value_) CS NE {
RT (value_ < 0) ? (-value_) : value_;
}
enum : dtl::type::ssize {
RL_COUNT_X,
RL_COUNT_Y
};
using StartEndArray = std::array<dtl::type::size, 4>;
using IS = dtl::type::size;
IS start_x{};
IS start_y{};
IS width{};
IS height{};
MI room_value{};
MI road_value{};
dtl::type::size division_min{ 3 };
dtl::type::size division_rand_max{ 4 };
dtl::type::size room_min_x{ 5 };
dtl::type::size room_rand_max_x{ 2 };
dtl::type::size room_min_y{ 5 };
dtl::type::size room_rand_max_y{ 2 };
TP<TN Matrix_, TN ...Args_>
BL drawNormal(Matrix_ && matrix_, CS IS end_x_, CS IS end_y_, Args_ && ...) CS NE {
CS dtl::type::size mapDivCount{ this->division_min + dtl::random::mt32bit.get<dtl::type::size>(this->division_rand_max) };
std::vector<StartEndArray> dungeon_division(mapDivCount, StartEndArray());
std::vector<StartEndArray> dungeon_room(mapDivCount, StartEndArray());
std::vector<StartEndArray> dungeon_road(mapDivCount, StartEndArray());
dungeon_division[0][0] = end_y_ - 1;
dungeon_division[0][1] = end_x_ - 1;
dungeon_division[0][2] = this->start_x + 1;
dungeon_division[0][3] = this->start_y + 1;
dungeon_road[0][0] = (DTL_TYPE_NUMERIC_LIMITS<dtl::type::size>::DTL_TYPE_NUMERIC_LIMITS_MAX)();
dungeon_road[0][1] = (DTL_TYPE_NUMERIC_LIMITS<dtl::type::size>::DTL_TYPE_NUMERIC_LIMITS_MAX)();
createDivision(dungeon_road, dungeon_division, mapDivCount);
createRoom(dungeon_room, dungeon_division, mapDivCount);
this->substitutionRoom(dungeon_room, matrix_, mapDivCount);
createRoad(dungeon_road, dungeon_room, dungeon_division, matrix_, mapDivCount);
RT true;
}
TP<TN Matrix_, TN ...Args_>
BL drawLayerNormal(Matrix_ && matrix_, CS IS layer_, CS IS end_x_, CS IS end_y_, Args_ && ...) CS NE {
CS dtl::type::size mapDivCount{ this->division_min + dtl::random::mt32bit.get<dtl::type::size>(this->division_rand_max) };
std::vector<StartEndArray> dungeon_division(mapDivCount, StartEndArray());
std::vector<StartEndArray> dungeon_room(mapDivCount, StartEndArray());
std::vector<StartEndArray> dungeon_road(mapDivCount, StartEndArray());
dungeon_division[0][0] = end_y_ - 1;
dungeon_division[0][1] = end_x_ - 1;
dungeon_division[0][2] = this->start_x + 1;
dungeon_division[0][3] = this->start_y + 1;
dungeon_road[0][0] = (DTL_TYPE_NUMERIC_LIMITS<dtl::type::size>::DTL_TYPE_NUMERIC_LIMITS_MAX)();
dungeon_road[0][1] = (DTL_TYPE_NUMERIC_LIMITS<dtl::type::size>::DTL_TYPE_NUMERIC_LIMITS_MAX)();
createDivision(dungeon_road, dungeon_division, mapDivCount);
createRoom(dungeon_room, dungeon_division, mapDivCount);
this->substitutionRoomLayer(dungeon_room, matrix_, mapDivCount, layer_);
RT true;
}
TP<TN Matrix_, TN ...Args_>
BL drawArray(Matrix_ && matrix_, CS IS end_x_, CS IS end_y_, CS IS max_x_, Args_ && ...) CS NE {
CS dtl::type::size mapDivCount{ this->division_min + dtl::random::mt32bit.get<dtl::type::size>(this->division_rand_max) };
std::vector<StartEndArray> dungeon_division(mapDivCount, StartEndArray());
std::vector<StartEndArray> dungeon_room(mapDivCount, StartEndArray());
std::vector<StartEndArray> dungeon_road(mapDivCount, StartEndArray());
dungeon_division[0][0] = end_y_ - 1;
dungeon_division[0][1] = end_x_ - 1;
dungeon_division[0][2] = this->start_x + 1;
dungeon_division[0][3] = this->start_y + 1;
dungeon_road[0][0] = (DTL_TYPE_NUMERIC_LIMITS<dtl::type::size>::DTL_TYPE_NUMERIC_LIMITS_MAX)();
dungeon_road[0][1] = (DTL_TYPE_NUMERIC_LIMITS<dtl::type::size>::DTL_TYPE_NUMERIC_LIMITS_MAX)();
createDivision(dungeon_road, dungeon_division, mapDivCount);
createRoom(dungeon_room, dungeon_division, mapDivCount);
this->substitutionRoomArray(dungeon_room, matrix_, mapDivCount, max_x_);
RT true;
}
void createDivision(std::vector<StartEndArray>& dungeon_road, std::vector<StartEndArray>& dungeon_division, CS dtl::type::size mapDivCount) CS NE {
dtl::type::size division_After{};
dtl::type::ssize count{};
for (dtl::type::size i{ 1 }; i < mapDivCount; ++i) {
division_After = dtl::random::mt32bit.get<dtl::type::size>(i);
if (dungeon_division[division_After][0] - dungeon_division[division_After][2] > dungeon_division[division_After][1] - dungeon_division[division_After][3]) count = RL_COUNT_X;
else count = RL_COUNT_Y;
if (dungeon_division[division_After][count] - dungeon_division[division_After][count + 2] < division_rand_max * 2 + 8) {
dtl::type::size k{};
for (dtl::type::size j{ 1 }; j < mapDivCount; ++j) {
if (dungeon_division[j][0] - dungeon_division[j][2] > k) {
k = dungeon_division[j][0] - dungeon_division[j][2];
division_After = j;
count = RL_COUNT_X;
}
if (dungeon_division[j][1] - dungeon_division[j][3] > k) {
k = dungeon_division[j][1] - dungeon_division[j][3];
division_After = j;
count = RL_COUNT_Y;
}
}
}
dungeon_road[i][0] = division_After;
dungeon_road[i][1] = count;
for (dtl::type::size j{ 1 }; j < i; ++j)
if (dungeon_road[j][0] == division_After) dungeon_road[j][0] = i;
dungeon_division[i][count] = dungeon_division[division_After][count + 2]
+ ((dungeon_division[division_After][count] - dungeon_division[division_After][count + 2]) / 3)
+ dtl::random::mt32bit.get<dtl::type::size>(1, (dungeon_division[division_After][count] - dungeon_division[division_After][count + 2]) / 3);
dungeon_division[i][count + 2] = dungeon_division[division_After][count + 2];
dungeon_division[division_After][count + 2] = dungeon_division[i][count];
dungeon_division[i][this->absTemplate(count - 1)] = dungeon_division[division_After][this->absTemplate(count - 1)];
dungeon_division[i][this->absTemplate(count - 1) + 2] = dungeon_division[division_After][this->absTemplate(count - 1) + 2];
}
}
void createRoom(std::vector<StartEndArray>& dungeon_room, CS std::vector<StartEndArray>& dungeon_division, CS dtl::type::size mapDivCount) CS NE {
for (dtl::type::size i{}; i < mapDivCount; ++i) {
dungeon_room[i][2] = dungeon_division[i][2];
dungeon_room[i][3] = dungeon_division[i][3];
dungeon_room[i][0] = dungeon_division[i][2] + this->room_min_y + dtl::random::mt32bit.get<dtl::type::size>(this->room_rand_max_x);
if (dungeon_division[i][0] - dungeon_division[i][2] < dungeon_room[i][0] - dungeon_room[i][2] + 5) {
dungeon_room[i][0] = dungeon_division[i][0] - 4;
if (dungeon_division[i][0] - dungeon_division[i][2] < dungeon_room[i][0] - dungeon_room[i][2] + 5) {
dungeon_room[i][0] = dungeon_division[i][2] + 1;
}
}
dungeon_room[i][1] = dungeon_division[i][3] + this->room_min_x + dtl::random::mt32bit.get<dtl::type::size>(this->room_rand_max_y);
if (dungeon_division[i][1] - dungeon_division[i][3] < dungeon_room[i][1] - dungeon_room[i][3] + 5) {
dungeon_room[i][1] = dungeon_division[i][1] - 4;
if (dungeon_division[i][1] - dungeon_division[i][3] < dungeon_room[i][1] - dungeon_room[i][3] + 5) {
dungeon_room[i][1] = dungeon_division[i][3] + 1;
}
}
if (dungeon_room[i][0] - dungeon_division[i][2] <= 1 || dungeon_room[i][1] - dungeon_division[i][3] <= 1) {
dungeon_room[i][0] = dungeon_division[i][2] + 1;
dungeon_room[i][1] = dungeon_division[i][3] + 1;
}
CS dtl::type::size l{ dtl::random::mt32bit.get<dtl::type::size>(1,dungeon_division[i][0] - dungeon_room[i][0] - 5) + 2 };
CS dtl::type::size n{ dtl::random::mt32bit.get<dtl::type::size>(1,dungeon_division[i][1] - dungeon_room[i][1] - 5) + 2 };
dungeon_room[i][0] += l;
dungeon_room[i][2] += l;
dungeon_room[i][1] += n;
dungeon_room[i][3] += n;
}
}
TP <TN Matrix_>
void substitutionRoom(CS std::vector<StartEndArray>& dungeon_room, Matrix_&& matrix_, CS dtl::type::size mapDivCount) CS NE {
for (dtl::type::size i{}; i < mapDivCount; ++i)
for (dtl::type::size j{ dungeon_room[i][2] }; j < dungeon_room[i][0]; ++j)
for (dtl::type::size k{ dungeon_room[i][3] }; k < dungeon_room[i][1]; ++k)
matrix_[j][k] = this->room_value;
}
TP <TN Matrix_>
void substitutionRoomLayer(CS std::vector<StartEndArray>& dungeon_room, Matrix_&& matrix_, CS dtl::type::size mapDivCount, CS IS layer_) CS NE {
for (dtl::type::size i{}; i < mapDivCount; ++i)
for (dtl::type::size j{ dungeon_room[i][2] }; j < dungeon_room[i][0]; ++j)
for (dtl::type::size k{ dungeon_room[i][3] }; k < dungeon_room[i][1]; ++k)
matrix_[j][k][layer_] = this->room_value;
}
TP <TN Matrix_>
void substitutionRoomArray(CS std::vector<StartEndArray>& dungeon_room, Matrix_&& matrix_, CS dtl::type::size mapDivCount, CS IS max_x_) CS NE {
for (dtl::type::size i{}; i < mapDivCount; ++i)
for (dtl::type::size j{ dungeon_room[i][2] }; j < dungeon_room[i][0]; ++j)
for (dtl::type::size k{ dungeon_room[i][3] }; k < dungeon_room[i][1]; ++k)
matrix_[j * max_x_ + k] = this->room_value;
}
TP <TN Matrix_>
void createRoad(std::vector<StartEndArray>& dungeon_road, CS std::vector<StartEndArray>& dungeon_room, CS std::vector<StartEndArray>& dungeon_division, Matrix_&& matrix_, CS dtl::type::size mapDivCount) CS NE {
for (dtl::type::size roomBefore{}, roomAfter{}; roomBefore < mapDivCount; ++roomBefore) {
roomAfter = dungeon_road[roomBefore][0];
switch (dungeon_road[roomBefore][1]) {
case RL_COUNT_X:
dungeon_road[roomBefore][2] = dtl::random::mt32bit.get<dtl::type::size>(dungeon_room[roomBefore][1] - dungeon_room[roomBefore][3] - 1);
dungeon_road[roomBefore][3] = dtl::random::mt32bit.get<dtl::type::size>(dungeon_room[roomAfter][1] - dungeon_room[roomAfter][3] - 1);
for (dtl::type::size j{ dungeon_room[roomBefore][0] }; j < dungeon_division[roomBefore][0]; ++j)
matrix_[j][dungeon_road[roomBefore][2] + dungeon_room[roomBefore][3]] = this->road_value;
for (dtl::type::size j{ dungeon_division[roomAfter][2] }; j < dungeon_room[roomAfter][2]; ++j)
matrix_[j][dungeon_road[roomBefore][3] + dungeon_room[roomAfter][3]] = this->road_value;
for (dtl::type::size j{ dungeon_road[roomBefore][2] + dungeon_room[roomBefore][3] }; j <= dungeon_road[roomBefore][3] + dungeon_room[roomAfter][3]; ++j)
matrix_[dungeon_division[roomBefore][0]][j] = this->road_value;
for (dtl::type::size j{ dungeon_road[roomBefore][3] + dungeon_room[roomAfter][3] }; j <= dungeon_road[roomBefore][2] + dungeon_room[roomBefore][3]; ++j)
matrix_[dungeon_division[roomBefore][0]][j] = this->road_value;
break;
case RL_COUNT_Y:
dungeon_road[roomBefore][2] = dtl::random::mt32bit.get<dtl::type::size>(dungeon_room[roomBefore][0] - dungeon_room[roomBefore][2] - 1);
dungeon_road[roomBefore][3] = dtl::random::mt32bit.get<dtl::type::size>(dungeon_room[roomAfter][0] - dungeon_room[roomAfter][2] - 1);
for (dtl::type::size j{ dungeon_room[roomBefore][1] }; j < dungeon_division[roomBefore][1]; ++j)
matrix_[dungeon_road[roomBefore][2] + dungeon_room[roomBefore][2]][j] = this->road_value;
for (dtl::type::size j{ dungeon_division[roomAfter][3] }; j < dungeon_room[roomAfter][3]; ++j)
matrix_[dungeon_road[roomBefore][3] + dungeon_room[roomAfter][2]][j] = this->road_value;
for (dtl::type::size j{ dungeon_road[roomBefore][2] + dungeon_room[roomBefore][2] }; j <= dungeon_road[roomBefore][3] + dungeon_room[roomAfter][2]; ++j)
matrix_[j][dungeon_division[roomBefore][1]] = this->road_value;
for (dtl::type::size j{ dungeon_road[roomBefore][3] + dungeon_room[roomAfter][2] }; j <= dungeon_road[roomBefore][2] + dungeon_room[roomBefore][2]; ++j)
matrix_[j][dungeon_division[roomBefore][1]] = this->road_value;
break;
}
}
}
TP <TN Matrix_>
void createRoadLayer(std::vector<StartEndArray>& dungeon_road, CS std::vector<StartEndArray>& dungeon_room, CS std::vector<StartEndArray>& dungeon_division, Matrix_&& matrix_, CS dtl::type::size mapDivCount, CS IS layer_) CS NE {
for (dtl::type::size roomBefore{}, roomAfter{}; roomBefore < mapDivCount; ++roomBefore) {
roomAfter = dungeon_road[roomBefore][0];
switch (dungeon_road[roomBefore][1]) {
case RL_COUNT_X:
dungeon_road[roomBefore][2] = dtl::random::mt32bit.get<dtl::type::size>(dungeon_room[roomBefore][1] - dungeon_room[roomBefore][3] - 1);
dungeon_road[roomBefore][3] = dtl::random::mt32bit.get<dtl::type::size>(dungeon_room[roomAfter][1] - dungeon_room[roomAfter][3] - 1);
for (dtl::type::size j{ dungeon_room[roomBefore][0] }; j < dungeon_division[roomBefore][0]; ++j)
matrix_[j][dungeon_road[roomBefore][2] + dungeon_room[roomBefore][3]][layer_] = this->road_value;
for (dtl::type::size j{ dungeon_division[roomAfter][2] }; j < dungeon_room[roomAfter][2]; ++j)
matrix_[j][dungeon_road[roomBefore][3] + dungeon_room[roomAfter][3]][layer_] = this->road_value;
for (dtl::type::size j{ dungeon_road[roomBefore][2] + dungeon_room[roomBefore][3] }; j <= dungeon_road[roomBefore][3] + dungeon_room[roomAfter][3]; ++j)
matrix_[dungeon_division[roomBefore][0]][j][layer_] = this->road_value;
for (dtl::type::size j{ dungeon_road[roomBefore][3] + dungeon_room[roomAfter][3] }; j <= dungeon_road[roomBefore][2] + dungeon_room[roomBefore][3]; ++j)
matrix_[dungeon_division[roomBefore][0]][j][layer_] = this->road_value;
break;
case RL_COUNT_Y:
dungeon_road[roomBefore][2] = dtl::random::mt32bit.get<dtl::type::size>(dungeon_room[roomBefore][0] - dungeon_room[roomBefore][2] - 1);
dungeon_road[roomBefore][3] = dtl::random::mt32bit.get<dtl::type::size>(dungeon_room[roomAfter][0] - dungeon_room[roomAfter][2] - 1);
for (dtl::type::size j{ dungeon_room[roomBefore][1] }; j < dungeon_division[roomBefore][1]; ++j)
matrix_[dungeon_road[roomBefore][2] + dungeon_room[roomBefore][2]][j][layer_] = this->road_value;
for (dtl::type::size j{ dungeon_division[roomAfter][3] }; j < dungeon_room[roomAfter][3]; ++j)
matrix_[dungeon_road[roomBefore][3] + dungeon_room[roomAfter][2]][j][layer_] = this->road_value;
for (dtl::type::size j{ dungeon_road[roomBefore][2] + dungeon_room[roomBefore][2] }; j <= dungeon_road[roomBefore][3] + dungeon_room[roomAfter][2]; ++j)
matrix_[j][dungeon_division[roomBefore][1]][layer_] = this->road_value;
for (dtl::type::size j{ dungeon_road[roomBefore][3] + dungeon_room[roomAfter][2] }; j <= dungeon_road[roomBefore][2] + dungeon_room[roomBefore][2]; ++j)
matrix_[j][dungeon_division[roomBefore][1]][layer_] = this->road_value;
break;
}
}
}
TP <TN Matrix_>
void createRoadArray(std::vector<StartEndArray>& dungeon_road, CS std::vector<StartEndArray>& dungeon_room, CS std::vector<StartEndArray>& dungeon_division, Matrix_&& matrix_, CS dtl::type::size mapDivCount, CS IS max_x_) CS NE {
for (dtl::type::size roomBefore{}, roomAfter{}; roomBefore < mapDivCount; ++roomBefore) {
roomAfter = dungeon_road[roomBefore][0];
switch (dungeon_road[roomBefore][1]) {
case RL_COUNT_X:
dungeon_road[roomBefore][2] = dtl::random::mt32bit.get<dtl::type::size>(dungeon_room[roomBefore][1] - dungeon_room[roomBefore][3] - 1);
dungeon_road[roomBefore][3] = dtl::random::mt32bit.get<dtl::type::size>(dungeon_room[roomAfter][1] - dungeon_room[roomAfter][3] - 1);
for (dtl::type::size j{ dungeon_room[roomBefore][0] }; j < dungeon_division[roomBefore][0]; ++j)
matrix_[j * max_x_ + dungeon_road[roomBefore][2] + dungeon_room[roomBefore][3]] = this->road_value;
for (dtl::type::size j{ dungeon_division[roomAfter][2] }; j < dungeon_room[roomAfter][2]; ++j)
matrix_[j * max_x_ + dungeon_road[roomBefore][3] + dungeon_room[roomAfter][3]] = this->road_value;
for (dtl::type::size j{ dungeon_road[roomBefore][2] + dungeon_room[roomBefore][3] }; j <= dungeon_road[roomBefore][3] + dungeon_room[roomAfter][3]; ++j)
matrix_[dungeon_division[roomBefore][0] * max_x_ + j] = this->road_value;
for (dtl::type::size j{ dungeon_road[roomBefore][3] + dungeon_room[roomAfter][3] }; j <= dungeon_road[roomBefore][2] + dungeon_room[roomBefore][3]; ++j)
matrix_[dungeon_division[roomBefore][0] * max_x_ + j] = this->road_value;
break;
case RL_COUNT_Y:
dungeon_road[roomBefore][2] = dtl::random::mt32bit.get<dtl::type::size>(dungeon_room[roomBefore][0] - dungeon_room[roomBefore][2] - 1);
dungeon_road[roomBefore][3] = dtl::random::mt32bit.get<dtl::type::size>(dungeon_room[roomAfter][0] - dungeon_room[roomAfter][2] - 1);
for (dtl::type::size j{ dungeon_room[roomBefore][1] }; j < dungeon_division[roomBefore][1]; ++j)
matrix_[(dungeon_road[roomBefore][2] + dungeon_room[roomBefore][2]) * max_x_ + j] = this->road_value;
for (dtl::type::size j{ dungeon_division[roomAfter][3] }; j < dungeon_room[roomAfter][3]; ++j)
matrix_[(dungeon_road[roomBefore][3] + dungeon_room[roomAfter][2]) * max_x_ + j] = this->road_value;
for (dtl::type::size j{ dungeon_road[roomBefore][2] + dungeon_room[roomBefore][2] }; j <= dungeon_road[roomBefore][3] + dungeon_room[roomAfter][2]; ++j)
matrix_[j * max_x_ + dungeon_division[roomBefore][1]] = this->road_value;
for (dtl::type::size j{ dungeon_road[roomBefore][3] + dungeon_room[roomAfter][2] }; j <= dungeon_road[roomBefore][2] + dungeon_room[roomBefore][2]; ++j)
matrix_[j * max_x_ + dungeon_division[roomBefore][1]] = this->road_value;
break;
}
}
}
public:
DVCN
CE IS getPointX() CS NE {
RT this->start_x;
}
DVCN
CE IS getPointY() CS NE {
RT this->start_y;
}
DVCN
CE IS getWidth() CS NE {
RT this->width;
}
DVCN
CE IS getHeight() CS NE {
RT this->height;
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_) CS NE {
RT this->drawNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= ((matrix_.size() == 0) ? 0 : matrix_[0].size())) ? ((matrix_.size() == 0) ? 0 : matrix_[0].size()) : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, Function_ && function_) CS NE {
RT this->drawNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= ((matrix_.size() == 0) ? 0 : matrix_[0].size())) ? ((matrix_.size() == 0) ? 0 : matrix_[0].size()) : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_, CS IS layer_) CS NE {
RT this->drawLayerNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->width == 0 || this->start_x + this->width >= ((matrix_.size() == 0) ? 0 : matrix_[0].size())) ? ((matrix_.size() == 0) ? 0 : matrix_[0].size()) : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, CS IS layer_, Function_ && function_) CS NE {
RT this->drawLayerNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->width == 0 || this->start_x + this->width >= ((matrix_.size() == 0) ? 0 : matrix_[0].size())) ? ((matrix_.size() == 0) ? 0 : matrix_[0].size()) : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_) CS NE {
RT this->drawNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_, Function_ && function_) CS NE {
RT this->drawNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_, CS IS layer_, CS IS max_x_, CS IS max_y_) CS NE {
RT this->drawLayerNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, CS IS layer_, CS IS max_x_, CS IS max_y_, Function_ && function_) CS NE {
RT this->drawLayerNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL drawArray(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_) CS NE {
RT this->drawArray(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, max_x_);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperatorArray(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_, Function_ && function_) CS NE {
RT this->drawArray(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, max_x_, function_);
}
TP<TN Matrix_, TN ...Args_>
CE BL operator()(Matrix_ && matrix_, Args_ && ... args_) CS NE {
RT this->draw(DTL_TYPE_FORWARD<Matrix_>(matrix_), DTL_TYPE_FORWARD<Args_>(args_)...);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& create(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->draw(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createArray(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->drawArray(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createOperator(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->drawOperator(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createOperatorArray(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->drawOperatorArray(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
DVCC
SimpleRogueLike& clearPointX() NE {
this->start_x = 0;
RT *this;
}
DVCC
SimpleRogueLike& clearPointY() NE {
this->start_y = 0;
RT *this;
}
DVCC
SimpleRogueLike& clearWidth() NE {
this->width = 0;
RT *this;
}
DVCC
SimpleRogueLike& clearHeight() NE {
this->height = 0;
RT *this;
}
DVCC
SimpleRogueLike& clearPoint() NE {
this->clearPointX();
this->clearPointY();
RT *this;
}
DVCC
SimpleRogueLike& clearRange() NE {
this->clearPointX();
this->clearPointY();
this->clearWidth();
this->clearHeight();
RT *this;
}
DVCC
SimpleRogueLike& clear() NE {
this->clearRange();
RT *this;
}
DVCC
SimpleRogueLike& setPointX(CS IS end_x_) NE {
this->start_x = end_x_;
RT *this;
}
DVCC
SimpleRogueLike& setPointY(CS IS end_y_) NE {
this->start_y = end_y_;
RT *this;
}
DVCC
SimpleRogueLike& setWidth(CS IS width_) NE {
this->width = width_;
RT *this;
}
DVCC
SimpleRogueLike& setHeight(CS IS height_) NE {
this->height = height_;
RT *this;
}
DVCC
SimpleRogueLike& setPoint(CS IS point_) NE {
this->start_x = point_;
this->start_y = point_;
RT *this;
}
DVCC
SimpleRogueLike& setPoint(CS IS end_x_, CS IS end_y_) NE {
this->start_x = end_x_;
this->start_y = end_y_;
RT *this;
}
DVCC
SimpleRogueLike& setRange(CS IS end_x_, CS IS end_y_, CS IS length_) NE {
this->start_x = end_x_;
this->start_y = end_y_;
this->width = length_;
this->height = length_;
RT *this;
}
DVCC
SimpleRogueLike& setRange(CS IS end_x_, CS IS end_y_, CS IS width_, CS IS height_) NE {
this->start_x = end_x_;
this->start_y = end_y_;
this->width = width_;
this->height = height_;
RT *this;
}
DVCC
SimpleRogueLike& setRange(CS dtl::base::MatrixRange & matrix_range_) NE {
this->start_x = matrix_range_.x;
this->start_y = matrix_range_.y;
this->width = matrix_range_.w;
this->height = matrix_range_.h;
RT *this;
}
DVCC
SimpleRogueLike& setRogueLike(CS dtl::type::size division_min_, CS dtl::type::size division_rand_max_, CS dtl::type::size room_min_x_, CS dtl::type::size room_rand_max_x_, CS dtl::type::size room_min_y_, CS dtl::type::size room_rand_max_y_) NE {
division_min = division_min_;
division_rand_max = division_rand_max_;
room_min_x = room_min_x_;
room_rand_max_x = room_rand_max_x_;
room_min_y = room_min_y_;
room_rand_max_y = room_rand_max_y_;
RT *this;
}
CE SimpleRogueLike() NE = default;
CE explicit SimpleRogueLike(CS MI& room_value_) NE
:room_value(room_value_) {}
CE explicit SimpleRogueLike(CS MI& room_value_, CS MI& road_value_) NE
:room_value(room_value_), road_value(road_value_) {}
CE explicit SimpleRogueLike(CS MI& room_value_, CS MI& road_value_, CS dtl::type::size division_min_, CS dtl::type::size division_rand_max_, CS dtl::type::size room_min_x_, CS dtl::type::size room_rand_max_x_, CS dtl::type::size room_min_y_, CS dtl::type::size room_rand_max_y_) NE
:room_value(room_value_), road_value(road_value_),
division_min(division_min_),
division_rand_max(division_rand_max_),
room_min_x(room_min_x_),
room_rand_max_x(room_rand_max_x_),
room_min_y(room_min_y_),
room_rand_max_y(room_rand_max_y_) {}
CE explicit SimpleRogueLike(CS dtl::base::MatrixRange & matrix_range_) NE
:start_x(matrix_range_.x), start_y(matrix_range_.y),
width(matrix_range_.w), height(matrix_range_.h) {}
CE explicit SimpleRogueLike(CS dtl::base::MatrixRange& matrix_range_, CS MI& room_value_) NE
:start_x(matrix_range_.x), start_y(matrix_range_.y),
width(matrix_range_.w), height(matrix_range_.h),
room_value(room_value_) {}
CE explicit SimpleRogueLike(CS dtl::base::MatrixRange& matrix_range_, CS MI& room_value_, CS MI& road_value_) NE
:start_x(matrix_range_.x), start_y(matrix_range_.y),
width(matrix_range_.w), height(matrix_range_.h),
room_value(room_value_), road_value(road_value_) {}
CE explicit SimpleRogueLike(CS dtl::base::MatrixRange& matrix_range_, CS MI& room_value_, CS MI& road_value_, CS dtl::type::size division_min_, CS dtl::type::size division_rand_max_, CS dtl::type::size room_min_x_, CS dtl::type::size room_rand_max_x_, CS dtl::type::size room_min_y_, CS dtl::type::size room_rand_max_y_) NE
:start_x(matrix_range_.x), start_y(matrix_range_.y),
width(matrix_range_.w), height(matrix_range_.h),
room_value(room_value_), road_value(road_value_),
division_min(division_min_),
division_rand_max(division_rand_max_),
room_min_x(room_min_x_),
room_rand_max_x(room_rand_max_x_),
room_min_y(room_min_y_),
room_rand_max_y(room_rand_max_y_) {}
CE explicit SimpleRogueLike(CS IS end_x_, CS IS end_y_, CS IS width_, CS IS height_) NE
:start_x(end_x_), start_y(end_y_),
width(width_), height(height_) {}
};
}
}
#endif 
#ifndef IDTL_DTL_SHAPE_SIMPLE_VORONOI_ISLAND
#define IDTL_DTL_SHAPE_SIMPLE_VORONOI_ISLAND
NS dtl {
inline NS shape {
TP<TN MI, TN UniquePair_ = DTL_TYPE_UNIQUE_PTR<std::pair<dtl::type::ssize, dtl::type::ssize>[]>, TN UniqueInt_ = DTL_TYPE_UNIQUE_PTR<MI[]>>
class SimpleVoronoiIsland {
private:
using IS = dtl::type::size;
dtl::utility::VoronoiDiagram<MI, UniquePair_, UniqueInt_> voronoiDiagram{};
double probability_value{ 0.5 };
MI land_value{};
MI sea_value{};
public:
DVCN
CE IS getPointX() CS NE {
RT this->voronoiDiagram.getPointX();
}
DVCN
CE IS getPointY() CS NE {
RT this->voronoiDiagram.getPointY();
}
DVCN
CE IS getWidth() CS NE {
RT this->voronoiDiagram.getWidth();
}
DVCN
CE IS getHeight() CS NE {
RT this->voronoiDiagram.getHeight();
}
DVCN
CE dtl::type::size getValue() CS NE {
RT this->voronoiDiagram.getValue();
}
CE BL isIsland(CS std::pair<dtl::type::ssize, dtl::type::ssize>& point_, CS dtl::type::ssize sx_, CS dtl::type::ssize sy_, CS dtl::type::ssize w_, CS dtl::type::ssize h_, CS dtl::type::ssize numerator_, CS dtl::type::ssize denominator_) CS NE {
RT (point_.first > ((w_ - sx_) * numerator_ / denominator_ + sx_) && point_.first < ((w_ - sx_) * (denominator_ - numerator_) / denominator_ + sx_)) && (point_.second > ((h_ - sy_) * numerator_ / denominator_ + sy_) && point_.second < ((h_ - sy_) * (denominator_ - numerator_) / denominator_ + sy_));
}
TP<TN Matrix_>
CE BL draw(Matrix_&& matrix_) CS NE {
RT this->voronoiDiagram.draw(matrix_,
[this](CS std::pair<dtl::type::ssize, dtl::type::ssize> & point_, MI & color_, CS dtl::type::ssize sx_, CS dtl::type::ssize sy_, CS dtl::type::ssize w_, CS dtl::type::ssize h_) {
if ((this->isIsland(point_, sx_, sy_, w_, h_, 2, 5) || this->isIsland(point_, sx_, sy_, w_, h_, 1, 5)) && dtl::random::mt32bit.probability(this->probability_value)) color_ = this->land_value;
else color_ = this->sea_value;
});
}
TP<TN Matrix_>
CE BL draw(Matrix_&& matrix_, CS IS layer_) CS NE {
RT this->voronoiDiagram.draw(matrix_, layer_,
[this](CS std::pair<dtl::type::ssize, dtl::type::ssize>& point_, MI & color_, CS dtl::type::ssize sx_, CS dtl::type::ssize sy_, CS dtl::type::ssize w_, CS dtl::type::ssize h_) {
if ((this->isIsland(point_, sx_, sy_, w_, h_, 2, 5) || this->isIsland(point_, sx_, sy_, w_, h_, 1, 5)) && dtl::random::mt32bit.probability(this->probability_value)) color_ = this->land_value;
else color_ = this->sea_value;
});
}
TP<TN Matrix_>
CE BL draw(Matrix_&& matrix_, CS IS max_x_, CS IS max_y_) CS NE {
RT this->voronoiDiagram.draw(matrix_, max_x_, max_y_,
[this](CS std::pair<dtl::type::ssize, dtl::type::ssize>& point_, MI & color_, CS dtl::type::ssize sx_, CS dtl::type::ssize sy_, CS dtl::type::ssize w_, CS dtl::type::ssize h_) {
if ((this->isIsland(point_, sx_, sy_, w_, h_, 2, 5) || this->isIsland(point_, sx_, sy_, w_, h_, 1, 5)) && dtl::random::mt32bit.probability(this->probability_value)) color_ = this->land_value;
else color_ = this->sea_value;
});
}
TP<TN Matrix_>
CE BL draw(Matrix_&& matrix_, CS IS layer_, CS IS max_x_, CS IS max_y_) CS NE {
RT this->voronoiDiagram.draw(matrix_, layer_, max_x_, max_y_,
[this](CS std::pair<dtl::type::ssize, dtl::type::ssize>& point_, MI & color_, CS dtl::type::ssize sx_, CS dtl::type::ssize sy_, CS dtl::type::ssize w_, CS dtl::type::ssize h_) {
if ((this->isIsland(point_, sx_, sy_, w_, h_, 2, 5) || this->isIsland(point_, sx_, sy_, w_, h_, 1, 5)) && dtl::random::mt32bit.probability(this->probability_value)) color_ = this->land_value;
else color_ = this->sea_value;
});
}
TP<TN Matrix_>
CE BL drawArray(Matrix_&& matrix_, CS IS max_x_, CS IS max_y_) CS NE {
RT this->voronoiDiagram.drawArray(matrix_, max_x_, max_y_,
[this](CS std::pair<dtl::type::ssize, dtl::type::ssize>& point_, MI & color_, CS dtl::type::ssize sx_, CS dtl::type::ssize sy_, CS dtl::type::ssize w_, CS dtl::type::ssize h_) {
if ((this->isIsland(point_, sx_, sy_, w_, h_, 2, 5) || this->isIsland(point_, sx_, sy_, w_, h_, 1, 5)) && dtl::random::mt32bit.probability(this->probability_value)) color_ = this->land_value;
else color_ = this->sea_value;
});
}
TP<TN Matrix_, TN ...Args_>
CE BL operator()(Matrix_&& matrix_, Args_&& ... args_) CS NE {
RT this->draw(DTL_TYPE_FORWARD<Matrix_>(matrix_), DTL_TYPE_FORWARD<Args_>(args_)...);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& create(Matrix_&& matrix_, Args_&& ... args_) CS NE {
this->draw(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createArray(Matrix_&& matrix_, Args_&& ... args_) CS NE {
this->drawArray(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createOperator(Matrix_&& matrix_, Args_&& ... args_) CS NE {
this->drawOperator(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createOperatorArray(Matrix_&& matrix_, Args_&& ... args_) CS NE {
this->drawOperatorArray(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
DVCC
SimpleVoronoiIsland& clearPointX() NE {
this->voronoiDiagram.clearPointX();
RT *this;
}
DVCC
SimpleVoronoiIsland& clearPointY() NE {
this->voronoiDiagram.clearPointY();
RT *this;
}
DVCC
SimpleVoronoiIsland& clearWidth() NE {
this->voronoiDiagram.clearWidth();
RT *this;
}
DVCC
SimpleVoronoiIsland& clearHeight() NE {
this->voronoiDiagram.clearHeight();
RT *this;
}
DVCC
SimpleVoronoiIsland& clearValue() NE {
this->voronoiDiagram.clearValue();
RT *this;
}
DVCC
SimpleVoronoiIsland& clearPoint() NE {
this->clearPointX();
this->clearPointY();
RT *this;
}
DVCC
SimpleVoronoiIsland& clearRange() NE {
this->clearPointX();
this->clearPointY();
this->clearWidth();
this->clearHeight();
RT *this;
}
DVCC
SimpleVoronoiIsland& clear() NE {
this->clearRange();
this->clearValue();
RT *this;
}
DVCC
SimpleVoronoiIsland& setPointX(CS IS end_x_) NE {
this->voronoiDiagram.setPointX(end_x_);
RT *this;
}
DVCC
SimpleVoronoiIsland& setPointY(CS IS end_y_) NE {
this->voronoiDiagram.setPointY(end_y_);
RT *this;
}
DVCC
SimpleVoronoiIsland& setWidth(CS IS width_) NE {
this->voronoiDiagram.setWidth(width_);
RT *this;
}
DVCC
SimpleVoronoiIsland& setHeight(CS IS height_) NE {
this->voronoiDiagram.setHeight(height_);
RT *this;
}
DVCC
SimpleVoronoiIsland& setValue(CS dtl::type::size voronoi_num_) NE {
this->voronoiDiagram.setValue(voronoi_num_);
RT *this;
}
DVCC
SimpleVoronoiIsland& setRange(CS dtl::base::MatrixRange& matrix_range_) NE {
this->voronoiDiagram.setRange(matrix_range_);
RT *this;
}
DVCC
SimpleVoronoiIsland& setPoint(CS IS point_) NE {
this->setPointX(point_);
this->setPointY(point_);
RT *this;
}
DVCC
SimpleVoronoiIsland& setPoint(CS IS end_x_, CS IS end_y_) NE {
this->setPointX(end_x_);
this->setPointY(end_y_);
RT *this;
}
DVCC
SimpleVoronoiIsland& setRange(CS IS end_x_, CS IS end_y_, CS IS length_) NE {
this->setPointX(end_x_);
this->setPointY(end_y_);
this->setWidth(length_);
this->setHeight(length_);
RT *this;
}
DVCC
SimpleVoronoiIsland& setRange(CS IS end_x_, CS IS end_y_, CS IS width_, CS IS height_) NE {
this->setPointX(end_x_);
this->setPointY(end_y_);
this->setWidth(width_);
this->setHeight(height_);
RT *this;
}
CE SimpleVoronoiIsland() NE = default;
CE explicit SimpleVoronoiIsland(CS dtl::type::size voronoi_num_) NE
:voronoiDiagram(voronoi_num_) {}
CE explicit SimpleVoronoiIsland(CS dtl::type::size voronoi_num_, CS double probability_value_) NE
:voronoiDiagram(voronoi_num_), probability_value(probability_value_) {}
CE explicit SimpleVoronoiIsland(CS dtl::type::size voronoi_num_, CS double probability_value_, CS MI& land_value_) NE
:voronoiDiagram(voronoi_num_), probability_value(probability_value_), land_value(land_value_) {}
CE explicit SimpleVoronoiIsland(CS dtl::type::size voronoi_num_, CS double probability_value_, CS MI& land_value_, CS MI& sea_value_) NE
:voronoiDiagram(voronoi_num_), probability_value(probability_value_), land_value(land_value_), sea_value(sea_value_) {}
CE explicit SimpleVoronoiIsland(CS dtl::base::MatrixRange& matrix_range_) NE
:voronoiDiagram(matrix_range_) {}
CE explicit SimpleVoronoiIsland(CS dtl::base::MatrixRange& matrix_range_, CS dtl::type::size voronoi_num_) NE
:voronoiDiagram(matrix_range_, voronoi_num_) {}
CE explicit SimpleVoronoiIsland(CS dtl::base::MatrixRange& matrix_range_, CS dtl::type::size voronoi_num_, CS double probability_value_) NE
:voronoiDiagram(matrix_range_, voronoi_num_), probability_value(probability_value_) {}
CE explicit SimpleVoronoiIsland(CS dtl::base::MatrixRange& matrix_range_, CS dtl::type::size voronoi_num_, CS double probability_value_, CS MI& land_value_) NE
:voronoiDiagram(matrix_range_, voronoi_num_), probability_value(probability_value_), land_value(land_value_) {}
CE explicit SimpleVoronoiIsland(CS dtl::base::MatrixRange& matrix_range_, CS dtl::type::size voronoi_num_, CS double probability_value_, CS MI& land_value_, CS MI& sea_value_) NE
:voronoiDiagram(matrix_range_, voronoi_num_), probability_value(probability_value_), land_value(land_value_), sea_value(sea_value_) {}
};
}
}
#endif 
#ifndef IDTL_DTL_SHAPE_WHITE_NOISE
#define IDTL_DTL_SHAPE_WHITE_NOISE
NS dtl {
inline NS shape {
TP<TN MI>
class WhiteNoise {
private:
using IS = dtl::type::size;
IS start_x{};
IS start_y{};
IS width{};
IS height{};
MI draw_value{};
TP<TN Matrix_>
DVCC
inline void substitutionSTL(Matrix_&& matrix_, CS IS end_x_, CS IS end_y_) CS NE {
if (dtl::random::mt32bit.probability()) matrix_[end_y_][end_x_] = this->draw_value;
}
TP<TN Matrix_>
DVCC
inline void substitutionArray(Matrix_&& matrix_, CS IS end_x_, CS IS end_y_, CS IS max_x_) CS NE {
if (dtl::random::mt32bit.probability()) matrix_[end_y_ * max_x_ + end_x_] = this->draw_value;
}
TP<TN Matrix_>
DVCC
inline void substitutionLayer(Matrix_&& matrix_, CS IS layer_, CS IS end_x_, CS IS end_y_) CS NE {
if (dtl::random::mt32bit.probability()) matrix_[end_y_][end_x_][layer_] = this->draw_value;
}
TP<TN Matrix_Value_>
DVCC
inline void substitutionList(Matrix_Value_&& matrix_) CS NE {
if (dtl::random::mt32bit.probability()) matrix_ = this->draw_value;
}
TP<TN Matrix_, TN Function_>
DVCC
inline void substitutionSTL(Matrix_&& matrix_, CS IS end_x_, CS IS end_y_, Function_&& function_) CS NE {
if (function_(matrix_[end_y_][end_x_]) && dtl::random::mt32bit.probability()) matrix_[end_y_][end_x_] = this->draw_value;
}
TP<TN Matrix_, TN Function_>
DVCC
inline void substitutionArray(Matrix_&& matrix_, CS IS end_x_, CS IS end_y_, CS IS max_x_, Function_&& function_) CS NE {
if (function_(matrix_[end_y_ * max_x_ + end_x_]) && dtl::random::mt32bit.probability()) matrix_[end_y_ * max_x_ + end_x_] = this->draw_value;
}
TP<TN Matrix_, TN Function_>
DVCC
inline void substitutionLayer(Matrix_ && matrix_, CS IS layer_, CS IS end_x_, CS IS end_y_, Function_ && function_) CS NE {
if (function_(matrix_[end_y_][end_x_][layer_]) && dtl::random::mt32bit.probability()) matrix_[end_y_][end_x_][layer_] = this->draw_value;
}
TP<TN Matrix_Value_, TN Function_>
DVCC
inline void substitutionList(Matrix_Value_&& matrix_, Function_&& function_) CS NE {
if (function_(matrix_) && dtl::random::mt32bit.probability()) matrix_ = this->draw_value;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawSTL(Matrix_ && matrix_, CS IS end_y_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i)
for (IS j{ this->start_x }; j < matrix_[i].size(); ++j)
this->substitutionSTL(matrix_, j, i, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawWidthSTL(Matrix_ && matrix_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i)
for (IS j{ this->start_x }; j < matrix_[i].size() && j < end_x_; ++j)
this->substitutionSTL(matrix_, j, i, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawLayerSTL(Matrix_ && matrix_, CS IS layer_, CS IS end_y_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i)
for (IS j{ this->start_x }; j < matrix_[i].size(); ++j)
this->substitutionLayer(matrix_, layer_, j, i, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawLayerWidthSTL(Matrix_ && matrix_, CS IS layer_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i)
for (IS j{ this->start_x }; j < matrix_[i].size() && j < end_x_; ++j)
this->substitutionLayer(matrix_, layer_, j, i, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawNormal(Matrix_ && matrix_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i)
for (IS j{ this->start_x }; j < end_x_; ++j)
this->substitutionSTL(matrix_, j, i, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawLayerNormal(Matrix_ && matrix_, CS IS layer_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i)
for (IS j{ this->start_x }; j < end_x_; ++j)
this->substitutionLayer(matrix_, layer_, j, i, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawArray(Matrix_ && matrix_, CS IS end_x_, CS IS end_y_, CS IS max_x_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i)
for (IS j{ this->start_x }; j < end_x_; ++j)
this->substitutionArray(matrix_, j, i, max_x_, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawList(Matrix_&& matrix_, CS IS end_x_, CS IS end_y_, Args_&& ... args_) CS NE {
dtl::type::size row_count{}, col_count{};
for (auto&& i : matrix_) {
++row_count;
if (row_count <= this->start_y) continue;
if (end_y_ != 1 && row_count >= end_y_) break;
col_count = 0;
for (auto&& j : i) {
++col_count;
if (col_count <= this->start_x) continue;
if (end_x_ != 1 && col_count >= end_x_) break;
this->substitutionList(j, args_...);
}
}
RT true;
}
public:
DVCN
CE IS getPointX() CS NE {
RT this->start_x;
}
DVCN
CE IS getPointY() CS NE {
RT this->start_y;
}
DVCN
CE IS getWidth() CS NE {
RT this->width;
}
DVCN
CE IS getHeight() CS NE {
RT this->height;
}
DVCN
CE MI getValue() CS NE {
RT this->draw_value;
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_) CS NE {
RT (this->width == 0) ? this->drawSTL(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height) : this->drawWidthSTL(matrix_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, Function_ && function_) CS NE {
RT (this->width == 0) ? this->drawSTL(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_) : this->drawWidthSTL(matrix_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_, CS IS layer_) CS NE {
RT (this->width == 0) ? this->drawLayerSTL(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height) : this->drawLayerWidthSTL(matrix_, layer_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, CS IS layer_, Function_ && function_) CS NE {
RT (this->width == 0) ? this->drawLayerSTL(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_) : this->drawLayerWidthSTL(matrix_, layer_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_) CS NE {
RT this->drawNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_, Function_ && function_) CS NE {
RT this->drawNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_, CS IS layer_, CS IS max_x_, CS IS max_y_) CS NE {
RT this->drawLayerNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, CS IS layer_, CS IS max_x_, CS IS max_y_, Function_ && function_) CS NE {
RT this->drawLayerNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL drawArray(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_) CS NE {
RT this->drawArray(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, max_x_);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperatorArray(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_, Function_ && function_) CS NE {
RT this->drawArray(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, max_x_, function_);
}
TP<TN Matrix_>
CE BL drawList(Matrix_&& matrix_) CS NE {
RT this->drawList(DTL_TYPE_FORWARD<Matrix_>(matrix_), this->start_x + this->width + 1, this->start_y + this->height + 1);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperatorList(Matrix_ && matrix_, Function_ && function_) CS NE {
RT this->drawList(DTL_TYPE_FORWARD<Matrix_>(matrix_), this->start_x + this->width + 1, this->start_y + this->height + 1, function_);
}
TP<TN Matrix_, TN ...Args_>
CE BL operator()(Matrix_ && matrix_, Args_ && ... args_) CS NE {
RT this->draw(DTL_TYPE_FORWARD<Matrix_>(matrix_), DTL_TYPE_FORWARD<Args_>(args_)...);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& create(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->draw(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createArray(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->drawArray(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createOperator(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->drawOperator(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createOperatorArray(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->drawOperatorArray(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
DVCC
WhiteNoise& clearPointX() NE {
this->start_x = 0;
RT *this;
}
DVCC
WhiteNoise& clearPointY() NE {
this->start_y = 0;
RT *this;
}
DVCC
WhiteNoise& clearWidth() NE {
this->width = 0;
RT *this;
}
DVCC
WhiteNoise& clearHeight() NE {
this->height = 0;
RT *this;
}
DVCC
WhiteNoise& clearValue() NE {
CS MI new_draw_value{};
this->draw_value = new_draw_value;
RT *this;
}
DVCC
WhiteNoise& clearPoint() NE {
this->clearPointX();
this->clearPointY();
RT *this;
}
DVCC
WhiteNoise& clearRange() NE {
this->clearPointX();
this->clearPointY();
this->clearWidth();
this->clearHeight();
RT *this;
}
DVCC
WhiteNoise& clear() NE {
this->clearRange();
this->clearValue();
RT *this;
}
DVCC
WhiteNoise& setPointX(CS IS end_x_) NE {
this->start_x = end_x_;
RT *this;
}
DVCC
WhiteNoise& setPointY(CS IS end_y_) NE {
this->start_y = end_y_;
RT *this;
}
DVCC
WhiteNoise& setWidth(CS IS width_) NE {
this->width = width_;
RT *this;
}
DVCC
WhiteNoise& setHeight(CS IS height_) NE {
this->height = height_;
RT *this;
}
DVCC
WhiteNoise& setValue(CS MI & draw_value_) NE {
this->draw_value = draw_value_;
RT *this;
}
DVCC
WhiteNoise& setPoint(CS IS point_) NE {
this->start_x = point_;
this->start_y = point_;
RT *this;
}
DVCC
WhiteNoise& setPoint(CS IS end_x_, CS IS end_y_) NE {
this->start_x = end_x_;
this->start_y = end_y_;
RT *this;
}
DVCC
WhiteNoise& setRange(CS IS end_x_, CS IS end_y_, CS IS length_) NE {
this->start_x = end_x_;
this->start_y = end_y_;
this->width = length_;
this->height = length_;
RT *this;
}
DVCC
WhiteNoise& setRange(CS IS end_x_, CS IS end_y_, CS IS width_, CS IS height_) NE {
this->start_x = end_x_;
this->start_y = end_y_;
this->width = width_;
this->height = height_;
RT *this;
}
DVCC
WhiteNoise& setRange(CS dtl::base::MatrixRange & matrix_range_) NE {
this->start_x = matrix_range_.x;
this->start_y = matrix_range_.y;
this->width = matrix_range_.w;
this->height = matrix_range_.h;
RT *this;
}
CE WhiteNoise() NE = default;
CE explicit WhiteNoise(CS MI & draw_value_) NE
:draw_value(draw_value_) {}
CE explicit WhiteNoise(CS dtl::base::MatrixRange & matrix_range_) NE
:start_x(matrix_range_.x), start_y(matrix_range_.y),
width(matrix_range_.w), height(matrix_range_.h) {}
CE explicit WhiteNoise(CS dtl::base::MatrixRange & matrix_range_, CS MI & draw_value_) NE
:start_x(matrix_range_.x), start_y(matrix_range_.y),
width(matrix_range_.w), height(matrix_range_.h),
draw_value(draw_value_) {}
CE explicit WhiteNoise(CS IS end_x_, CS IS end_y_, CS IS width_, CS IS height_) NE
:start_x(end_x_), start_y(end_y_),
width(width_), height(height_) {}
CE explicit WhiteNoise(CS IS end_x_, CS IS end_y_, CS IS width_, CS IS height_, CS MI & draw_value_) NE
:start_x(end_x_), start_y(end_y_),
width(width_), height(height_),
draw_value(draw_value_) {}
};
}
}
#endif 
#endif 
#endif 
#ifndef NOT_IDTL_DTL_UTILITY
#ifndef IDTL_DTL_UTILITY
#define IDTL_DTL_UTILITY
#ifndef IDTL_DTL_UTILITY_BINARIZATION
#define IDTL_DTL_UTILITY_BINARIZATION
NS dtl {
inline NS utility {
TP<TN MI>
class Binarization {
private:
using IS = dtl::type::size;
IS start_x{};
IS start_y{};
IS width{};
IS height{};
MI true_value{};
MI false_value{};
TP<TN Matrix_>
DVCC
inline void substitutionSTL(Matrix_&& matrix_, CS IS point_x_, CS IS point_y_) CS NE {
(matrix_[point_y_][point_x_]) ? matrix_[point_y_][point_x_] = this->true_value : matrix_[point_y_][point_x_] = this->false_value;
}
TP<TN Matrix_>
DVCC
inline void substitutionArray(Matrix_&& matrix_, CS IS point_x_, CS IS point_y_, CS IS max_x_) CS NE {
(matrix_[point_y_ * max_x_ + point_x_]) ? matrix_[point_y_ * max_x_ + point_x_] = this->true_value : matrix_[point_y_ * max_x_ + point_x_] = this->false_value;
}
TP<TN Matrix_>
DVCC
inline void substitutionLayer(Matrix_ && matrix_, CS IS layer_, CS IS point_x_, CS IS point_y_) CS NE {
(matrix_[point_y_][point_x_][layer_]) ? matrix_[point_y_][point_x_][layer_] = this->true_value : matrix_[point_y_][point_x_][layer_] = this->false_value;
}
TP<TN Matrix_, TN Function_>
DVCC
inline void substitutionSTL(Matrix_ && matrix_, CS IS point_x_, CS IS point_y_, Function_ && function_) CS NE {
(function_(matrix_[point_y_][point_x_])) ? matrix_[point_y_][point_x_] = this->true_value : matrix_[point_y_][point_x_] = this->false_value;
}
TP<TN Matrix_, TN Function_>
DVCC
inline void substitutionArray(Matrix_ && matrix_, CS IS point_x_, CS IS point_y_, CS IS max_x_, Function_ && function_) CS NE {
(function_(matrix_[point_y_ * max_x_ + point_x_])) ? matrix_[point_y_ * max_x_ + point_x_] = this->true_value : matrix_[point_y_ * max_x_ + point_x_] = this->false_value;
}
TP<TN Matrix_, TN Function_>
DVCC
inline void substitutionLayer(Matrix_ && matrix_, CS IS layer_, CS IS point_x_, CS IS point_y_, Function_ && function_) CS NE {
(function_(matrix_[point_y_][point_x_][layer_])) ? matrix_[point_y_][point_x_][layer_] = this->true_value : matrix_[point_y_][point_x_][layer_] = this->false_value;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawSTL(Matrix_ && matrix_, CS IS end_y_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i)
for (IS j{ this->start_x }; j < matrix_[i].size(); ++j)
this->substitutionSTL(matrix_, j, i, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawWidthSTL(Matrix_ && matrix_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i)
for (IS j{ this->start_x }; j < matrix_[i].size() && j < end_x_; ++j)
this->substitutionSTL(matrix_, j, i, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawLayerSTL(Matrix_ && matrix_, CS IS layer_, CS IS end_y_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i)
for (IS j{ this->start_x }; j < matrix_[i].size(); ++j)
this->substitutionLayer(matrix_, layer_, j, i, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawLayerWidthSTL(Matrix_ && matrix_, CS IS layer_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i)
for (IS j{ this->start_x }; j < matrix_[i].size() && j < end_x_; ++j)
this->substitutionLayer(matrix_, layer_, j, i, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawNormal(Matrix_ && matrix_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i)
for (IS j{ this->start_x }; j < end_x_; ++j)
this->substitutionSTL(matrix_, j, i, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawLayerNormal(Matrix_ && matrix_, CS IS layer_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i)
for (IS j{ this->start_x }; j < end_x_; ++j)
this->substitutionLayer(matrix_, layer_, j, i, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawArray(Matrix_ && matrix_, CS IS end_x_, CS IS end_y_, CS IS max_x_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i)
for (IS j{ this->start_x }; j < end_x_; ++j)
this->substitutionArray(matrix_, j, i, max_x_, args_...);
RT true;
}
public:
DVCN
CE IS getPointX() CS NE {
RT this->start_x;
}
DVCN
CE IS getPointY() CS NE {
RT this->start_y;
}
DVCN
CE IS getWidth() CS NE {
RT this->width;
}
DVCN
CE IS getHeight() CS NE {
RT this->height;
}
DVCN
CE MI getValue() CS NE {
RT this->true_value;
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_) CS NE {
RT (this->width == 0) ? this->drawSTL(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height) : this->drawWidthSTL(matrix_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, Function_ && function_) CS NE {
RT (this->width == 0) ? this->drawSTL(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_) : this->drawWidthSTL(matrix_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_, CS IS layer_) CS NE {
RT (this->width == 0) ? this->drawLayerSTL(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height) : this->drawLayerWidthSTL(matrix_, layer_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, CS IS layer_, Function_ && function_) CS NE {
RT (this->width == 0) ? this->drawLayerSTL(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_) : this->drawLayerWidthSTL(matrix_, layer_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_) CS NE {
RT this->drawNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_, Function_ && function_) CS NE {
RT this->drawNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_, CS IS layer_, CS IS max_x_, CS IS max_y_) CS NE {
RT this->drawLayerNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, CS IS layer_, CS IS max_x_, CS IS max_y_, Function_ && function_) CS NE {
RT this->drawLayerNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL drawArray(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_) CS NE {
RT this->drawArray(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, max_x_);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperatorArray(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_, Function_ && function_) CS NE {
RT this->drawArray(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, max_x_, function_);
}
TP<TN Matrix_, TN ...Args_>
CE BL operator()(Matrix_ && matrix_, Args_ && ... args_) CS NE {
RT this->draw(DTL_TYPE_FORWARD<Matrix_>(matrix_), DTL_TYPE_FORWARD<Args_>(args_)...);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& create(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->draw(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createArray(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->drawArray(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createOperator(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->drawOperator(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createOperatorArray(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->drawOperatorArray(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
DVCC
Binarization& clearPointX() NE {
this->start_x = 0;
RT *this;
}
DVCC
Binarization& clearPointY() NE {
this->start_y = 0;
RT *this;
}
DVCC
Binarization& clearWidth() NE {
this->width = 0;
RT *this;
}
DVCC
Binarization& clearHeight() NE {
this->height = 0;
RT *this;
}
DVCC
Binarization& clearPoint() NE {
this->clearPointX();
this->clearPointY();
RT *this;
}
DVCC
Binarization& clearRange() NE {
this->clearPointX();
this->clearPointY();
this->clearWidth();
this->clearHeight();
RT *this;
}
DVCC
Binarization& clear() NE {
this->clearRange();
RT *this;
}
DVCC
Binarization& setPointX(CS IS start_x_) NE {
this->start_x = start_x_;
RT *this;
}
DVCC
Binarization& setPointY(CS IS start_y_) NE {
this->start_y = start_y_;
RT *this;
}
DVCC
Binarization& setWidth(CS IS width_) NE {
this->width = width_;
RT *this;
}
DVCC
Binarization& setHeight(CS IS height_) NE {
this->height = height_;
RT *this;
}
DVCC
Binarization& setPoint(CS IS point_) NE {
this->start_x = point_;
this->start_y = point_;
RT *this;
}
DVCC
Binarization& setPoint(CS IS start_x_, CS IS start_y_) NE {
this->start_x = start_x_;
this->start_y = start_y_;
RT *this;
}
DVCC
Binarization& setRange(CS IS start_x_, CS IS start_y_, CS IS length_) NE {
this->start_x = start_x_;
this->start_y = start_y_;
this->width = length_;
this->height = length_;
RT *this;
}
DVCC
Binarization& setRange(CS IS start_x_, CS IS start_y_, CS IS width_, CS IS height_) NE {
this->start_x = start_x_;
this->start_y = start_y_;
this->width = width_;
this->height = height_;
RT *this;
}
DVCC
Binarization& setRange(CS dtl::base::MatrixRange & matrix_range_) NE {
this->start_x = matrix_range_.x;
this->start_y = matrix_range_.y;
this->width = matrix_range_.w;
this->height = matrix_range_.h;
RT *this;
}
CE Binarization() NE = default;
CE explicit Binarization(CS MI & true_value_) NE
:true_value(true_value_) {}
CE explicit Binarization(CS MI & true_value_, CS MI & false_value_) NE
:true_value(true_value_), false_value(false_value_) {}
CE explicit Binarization(CS dtl::base::MatrixRange & matrix_range_) NE
:start_x(matrix_range_.x), start_y(matrix_range_.y),
width(matrix_range_.w), height(matrix_range_.h) {}
CE explicit Binarization(CS dtl::base::MatrixRange& matrix_range_, CS MI& true_value_) NE
:start_x(matrix_range_.x), start_y(matrix_range_.y),
width(matrix_range_.w), height(matrix_range_.h),
true_value(true_value_) {}
CE explicit Binarization(CS dtl::base::MatrixRange& matrix_range_, CS MI& true_value_, CS MI& false_value_) NE
:start_x(matrix_range_.x), start_y(matrix_range_.y),
width(matrix_range_.w), height(matrix_range_.h),
true_value(true_value_), false_value(false_value_) {}
CE explicit Binarization(CS IS start_x_, CS IS start_y_, CS IS width_, CS IS height_) NE
:start_x(start_x_), start_y(start_y_),
width(width_), height(height_) {}
CE explicit Binarization(CS IS start_x_, CS IS start_y_, CS IS width_, CS IS height_, CS MI & true_value_) NE
:start_x(start_x_), start_y(start_y_),
width(width_), height(height_),
true_value(true_value_) {}
CE explicit Binarization(CS IS start_x_, CS IS start_y_, CS IS width_, CS IS height_, CS MI & true_value_, CS MI & false_value_) NE
:start_x(start_x_), start_y(start_y_),
width(width_), height(height_),
true_value(true_value_), false_value(false_value_) {}
};
}
}
#endif 
#ifndef IDTL_DTL_UTILITY_COPY
#define IDTL_DTL_UTILITY_COPY
NS dtl {
inline NS utility {
NS tool {
TP<TN MI, TN Value_Int_>
DVCC
void castCopyValue(MI& value_, CS Value_Int_& value2_) NE {
value_ = static_cast<MI>(value2_);
}
TP<TN Matrix_>
DVCC
void copyMatrix(Matrix_& matrix_, CS Matrix_& matrix2_) NE {
matrix_ = matrix2_;
}
}
NS stl {
TP<TN Matrix_, TN Matrix2_>
DVCC
void copyMatrix(Matrix_& matrix_, CS Matrix2_& matrix2_) NE {
for (dtl::type::size i{}; i < matrix_.size(); ++i)
for (dtl::type::size j{}; j < matrix_[i].size(); ++j)
matrix_[i][j] = matrix2_[i][j];
}
}
NS normal {
TP<TN Matrix_, TN Matrix2_>
DVCC
void copyMatrix(Matrix_& matrix_, CS Matrix2_& matrix2_, CS dtl::type::size x_, CS dtl::type::size y_) NE {
for (dtl::type::size i{}; i < y_; ++i)
for (dtl::type::size j{}; j < x_; ++j)
matrix_[i][j] = matrix2_[i][j];
}
}
NS array {
TP<TN Matrix_, TN Matrix2_>
DVCC
void copyMatrix(Matrix_& matrix_, CS Matrix2_& matrix2_, CS dtl::type::size x_, CS dtl::type::size y_) NE {
for (dtl::type::size i{}; i < y_; ++i)
for (dtl::type::size j{}; j < x_; ++j)
matrix_[i * x_ + j] = matrix2_[i * x_ + j];
}
}
NS layer {
NS stl {
TP<TN Matrix_, TN Matrix2_>
DVCC
void copyMatrix(Matrix_& matrix_, CS Matrix2_& matrix2_, CS dtl::type::size layer_) NE {
for (dtl::type::size i{}; i < matrix_.size(); ++i)
for (dtl::type::size j{}; j < matrix_[i].size(); ++j)
matrix_[i][j][layer_] = matrix2_[i][j][layer_];
}
}
}
NS layer {
NS normal {
TP<TN Matrix_, TN Matrix2_>
DVCC
void copyMatrix(Matrix_& matrix_, CS Matrix2_& matrix2_, CS dtl::type::size layer_, CS dtl::type::size x_, CS dtl::type::size y_) NE {
for (dtl::type::size i{}; i < y_; ++i)
for (dtl::type::size j{}; j < x_; ++j)
matrix_[i][j][layer_] = matrix2_[i][j][layer_];
}
}
}
}
}
#endif 
#ifndef IDTL_DTL_UTILITY_INIT
#define IDTL_DTL_UTILITY_INIT
NS dtl {
inline NS utility {
TP<TN MI>
class Init {
private:
using IS = dtl::type::size;
IS start_x{};
IS start_y{};
IS width{};
IS height{};
MI draw_value{};
TP<TN Matrix_>
DVCC
inline void substitutionSTL(Matrix_&& matrix_, CS IS point_x_, CS IS point_y_) CS NE {
matrix_[point_y_][point_x_] = this->draw_value;
}
TP<TN Matrix_>
DVCC
inline void substitutionArray(Matrix_&& matrix_, CS IS point_x_, CS IS point_y_, CS IS max_x_) CS NE {
matrix_[point_y_ * max_x_ + point_x_] = this->draw_value;
}
TP<TN Matrix_>
DVCC
inline void substitutionLayer(Matrix_&& matrix_, CS IS layer_, CS IS point_x_, CS IS point_y_) CS NE {
matrix_[point_y_][point_x_][layer_] = this->draw_value;
}
TP<TN Matrix_, TN Function_>
DVCC
inline void substitutionSTL(Matrix_&& matrix_, CS IS point_x_, CS IS point_y_, Function_&& function_) CS NE {
if (function_(matrix_[point_y_][point_x_])) matrix_[point_y_][point_x_] = this->draw_value;
}
TP<TN Matrix_, TN Function_>
DVCC
inline void substitutionArray(Matrix_&& matrix_, CS IS point_x_, CS IS point_y_, CS IS max_x_, Function_&& function_) CS NE {
if (function_(matrix_[point_y_ * max_x_ + point_x_])) matrix_[point_y_ * max_x_ + point_x_] = this->draw_value;
}
TP<TN Matrix_, TN Function_>
DVCC
inline void substitutionLayer(Matrix_ && matrix_, CS IS layer_, CS IS point_x_, CS IS point_y_, Function_ && function_) CS NE {
if (function_(matrix_[point_y_][point_x_][layer_])) matrix_[point_y_][point_x_][layer_] = this->draw_value;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawSTL(Matrix_ && matrix_, CS IS end_y_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i)
for (IS j{ this->start_x }; j < matrix_[i].size(); ++j)
this->substitutionSTL(matrix_, j, i, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawWidthSTL(Matrix_ && matrix_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i)
for (IS j{ this->start_x }; j < matrix_[i].size() && j < end_x_; ++j)
this->substitutionSTL(matrix_, j, i, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawLayerSTL(Matrix_ && matrix_, CS IS layer_, CS IS end_y_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i)
for (IS j{ this->start_x }; j < matrix_[i].size(); ++j)
this->substitutionLayer(matrix_, layer_, j, i, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawLayerWidthSTL(Matrix_ && matrix_, CS IS layer_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i)
for (IS j{ this->start_x }; j < matrix_[i].size() && j < end_x_; ++j)
this->substitutionLayer(matrix_, layer_, j, i, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawNormal(Matrix_ && matrix_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i)
for (IS j{ this->start_x }; j < end_x_; ++j)
this->substitutionSTL(matrix_, j, i, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawLayerNormal(Matrix_ && matrix_, CS IS layer_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i)
for (IS j{ this->start_x }; j < end_x_; ++j)
this->substitutionLayer(matrix_, layer_, j, i, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawArray(Matrix_ && matrix_, CS IS end_x_, CS IS end_y_, CS IS max_x_, Args_ && ... args_) CS NE {
for (IS i{ this->start_y }; i < end_y_; ++i)
for (IS j{ this->start_x }; j < end_x_; ++j)
this->substitutionArray(matrix_, j, i, max_x_, args_...);
RT true;
}
public:
DVCN
CE IS getPointX() CS NE {
RT this->start_x;
}
DVCN
CE IS getPointY() CS NE {
RT this->start_y;
}
DVCN
CE IS getWidth() CS NE {
RT this->width;
}
DVCN
CE IS getHeight() CS NE {
RT this->height;
}
DVCN
CE MI getValue() CS NE {
RT this->draw_value;
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_) CS NE {
RT (this->width == 0) ? this->drawSTL(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height) : this->drawWidthSTL(matrix_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, Function_ && function_) CS NE {
RT (this->width == 0) ? this->drawSTL(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_) : this->drawWidthSTL(matrix_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_, CS IS layer_) CS NE {
RT (this->width == 0) ? this->drawLayerSTL(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height) : this->drawLayerWidthSTL(matrix_, layer_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, CS IS layer_, Function_ && function_) CS NE {
RT (this->width == 0) ? this->drawLayerSTL(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_) : this->drawLayerWidthSTL(matrix_, layer_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_) CS NE {
RT this->drawNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_, Function_ && function_) CS NE {
RT this->drawNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_, CS IS layer_, CS IS max_x_, CS IS max_y_) CS NE {
RT this->drawLayerNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, CS IS layer_, CS IS max_x_, CS IS max_y_, Function_ && function_) CS NE {
RT this->drawLayerNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL drawArray(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_) CS NE {
RT this->drawArray(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, max_x_);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperatorArray(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_, Function_ && function_) CS NE {
RT this->drawArray(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, max_x_, function_);
}
TP<TN Matrix_, TN ...Args_>
CE BL operator()(Matrix_ && matrix_, Args_ && ... args_) CS NE {
RT this->draw(DTL_TYPE_FORWARD<Matrix_>(matrix_), DTL_TYPE_FORWARD<Args_>(args_)...);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& create(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->draw(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createArray(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->drawArray(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createOperator(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->drawOperator(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createOperatorArray(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->drawOperatorArray(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
DVCC
Init& clearPointX() NE {
this->start_x = 0;
RT *this;
}
DVCC
Init& clearPointY() NE {
this->start_y = 0;
RT *this;
}
DVCC
Init& clearWidth() NE {
this->width = 0;
RT *this;
}
DVCC
Init& clearHeight() NE {
this->height = 0;
RT *this;
}
DVCC
Init& clearValue() NE {
CS MI new_draw_value{};
this->draw_value = new_draw_value;
RT *this;
}
DVCC
Init& clearPoint() NE {
this->clearPointX();
this->clearPointY();
RT *this;
}
DVCC
Init& clearRange() NE {
this->clearPointX();
this->clearPointY();
this->clearWidth();
this->clearHeight();
RT *this;
}
DVCC
Init& clear() NE {
this->clearRange();
this->clearValue();
RT *this;
}
DVCC
Init& setPointX(CS IS start_x_) NE {
this->start_x = start_x_;
RT *this;
}
DVCC
Init& setPointY(CS IS start_y_) NE {
this->start_y = start_y_;
RT *this;
}
DVCC
Init& setWidth(CS IS width_) NE {
this->width = width_;
RT *this;
}
DVCC
Init& setHeight(CS IS height_) NE {
this->height = height_;
RT *this;
}
DVCC
Init& setValue(CS MI & draw_value_) NE {
this->draw_value = draw_value_;
RT *this;
}
DVCC
Init& setPoint(CS IS point_) NE {
this->start_x = point_;
this->start_y = point_;
RT *this;
}
DVCC
Init& setPoint(CS IS start_x_, CS IS start_y_) NE {
this->start_x = start_x_;
this->start_y = start_y_;
RT *this;
}
DVCC
Init& setRange(CS IS start_x_, CS IS start_y_, CS IS length_) NE {
this->start_x = start_x_;
this->start_y = start_y_;
this->width = length_;
this->height = length_;
RT *this;
}
DVCC
Init& setRange(CS IS start_x_, CS IS start_y_, CS IS width_, CS IS height_) NE {
this->start_x = start_x_;
this->start_y = start_y_;
this->width = width_;
this->height = height_;
RT *this;
}
DVCC
Init& setRange(CS dtl::base::MatrixRange & matrix_range_) NE {
this->start_x = matrix_range_.x;
this->start_y = matrix_range_.y;
this->width = matrix_range_.w;
this->height = matrix_range_.h;
RT *this;
}
CE Init() NE = default;
CE explicit Init(CS MI & draw_value_) NE
:draw_value(draw_value_) {}
CE explicit Init(CS dtl::base::MatrixRange & matrix_range_) NE
:start_x(matrix_range_.x), start_y(matrix_range_.y),
width(matrix_range_.w), height(matrix_range_.h) {}
CE explicit Init(CS dtl::base::MatrixRange & matrix_range_, CS MI & draw_value_) NE
:start_x(matrix_range_.x), start_y(matrix_range_.y),
width(matrix_range_.w), height(matrix_range_.h),
draw_value(draw_value_) {}
CE explicit Init(CS IS start_x_, CS IS start_y_, CS IS width_, CS IS height_) NE
:start_x(start_x_), start_y(start_y_),
width(width_), height(height_) {}
CE explicit Init(CS IS start_x_, CS IS start_y_, CS IS width_, CS IS height_, CS MI & draw_value_) NE
:start_x(start_x_), start_y(start_y_),
width(width_), height(height_),
draw_value(draw_value_) {}
};
}
}
#endif 
#ifndef IDTL_DTL_UTILITY_NOISE_BOOL
#define IDTL_DTL_UTILITY_NOISE_BOOL
NS dtl {
inline NS utility {
NS stl {
TP<TN Matrix_>
DVCC
void noiseBool(Matrix_& matrix_) NE {
using dtl::random::mersenne_twister_32bit;
for (dtl::type::size i{}; i < matrix_.size(); ++i)
for (dtl::type::size j{}; j < matrix_[i].size(); ++j) {
if (!mersenne_twister_32bit.probability()) continue;
if (matrix_[i][j]) matrix_[i][j] = false;
else matrix_[i][j] = true;
}
}
TP<TN Matrix_>
DVCC
void noiseBool(Matrix_& matrix_, CS double rBL_) NE {
using dtl::random::mersenne_twister_32bit;
for (dtl::type::size i{}; i < matrix_.size(); ++i)
for (dtl::type::size j{}; j < matrix_[i].size(); ++j) {
if (!mersenne_twister_32bit.probability(rBL_)) continue;
if (matrix_[i][j]) matrix_[i][j] = false;
else matrix_[i][j] = true;
}
}
TP<TN True_Int_, TN False_Int_, TN Matrix_>
DVCC
void noiseBool(Matrix_& matrix_, CS double rBL_, CS True_Int_ true_tile_, CS False_Int_ false_tile_ = 0) NE {
using dtl::random::mersenne_twister_32bit;
for (dtl::type::size i{}; i < matrix_.size(); ++i)
for (dtl::type::size j{}; j < matrix_[i].size(); ++j) {
if (!mersenne_twister_32bit.probability(rBL_)) continue;
if (matrix_[i][j]) dtl::utility::tool::castCopyValue(matrix_[i][j], false_tile_);
else dtl::utility::tool::castCopyValue(matrix_[i][j], true_tile_);
}
}
}
NS normal {
TP<TN Matrix_>
DVCC
void noiseBool(Matrix_& matrix_, CS dtl::type::size, CS dtl::type::size y_) NE {
using dtl::random::mersenne_twister_32bit;
for (dtl::type::size i{}; i < y_; ++i)
for (dtl::type::size j{}; j < y_; ++j) {
if (!mersenne_twister_32bit.probability()) continue;
if (matrix_[i][j]) matrix_[i][j] = false;
else matrix_[i][j] = true;
}
}
TP<TN Matrix_>
DVCC
void noiseBool(Matrix_& matrix_, CS dtl::type::size, CS dtl::type::size y_, CS double rBL_) NE {
using dtl::random::mersenne_twister_32bit;
for (dtl::type::size i{}; i < y_; ++i)
for (dtl::type::size j{}; j < y_; ++j) {
if (!mersenne_twister_32bit.probability(rBL_)) continue;
if (matrix_[i][j]) matrix_[i][j] = false;
else matrix_[i][j] = true;
}
}
TP<TN True_Int_, TN False_Int_, TN Matrix_>
DVCC
void noiseBool(Matrix_& matrix_, CS dtl::type::size, CS dtl::type::size y_, CS double rBL_, CS True_Int_ true_tile_, CS False_Int_ false_tile_ = 0) NE {
using dtl::random::mersenne_twister_32bit;
for (dtl::type::size i{}; i < y_; ++i)
for (dtl::type::size j{}; j < y_; ++j) {
if (!mersenne_twister_32bit.probability(rBL_)) continue;
if (matrix_[i][j]) dtl::utility::tool::castCopyValue(matrix_[i][j], false_tile_);
else dtl::utility::tool::castCopyValue(matrix_[i][j], true_tile_);
}
}
}
NS array {
TP<TN Matrix_>
DVCC
void noiseBool(Matrix_& matrix_, CS dtl::type::size x_, CS dtl::type::size y_) NE {
using dtl::random::mersenne_twister_32bit;
for (dtl::type::size i{}; i < y_; ++i)
for (dtl::type::size j{}; j < y_; ++j) {
if (!mersenne_twister_32bit.probability()) continue;
if (matrix_[i * x_ + j]) matrix_[i * x_ + j] = false;
else matrix_[i * x_ + j] = true;
}
}
TP<TN Matrix_>
DVCC
void noiseBool(Matrix_ & matrix_, CS dtl::type::size x_, CS dtl::type::size y_, CS double rBL_) NE {
using dtl::random::mersenne_twister_32bit;
for (dtl::type::size i{}; i < y_; ++i)
for (dtl::type::size j{}; j < y_; ++j) {
if (!mersenne_twister_32bit.probability(rBL_)) continue;
if (matrix_[i * x_ + j]) matrix_[i * x_ + j] = false;
else matrix_[i * x_ + j] = true;
}
}
TP<TN True_Int_, TN False_Int_, TN Matrix_>
DVCC
void noiseBool(Matrix_ & matrix_, CS dtl::type::size x_, CS dtl::type::size y_, CS double rBL_, CS True_Int_ true_tile_, CS False_Int_ false_tile_ = 0) NE {
using dtl::random::mersenne_twister_32bit;
for (dtl::type::size i{}; i < y_; ++i)
for (dtl::type::size j{}; j < y_; ++j) {
if (!mersenne_twister_32bit.probability(rBL_)) continue;
if (matrix_[i * x_ + j]) dtl::utility::tool::castCopyValue(matrix_[i * x_ + j], false_tile_);
else dtl::utility::tool::castCopyValue(matrix_[i * x_ + j], true_tile_);
}
}
}
NS rangeBasedFor {
TP<TN Matrix_>
DVCC
void noiseBool(Matrix_& matrix_) NE {
using dtl::random::mersenne_twister_32bit;
for (auto&& i : matrix_)
for (auto&& j : i) {
if (!mersenne_twister_32bit.probability()) continue;
if (j) j = false;
else j = true;
}
}
TP<TN Matrix_>
DVCC
void noiseBool(Matrix_& matrix_, CS double rBL_) NE {
using dtl::random::mersenne_twister_32bit;
for (auto&& i : matrix_)
for (auto&& j : i) {
if (!mersenne_twister_32bit.probability(rBL_)) continue;
if (j) j = false;
else j = true;
}
}
TP<TN True_Int_, TN False_Int_, TN Matrix_>
DVCC
void noiseBool(Matrix_& matrix_, CS double rBL_, CS True_Int_ true_tile_, CS False_Int_ false_tile_ = 0) NE {
using dtl::random::mersenne_twister_32bit;
for (auto&& i : matrix_)
for (auto&& j : i) {
if (!mersenne_twister_32bit.probability(rBL_)) continue;
if (j) dtl::utility::tool::castCopyValue(j, false_tile_);
else dtl::utility::tool::castCopyValue(j, true_tile_);
}
}
}
NS layer {
NS stl {
TP<TN Matrix_>
DVCC
void noiseBool(Matrix_& matrix_, CS dtl::type::size layer_) NE {
using dtl::random::mersenne_twister_32bit;
for (dtl::type::size i{}; i < matrix_.size(); ++i)
for (dtl::type::size j{}; j < matrix_[i].size(); ++j) {
if (!mersenne_twister_32bit.probability()) continue;
if (matrix_[i][j][layer_]) matrix_[i][j][layer_] = false;
else matrix_[i][j][layer_] = true;
}
}
TP<TN Matrix_>
DVCC
void noiseBool(Matrix_& matrix_, CS dtl::type::size layer_, CS double rBL_) NE {
using dtl::random::mersenne_twister_32bit;
for (dtl::type::size i{}; i < matrix_.size(); ++i)
for (dtl::type::size j{}; j < matrix_[i].size(); ++j) {
if (!mersenne_twister_32bit.probability(rBL_)) continue;
if (matrix_[i][j][layer_]) matrix_[i][j][layer_] = false;
else matrix_[i][j][layer_] = true;
}
}
TP<TN True_Int_, TN False_Int_, TN Matrix_>
DVCC
void noiseBool(Matrix_& matrix_, CS dtl::type::size layer_, CS double rBL_, CS True_Int_ true_tile_, CS False_Int_ false_tile_ = 0) NE {
using dtl::random::mersenne_twister_32bit;
for (dtl::type::size i{}; i < matrix_.size(); ++i)
for (dtl::type::size j{}; j < matrix_[i].size(); ++j) {
if (!mersenne_twister_32bit.probability(rBL_)) continue;
if (matrix_[i][j][layer_]) dtl::utility::tool::castCopyValue(matrix_[i][j][layer_], false_tile_);
else dtl::utility::tool::castCopyValue(matrix_[i][j][layer_], true_tile_);
}
}
}
}
NS layer {
NS normal {
TP<TN Matrix_>
DVCC
void noiseBool(Matrix_& matrix_, CS dtl::type::size layer_, CS dtl::type::size, CS dtl::type::size y_) NE {
using dtl::random::mersenne_twister_32bit;
for (dtl::type::size i{}; i < y_; ++i)
for (dtl::type::size j{}; j < y_; ++j) {
if (!mersenne_twister_32bit.probability()) continue;
if (matrix_[i][j][layer_]) matrix_[i][j][layer_] = false;
else matrix_[i][j][layer_] = true;
}
}
TP<TN Matrix_>
DVCC
void noiseBool(Matrix_& matrix_, CS dtl::type::size layer_, CS dtl::type::size, CS dtl::type::size y_, CS double rBL_) NE {
using dtl::random::mersenne_twister_32bit;
for (dtl::type::size i{}; i < y_; ++i)
for (dtl::type::size j{}; j < y_; ++j) {
if (!mersenne_twister_32bit.probability(rBL_)) continue;
if (matrix_[i][j][layer_]) matrix_[i][j][layer_] = false;
else matrix_[i][j][layer_] = true;
}
}
TP<TN True_Int_, TN False_Int_, TN Matrix_>
DVCC
void noiseBool(Matrix_& matrix_, CS dtl::type::size layer_, CS dtl::type::size, CS dtl::type::size y_, CS double rBL_, CS True_Int_ true_tile_, CS False_Int_ false_tile_ = 0) NE {
using dtl::random::mersenne_twister_32bit;
for (dtl::type::size i{}; i < y_; ++i)
for (dtl::type::size j{}; j < y_; ++j) {
if (!mersenne_twister_32bit.probability(rBL_)) continue;
if (matrix_[i][j][layer_]) dtl::utility::tool::castCopyValue(matrix_[i][j][layer_], false_tile_);
else dtl::utility::tool::castCopyValue(matrix_[i][j][layer_], true_tile_);
}
}
}
}
}
}
#endif 
#ifndef IDTL_DTL_UTILITY_NOISE_SHORE_BOOL
#define IDTL_DTL_UTILITY_NOISE_SHORE_BOOL
NS dtl {
inline NS utility {
NS tool {
TP<TN MI>
DVCN
CE BL isNoise_noiseShoreBool(CS MI value_, CS MI value2_, CS MI value3_) NE {
using dtl::random::mersenne_twister_32bit;
RT (value_ != value2_ || value_ != value3_) && mersenne_twister_32bit.probability();
}
TP<TN MI>
DVCN
CE BL isNoise_noiseShoreBool(CS MI value_, CS MI value2_, CS MI value3_, CS double rBL_) NE {
using dtl::random::mersenne_twister_32bit;
RT (value_ != value2_ || value_ != value3_) && mersenne_twister_32bit.probability(rBL_);
}
}
NS stl {
TP<TN Matrix_>
DVCC
void noiseShoreBool(Matrix_& matrix_) NE {
using dtl::random::mersenne_twister_32bit;
using dtl::utility::tool::isNoise_noiseShoreBool;
for (dtl::type::size i{ 1 }; i < matrix_.size(); ++i)
for (dtl::type::size j{ 1 }; j < matrix_[i].size(); ++j) {
if (!isNoise_noiseShoreBool(matrix_[i][j], matrix_[i][j - 1], matrix_[i - 1][j])) continue;
if (matrix_[i][j]) matrix_[i][j] = false;
else matrix_[i][j] = true;
}
}
TP<TN Matrix_>
DVCC
void noiseShoreBool(Matrix_ & matrix_, CS double rBL_) NE {
using dtl::random::mersenne_twister_32bit;
using dtl::utility::tool::isNoise_noiseShoreBool;
for (dtl::type::size i{ 1 }; i < matrix_.size(); ++i)
for (dtl::type::size j{ 1 }; j < matrix_[i].size(); ++j) {
if (!isNoise_noiseShoreBool(matrix_[i][j], matrix_[i][j - 1], matrix_[i - 1][j], rBL_)) continue;
if (matrix_[i][j]) matrix_[i][j] = false;
else matrix_[i][j] = true;
}
}
TP<TN MI, TN Matrix_>
DVCC
void noiseShoreBool(Matrix_ & matrix_, CS double rBL_, CS MI true_tile_, CS MI false_tile_ = 0) NE {
using dtl::random::mersenne_twister_32bit;
using dtl::utility::tool::isNoise_noiseShoreBool;
for (dtl::type::size i{ 1 }; i < matrix_.size(); ++i)
for (dtl::type::size j{ 1 }; j < matrix_[i].size(); ++j) {
if (!isNoise_noiseShoreBool(matrix_[i][j], matrix_[i][j - 1], matrix_[i - 1][j], rBL_)) continue;
if (matrix_[i][j]) matrix_[i][j] = false_tile_;
else matrix_[i][j] = true_tile_;
}
}
TP<TN Matrix_>
DVCC
void rnoiseShoreBool(Matrix_ & matrix_) NE {
using dtl::random::mersenne_twister_32bit;
using dtl::utility::tool::isNoise_noiseShoreBool;
for (dtl::type::size i{ matrix_.size() - 1 }; i >= 1; --i)
for (dtl::type::size j{ matrix_[i].size() - 1 }; j >= 1; --j) {
if (!isNoise_noiseShoreBool(matrix_[i - 1][j - 1], matrix_[i][j - 1], matrix_[i - 1][j])) continue;
if (matrix_[i - 1][j - 1]) matrix_[i - 1][j - 1] = false;
else matrix_[i - 1][j - 1] = true;
}
}
TP<TN Matrix_>
DVCC
void rnoiseShoreBool(Matrix_ & matrix_, CS double rBL_) NE {
using dtl::random::mersenne_twister_32bit;
using dtl::utility::tool::isNoise_noiseShoreBool;
for (dtl::type::size i{ matrix_.size() - 1 }; i >= 1; --i)
for (dtl::type::size j{ matrix_[i].size() - 1 }; j >= 1; --j) {
if (!isNoise_noiseShoreBool(matrix_[i - 1][j - 1], matrix_[i][j - 1], matrix_[i - 1][j], rBL_)) continue;
if (matrix_[i - 1][j - 1]) matrix_[i - 1][j - 1] = false;
else matrix_[i - 1][j - 1] = true;
}
}
TP<TN MI, TN Matrix_>
DVCC
void rnoiseShoreBool(Matrix_ & matrix_, CS double rBL_, CS MI true_tile_, CS MI false_tile_ = 0) NE {
using dtl::random::mersenne_twister_32bit;
using dtl::utility::tool::isNoise_noiseShoreBool;
for (dtl::type::size i{ matrix_.size() - 1 }; i >= 1; --i)
for (dtl::type::size j{ matrix_[i].size() - 1 }; j >= 1; --j) {
if (!isNoise_noiseShoreBool(matrix_[i - 1][j - 1], matrix_[i][j - 1], matrix_[i - 1][j], rBL_)) continue;
if (matrix_[i - 1][j - 1]) matrix_[i - 1][j - 1] = false_tile_;
else matrix_[i - 1][j - 1] = true_tile_;
}
}
TP<TN Matrix_>
DVCC
void noiseShoreBothBool(Matrix_ & matrix_) NE {
dtl::utility::stl::noiseShoreBool(matrix_);
dtl::utility::stl::rnoiseShoreBool(matrix_);
}
TP<TN Matrix_>
DVCC
void noiseShoreBothBool(Matrix_ & matrix_, CS double rBL_) NE {
dtl::utility::stl::noiseShoreBool(matrix_, rBL_);
dtl::utility::stl::rnoiseShoreBool(matrix_, rBL_);
}
TP<TN Matrix_>
DVCC
void noiseShoreBothBool(Matrix_ & matrix_, CS double rBL1_, CS double rBL2_) NE {
dtl::utility::stl::noiseShoreBool(matrix_, rBL1_);
dtl::utility::stl::rnoiseShoreBool(matrix_, rBL2_);
}
TP<TN Matrix_>
DVCC
void rnoiseShoreBothBool(Matrix_ & matrix_) NE {
dtl::utility::stl::rnoiseShoreBool(matrix_);
dtl::utility::stl::noiseShoreBool(matrix_);
}
TP<TN Matrix_>
DVCC
void rnoiseShoreBothBool(Matrix_ & matrix_, CS double rBL_) NE {
dtl::utility::stl::rnoiseShoreBool(matrix_, rBL_);
dtl::utility::stl::noiseShoreBool(matrix_, rBL_);
}
TP<TN Matrix_>
DVCC
void rnoiseShoreBothBool(Matrix_ & matrix_, CS double rBL1_, CS double rBL2_) NE {
dtl::utility::stl::rnoiseShoreBool(matrix_, rBL1_);
dtl::utility::stl::noiseShoreBool(matrix_, rBL2_);
}
}
NS normal {
TP<TN Matrix_>
DVCC
void noiseShoreBool(Matrix_& matrix_, CS dtl::type::size x_, CS dtl::type::size y_) NE {
using dtl::random::mersenne_twister_32bit;
using dtl::utility::tool::isNoise_noiseShoreBool;
for (dtl::type::size i{ 1 }; i < y_; ++i)
for (dtl::type::size j{ 1 }; j < x_; ++j) {
if (!isNoise_noiseShoreBool(matrix_[i][j], matrix_[i][j - 1], matrix_[i - 1][j])) continue;
if (matrix_[i][j]) matrix_[i][j] = false;
else matrix_[i][j] = true;
}
}
TP<TN Matrix_>
DVCC
void noiseShoreBool(Matrix_ & matrix_, CS dtl::type::size x_, CS dtl::type::size y_, CS double rBL_) NE {
using dtl::random::mersenne_twister_32bit;
using dtl::utility::tool::isNoise_noiseShoreBool;
for (dtl::type::size i{ 1 }; i < y_; ++i)
for (dtl::type::size j{ 1 }; j < x_; ++j) {
if (!isNoise_noiseShoreBool(matrix_[i][j], matrix_[i][j - 1], matrix_[i - 1][j], rBL_)) continue;
if (matrix_[i][j]) matrix_[i][j] = false;
else matrix_[i][j] = true;
}
}
TP<TN MI, TN Matrix_>
DVCC
void noiseShoreBool(Matrix_ & matrix_, CS dtl::type::size x_, CS dtl::type::size y_, CS double rBL_, CS MI true_tile_, CS MI false_tile_ = 0) NE {
using dtl::random::mersenne_twister_32bit;
using dtl::utility::tool::isNoise_noiseShoreBool;
for (dtl::type::size i{ 1 }; i < y_; ++i)
for (dtl::type::size j{ 1 }; j < x_; ++j) {
if (!isNoise_noiseShoreBool(matrix_[i][j], matrix_[i][j - 1], matrix_[i - 1][j], rBL_)) continue;
if (matrix_[i][j]) matrix_[i][j] = false_tile_;
else matrix_[i][j] = true_tile_;
}
}
TP<TN Matrix_>
DVCC
void rnoiseShoreBool(Matrix_ & matrix_, CS dtl::type::size x_, CS dtl::type::size y_) NE {
using dtl::random::mersenne_twister_32bit;
using dtl::utility::tool::isNoise_noiseShoreBool;
for (dtl::type::size i{ y_ - 1 }; i >= 1; --i)
for (dtl::type::size j{ x_ - 1 }; j >= 1; --j) {
if (!isNoise_noiseShoreBool(matrix_[i - 1][j - 1], matrix_[i][j - 1], matrix_[i - 1][j])) continue;
if (matrix_[i - 1][j - 1]) matrix_[i - 1][j - 1] = false;
else matrix_[i - 1][j - 1] = true;
}
}
TP<TN Matrix_>
DVCC
void rnoiseShoreBool(Matrix_ & matrix_, CS dtl::type::size x_, CS dtl::type::size y_, CS double rBL_) NE {
using dtl::random::mersenne_twister_32bit;
using dtl::utility::tool::isNoise_noiseShoreBool;
for (dtl::type::size i{ y_ - 1 }; i >= 1; --i)
for (dtl::type::size j{ x_ - 1 }; j >= 1; --j) {
if (!isNoise_noiseShoreBool(matrix_[i - 1][j - 1], matrix_[i][j - 1], matrix_[i - 1][j], rBL_)) continue;
if (matrix_[i - 1][j - 1]) matrix_[i - 1][j - 1] = false;
else matrix_[i - 1][j - 1] = true;
}
}
TP<TN MI, TN Matrix_>
DVCC
void rnoiseShoreBool(Matrix_ & matrix_, CS dtl::type::size x_, CS dtl::type::size y_, CS double rBL_, CS MI true_tile_, CS MI false_tile_ = 0) NE {
using dtl::random::mersenne_twister_32bit;
using dtl::utility::tool::isNoise_noiseShoreBool;
for (dtl::type::size i{ y_ - 1 }; i >= 1; --i)
for (dtl::type::size j{ x_ - 1 }; j >= 1; --j) {
if (!isNoise_noiseShoreBool(matrix_[i - 1][j - 1], matrix_[i][j - 1], matrix_[i - 1][j], rBL_)) continue;
if (matrix_[i - 1][j - 1]) matrix_[i - 1][j - 1] = false_tile_;
else matrix_[i - 1][j - 1] = true_tile_;
}
}
TP<TN Matrix_>
DVCC
void noiseShoreBothBool(Matrix_ & matrix_, CS dtl::type::size x_, CS dtl::type::size y_) NE {
dtl::utility::normal::noiseShoreBool(matrix_, x_, y_);
dtl::utility::normal::rnoiseShoreBool(matrix_, x_, y_);
}
TP<TN Matrix_>
DVCC
void noiseShoreBothBool(Matrix_ & matrix_, CS dtl::type::size x_, CS dtl::type::size y_, CS double rBL_) NE {
dtl::utility::normal::noiseShoreBool(matrix_, x_, y_, rBL_);
dtl::utility::normal::rnoiseShoreBool(matrix_, x_, y_, rBL_);
}
TP<TN Matrix_>
DVCC
void noiseShoreBothBool(Matrix_ & matrix_, CS dtl::type::size x_, CS dtl::type::size y_, CS double rBL1_, CS double rBL2_) NE {
dtl::utility::normal::noiseShoreBool(matrix_, x_, y_, rBL1_);
dtl::utility::normal::rnoiseShoreBool(matrix_, x_, y_, rBL2_);
}
TP<TN Matrix_>
DVCC
void rnoiseShoreBothBool(Matrix_ & matrix_, CS dtl::type::size x_, CS dtl::type::size y_) NE {
dtl::utility::normal::rnoiseShoreBool(matrix_, x_, y_);
dtl::utility::normal::noiseShoreBool(matrix_, x_, y_);
}
TP<TN Matrix_>
DVCC
void rnoiseShoreBothBool(Matrix_ & matrix_, CS dtl::type::size x_, CS dtl::type::size y_, CS double rBL_) NE {
dtl::utility::normal::rnoiseShoreBool(matrix_, x_, y_, rBL_);
dtl::utility::normal::noiseShoreBool(matrix_, x_, y_, rBL_);
}
TP<TN Matrix_>
DVCC
void rnoiseShoreBothBool(Matrix_ & matrix_, CS dtl::type::size x_, CS dtl::type::size y_, CS double rBL1_, CS double rBL2_) NE {
dtl::utility::normal::rnoiseShoreBool(matrix_, x_, y_, rBL1_);
dtl::utility::normal::noiseShoreBool(matrix_, x_, y_, rBL2_);
}
}
NS array {
TP<TN Matrix_>
DVCC
void noiseShoreBool(Matrix_& matrix_, CS dtl::type::size x_, CS dtl::type::size y_) NE {
using dtl::random::mersenne_twister_32bit;
using dtl::utility::tool::isNoise_noiseShoreBool;
for (dtl::type::size i{ 1 }; i < y_; ++i)
for (dtl::type::size j{ 1 }; j < x_; ++j) {
if (!isNoise_noiseShoreBool(matrix_[(i)* x_ + (j)], matrix_[(i)* x_ + (j - 1)], matrix_[(i - 1) * x_ + (j)])) continue;
if (matrix_[(i)* x_ + (j)]) matrix_[(i)* x_ + (j)] = false;
else matrix_[(i)* x_ + (j)] = true;
}
}
TP<TN Matrix_>
DVCC
void noiseShoreBool(Matrix_ & matrix_, CS dtl::type::size x_, CS dtl::type::size y_, CS double rBL_) NE {
using dtl::random::mersenne_twister_32bit;
using dtl::utility::tool::isNoise_noiseShoreBool;
for (dtl::type::size i{ 1 }; i < y_; ++i)
for (dtl::type::size j{ 1 }; j < x_; ++j) {
if (!isNoise_noiseShoreBool(matrix_[(i)* x_ + (j)], matrix_[(i)* x_ + (j - 1)], matrix_[(i - 1) * x_ + (j)], rBL_)) continue;
if (matrix_[(i)* x_ + (j)]) matrix_[(i)* x_ + (j)] = false;
else matrix_[(i)* x_ + (j)] = true;
}
}
TP<TN MI, TN Matrix_>
DVCC
void noiseShoreBool(Matrix_ & matrix_, CS dtl::type::size x_, CS dtl::type::size y_, CS double rBL_, CS MI true_tile_, CS MI false_tile_ = 0) NE {
using dtl::random::mersenne_twister_32bit;
using dtl::utility::tool::isNoise_noiseShoreBool;
for (dtl::type::size i{ 1 }; i < y_; ++i)
for (dtl::type::size j{ 1 }; j < x_; ++j) {
if (!isNoise_noiseShoreBool(matrix_[(i)* x_ + (j)], matrix_[(i)* x_ + (j - 1)], matrix_[(i - 1) * x_ + (j)], rBL_)) continue;
if (matrix_[(i)* x_ + (j)]) matrix_[(i)* x_ + (j)] = false_tile_;
else matrix_[(i)* x_ + (j)] = true_tile_;
}
}
TP<TN Matrix_>
DVCC
void rnoiseShoreBool(Matrix_ & matrix_, CS dtl::type::size x_, CS dtl::type::size y_) NE {
using dtl::random::mersenne_twister_32bit;
using dtl::utility::tool::isNoise_noiseShoreBool;
for (dtl::type::size i{ y_ - 1 }; i >= 1; --i)
for (dtl::type::size j{ x_ - 1 }; j >= 1; --j) {
if (!isNoise_noiseShoreBool(matrix_[(i - 1) * x_ + (j - 1)], matrix_[(i)* x_ + (j - 1)], matrix_[(i - 1) * x_ + (j)])) continue;
if (matrix_[(i - 1) * x_ + (j - 1)]) matrix_[(i - 1) * x_ + (j - 1)] = false;
else matrix_[(i - 1) * x_ + (j - 1)] = true;
}
}
TP<TN Matrix_>
DVCC
void rnoiseShoreBool(Matrix_ & matrix_, CS dtl::type::size x_, CS dtl::type::size y_, CS double rBL_) NE {
using dtl::random::mersenne_twister_32bit;
using dtl::utility::tool::isNoise_noiseShoreBool;
for (dtl::type::size i{ y_ - 1 }; i >= 1; --i)
for (dtl::type::size j{ x_ - 1 }; j >= 1; --j) {
if (!isNoise_noiseShoreBool(matrix_[(i - 1) * x_ + (j - 1)], matrix_[(i)* x_ + (j - 1)], matrix_[(i - 1) * x_ + (j)], rBL_)) continue;
if (matrix_[(i - 1) * x_ + (j - 1)]) matrix_[(i - 1) * x_ + (j - 1)] = false;
else matrix_[(i - 1) * x_ + (j - 1)] = true;
}
}
TP<TN MI, TN Matrix_>
DVCC
void rnoiseShoreBool(Matrix_ & matrix_, CS dtl::type::size x_, CS dtl::type::size y_, CS double rBL_, CS MI true_tile_, CS MI false_tile_ = 0) NE {
using dtl::random::mersenne_twister_32bit;
using dtl::utility::tool::isNoise_noiseShoreBool;
for (dtl::type::size i{ y_ - 1 }; i >= 1; --i)
for (dtl::type::size j{ x_ - 1 }; j >= 1; --j) {
if (!isNoise_noiseShoreBool(matrix_[(i - 1) * x_ + (j - 1)], matrix_[(i)* x_ + (j - 1)], matrix_[(i - 1) * x_ + (j)], rBL_)) continue;
if (matrix_[(i - 1) * x_ + (j - 1)]) matrix_[(i - 1) * x_ + (j - 1)] = false_tile_;
else matrix_[(i - 1) * x_ + (j - 1)] = true_tile_;
}
}
TP<TN Matrix_>
DVCC
void noiseShoreBothBool(Matrix_ & matrix_, CS dtl::type::size x_, CS dtl::type::size y_) NE {
dtl::utility::array::noiseShoreBool(matrix_, x_, y_);
dtl::utility::array::rnoiseShoreBool(matrix_, x_, y_);
}
TP<TN Matrix_>
DVCC
void noiseShoreBothBool(Matrix_ & matrix_, CS dtl::type::size x_, CS dtl::type::size y_, CS double rBL_) NE {
dtl::utility::array::noiseShoreBool(matrix_, x_, y_, rBL_);
dtl::utility::array::rnoiseShoreBool(matrix_, x_, y_, rBL_);
}
TP<TN Matrix_>
DVCC
void noiseShoreBothBool(Matrix_ & matrix_, CS dtl::type::size x_, CS dtl::type::size y_, CS double rBL1_, CS double rBL2_) NE {
dtl::utility::array::noiseShoreBool(matrix_, x_, y_, rBL1_);
dtl::utility::array::rnoiseShoreBool(matrix_, x_, y_, rBL2_);
}
TP<TN Matrix_>
DVCC
void rnoiseShoreBothBool(Matrix_ & matrix_, CS dtl::type::size x_, CS dtl::type::size y_) NE {
dtl::utility::array::rnoiseShoreBool(matrix_, x_, y_);
dtl::utility::array::noiseShoreBool(matrix_, x_, y_);
}
TP<TN Matrix_>
DVCC
void rnoiseShoreBothBool(Matrix_ & matrix_, CS dtl::type::size x_, CS dtl::type::size y_, CS double rBL_) NE {
dtl::utility::array::rnoiseShoreBool(matrix_, x_, y_, rBL_);
dtl::utility::array::noiseShoreBool(matrix_, x_, y_, rBL_);
}
TP<TN Matrix_>
DVCC
void rnoiseShoreBothBool(Matrix_ & matrix_, CS dtl::type::size x_, CS dtl::type::size y_, CS double rBL1_, CS double rBL2_) NE {
dtl::utility::array::rnoiseShoreBool(matrix_, x_, y_, rBL1_);
dtl::utility::array::noiseShoreBool(matrix_, x_, y_, rBL2_);
}
}
NS layer {
NS stl {
TP<TN Matrix_>
DVCC
void noiseShoreBool(Matrix_& matrix_, CS dtl::type::size layer_) NE {
using dtl::random::mersenne_twister_32bit;
using dtl::utility::tool::isNoise_noiseShoreBool;
for (dtl::type::size i{ 1 }; i < matrix_.size(); ++i)
for (dtl::type::size j{ 1 }; j < matrix_[i].size(); ++j) {
if (!isNoise_noiseShoreBool(matrix_[i][j][layer_], matrix_[i][j - 1][layer_], matrix_[i - 1][j][layer_])) continue;
if (matrix_[i][j][layer_]) matrix_[i][j][layer_] = false;
else matrix_[i][j][layer_] = true;
}
}
TP<TN Matrix_>
DVCC
void noiseShoreBool(Matrix_ & matrix_, CS dtl::type::size layer_, CS double rBL_) NE {
using dtl::random::mersenne_twister_32bit;
using dtl::utility::tool::isNoise_noiseShoreBool;
for (dtl::type::size i{ 1 }; i < matrix_.size(); ++i)
for (dtl::type::size j{ 1 }; j < matrix_[i].size(); ++j) {
if (!isNoise_noiseShoreBool(matrix_[i][j][layer_], matrix_[i][j - 1][layer_], matrix_[i - 1][j][layer_], rBL_)) continue;
if (matrix_[i][j][layer_]) matrix_[i][j][layer_] = false;
else matrix_[i][j][layer_] = true;
}
}
TP<TN MI, TN Matrix_>
DVCC
void noiseShoreBool(Matrix_ & matrix_, CS dtl::type::size layer_, CS double rBL_, CS MI true_tile_, CS MI false_tile_ = 0) NE {
using dtl::random::mersenne_twister_32bit;
using dtl::utility::tool::isNoise_noiseShoreBool;
for (dtl::type::size i{ 1 }; i < matrix_.size(); ++i)
for (dtl::type::size j{ 1 }; j < matrix_[i].size(); ++j) {
if (!isNoise_noiseShoreBool(matrix_[i][j][layer_], matrix_[i][j - 1][layer_], matrix_[i - 1][j][layer_], rBL_)) continue;
if (matrix_[i][j][layer_]) matrix_[i][j][layer_] = false_tile_;
else matrix_[i][j][layer_] = true_tile_;
}
}
TP<TN Matrix_>
DVCC
void rnoiseShoreBool(Matrix_ & matrix_, CS dtl::type::size layer_) NE {
using dtl::random::mersenne_twister_32bit;
using dtl::utility::tool::isNoise_noiseShoreBool;
for (dtl::type::size i{ matrix_.size() - 1 }; i >= 1; --i)
for (dtl::type::size j{ matrix_[i].size() - 1 }; j >= 1; --j) {
if (!isNoise_noiseShoreBool(matrix_[i - 1][j - 1][layer_], matrix_[i][j - 1][layer_], matrix_[i - 1][j][layer_])) continue;
if (matrix_[i - 1][j - 1][layer_]) matrix_[i - 1][j - 1][layer_] = false;
else matrix_[i - 1][j - 1][layer_] = true;
}
}
TP<TN Matrix_>
DVCC
void rnoiseShoreBool(Matrix_ & matrix_, CS dtl::type::size layer_, CS double rBL_) NE {
using dtl::random::mersenne_twister_32bit;
using dtl::utility::tool::isNoise_noiseShoreBool;
for (dtl::type::size i{ matrix_.size() - 1 }; i >= 1; --i)
for (dtl::type::size j{ matrix_[i].size() - 1 }; j >= 1; --j) {
if (!isNoise_noiseShoreBool(matrix_[i - 1][j - 1][layer_], matrix_[i][j - 1][layer_], matrix_[i - 1][j][layer_], rBL_)) continue;
if (matrix_[i - 1][j - 1][layer_]) matrix_[i - 1][j - 1][layer_] = false;
else matrix_[i - 1][j - 1][layer_] = true;
}
}
TP<TN MI, TN Matrix_>
DVCC
void rnoiseShoreBool(Matrix_ & matrix_, CS dtl::type::size layer_, CS double rBL_, CS MI true_tile_, CS MI false_tile_ = 0) NE {
using dtl::random::mersenne_twister_32bit;
using dtl::utility::tool::isNoise_noiseShoreBool;
for (dtl::type::size i{ matrix_.size() - 1 }; i >= 1; --i)
for (dtl::type::size j{ matrix_[i].size() - 1 }; j >= 1; --j) {
if (!isNoise_noiseShoreBool(matrix_[i - 1][j - 1][layer_], matrix_[i][j - 1][layer_], matrix_[i - 1][j][layer_], rBL_)) continue;
if (matrix_[i - 1][j - 1][layer_]) matrix_[i - 1][j - 1][layer_] = false_tile_;
else matrix_[i - 1][j - 1][layer_] = true_tile_;
}
}
TP<TN Matrix_>
DVCC
void noiseShoreBothBool(Matrix_ & matrix_, CS dtl::type::size layer_) NE {
dtl::utility::layer::stl::noiseShoreBool(matrix_, layer_);
dtl::utility::layer::stl::rnoiseShoreBool(matrix_, layer_);
}
TP<TN Matrix_>
DVCC
void noiseShoreBothBool(Matrix_ & matrix_, CS dtl::type::size layer_, CS double rBL_) NE {
dtl::utility::layer::stl::noiseShoreBool(matrix_, layer_, rBL_);
dtl::utility::layer::stl::rnoiseShoreBool(matrix_, layer_, rBL_);
}
TP<TN Matrix_>
DVCC
void noiseShoreBothBool(Matrix_ & matrix_, CS dtl::type::size layer_, CS double rBL1_, CS double rBL2_) NE {
dtl::utility::layer::stl::noiseShoreBool(matrix_, layer_, rBL1_);
dtl::utility::layer::stl::rnoiseShoreBool(matrix_, layer_, rBL2_);
}
TP<TN Matrix_>
DVCC
void rnoiseShoreBothBool(Matrix_ & matrix_, CS dtl::type::size layer_) NE {
dtl::utility::layer::stl::rnoiseShoreBool(matrix_, layer_);
dtl::utility::layer::stl::noiseShoreBool(matrix_, layer_);
}
TP<TN Matrix_>
DVCC
void rnoiseShoreBothBool(Matrix_ & matrix_, CS dtl::type::size layer_, CS double rBL_) NE {
dtl::utility::layer::stl::rnoiseShoreBool(matrix_, layer_, rBL_);
dtl::utility::layer::stl::noiseShoreBool(matrix_, layer_, rBL_);
}
TP<TN Matrix_>
DVCC
void rnoiseShoreBothBool(Matrix_ & matrix_, CS dtl::type::size layer_, CS double rBL1_, CS double rBL2_) NE {
dtl::utility::layer::stl::rnoiseShoreBool(matrix_, layer_, rBL1_);
dtl::utility::layer::stl::noiseShoreBool(matrix_, layer_, rBL2_);
}
}
}
NS layer {
NS normal {
TP<TN Matrix_>
DVCC
void noiseShoreBool(Matrix_& matrix_, CS dtl::type::size layer_, CS dtl::type::size x_, CS dtl::type::size y_) NE {
using dtl::random::mersenne_twister_32bit;
using dtl::utility::tool::isNoise_noiseShoreBool;
for (dtl::type::size i{ 1 }; i < y_; ++i)
for (dtl::type::size j{ 1 }; j < x_; ++j) {
if (!isNoise_noiseShoreBool(matrix_[i][j][layer_], matrix_[i][j - 1][layer_], matrix_[i - 1][j][layer_])) continue;
if (matrix_[i][j][layer_]) matrix_[i][j][layer_] = false;
else matrix_[i][j][layer_] = true;
}
}
TP<TN Matrix_>
DVCC
void noiseShoreBool(Matrix_ & matrix_, CS dtl::type::size layer_, CS dtl::type::size x_, CS dtl::type::size y_, CS double rBL_) NE {
using dtl::random::mersenne_twister_32bit;
using dtl::utility::tool::isNoise_noiseShoreBool;
for (dtl::type::size i{ 1 }; i < y_; ++i)
for (dtl::type::size j{ 1 }; j < x_; ++j) {
if (!isNoise_noiseShoreBool(matrix_[i][j][layer_], matrix_[i][j - 1][layer_], matrix_[i - 1][j][layer_], rBL_)) continue;
if (matrix_[i][j][layer_]) matrix_[i][j][layer_] = false;
else matrix_[i][j][layer_] = true;
}
}
TP<TN MI, TN Matrix_>
DVCC
void noiseShoreBool(Matrix_ & matrix_, CS dtl::type::size layer_, CS dtl::type::size x_, CS dtl::type::size y_, CS double rBL_, CS MI true_tile_, CS MI false_tile_ = 0) NE {
using dtl::random::mersenne_twister_32bit;
using dtl::utility::tool::isNoise_noiseShoreBool;
for (dtl::type::size i{ 1 }; i < y_; ++i)
for (dtl::type::size j{ 1 }; j < x_; ++j) {
if (!isNoise_noiseShoreBool(matrix_[i][j][layer_], matrix_[i][j - 1][layer_], matrix_[i - 1][j][layer_], rBL_)) continue;
if (matrix_[i][j][layer_]) matrix_[i][j][layer_] = false_tile_;
else matrix_[i][j][layer_] = true_tile_;
}
}
TP<TN Matrix_>
DVCC
void rnoiseShoreBool(Matrix_ & matrix_, CS dtl::type::size layer_, CS dtl::type::size x_, CS dtl::type::size y_) NE {
using dtl::random::mersenne_twister_32bit;
using dtl::utility::tool::isNoise_noiseShoreBool;
for (dtl::type::size i{ y_ - 1 }; i >= 1; --i)
for (dtl::type::size j{ x_ - 1 }; j >= 1; --j) {
if (!isNoise_noiseShoreBool(matrix_[i - 1][j - 1][layer_], matrix_[i][j - 1][layer_], matrix_[i - 1][j][layer_])) continue;
if (matrix_[i - 1][j - 1][layer_]) matrix_[i - 1][j - 1][layer_] = false;
else matrix_[i - 1][j - 1][layer_] = true;
}
}
TP<TN Matrix_>
DVCC
void rnoiseShoreBool(Matrix_ & matrix_, CS dtl::type::size layer_, CS dtl::type::size x_, CS dtl::type::size y_, CS double rBL_) NE {
using dtl::random::mersenne_twister_32bit;
using dtl::utility::tool::isNoise_noiseShoreBool;
for (dtl::type::size i{ y_ - 1 }; i >= 1; --i)
for (dtl::type::size j{ x_ - 1 }; j >= 1; --j) {
if (!isNoise_noiseShoreBool(matrix_[i - 1][j - 1][layer_], matrix_[i][j - 1][layer_], matrix_[i - 1][j][layer_], rBL_)) continue;
if (matrix_[i - 1][j - 1][layer_]) matrix_[i - 1][j - 1][layer_] = false;
else matrix_[i - 1][j - 1][layer_] = true;
}
}
TP<TN MI, TN Matrix_>
DVCC
void rnoiseShoreBool(Matrix_ & matrix_, CS dtl::type::size layer_, CS dtl::type::size x_, CS dtl::type::size y_, CS double rBL_, CS MI true_tile_, CS MI false_tile_ = 0) NE {
using dtl::random::mersenne_twister_32bit;
using dtl::utility::tool::isNoise_noiseShoreBool;
for (dtl::type::size i{ y_ - 1 }; i >= 1; --i)
for (dtl::type::size j{ x_ - 1 }; j >= 1; --j) {
if (!isNoise_noiseShoreBool(matrix_[i - 1][j - 1][layer_], matrix_[i][j - 1][layer_], matrix_[i - 1][j][layer_], rBL_)) continue;
if (matrix_[i - 1][j - 1][layer_]) matrix_[i - 1][j - 1][layer_] = false_tile_;
else matrix_[i - 1][j - 1][layer_] = true_tile_;
}
}
TP<TN Matrix_>
DVCC
void noiseShoreBothBool(Matrix_ & matrix_, CS dtl::type::size layer_, CS dtl::type::size x_, CS dtl::type::size y_) NE {
dtl::utility::layer::normal::noiseShoreBool(matrix_, layer_, x_, y_);
dtl::utility::layer::normal::rnoiseShoreBool(matrix_, layer_, x_, y_);
}
TP<TN Matrix_>
DVCC
void noiseShoreBothBool(Matrix_ & matrix_, CS dtl::type::size layer_, CS dtl::type::size x_, CS dtl::type::size y_, CS double rBL_) NE {
dtl::utility::layer::normal::noiseShoreBool(matrix_, layer_, x_, y_, rBL_);
dtl::utility::layer::normal::rnoiseShoreBool(matrix_, layer_, x_, y_, rBL_);
}
TP<TN Matrix_>
DVCC
void noiseShoreBothBool(Matrix_ & matrix_, CS dtl::type::size layer_, CS dtl::type::size x_, CS dtl::type::size y_, CS double rBL1_, CS double rBL2_) NE {
dtl::utility::layer::normal::noiseShoreBool(matrix_, layer_, x_, y_, rBL1_);
dtl::utility::layer::normal::rnoiseShoreBool(matrix_, layer_, x_, y_, rBL2_);
}
TP<TN Matrix_>
DVCC
void rnoiseShoreBothBool(Matrix_ & matrix_, CS dtl::type::size layer_, CS dtl::type::size x_, CS dtl::type::size y_) NE {
dtl::utility::layer::normal::rnoiseShoreBool(matrix_, layer_, x_, y_);
dtl::utility::layer::normal::noiseShoreBool(matrix_, layer_, x_, y_);
}
TP<TN Matrix_>
DVCC
void rnoiseShoreBothBool(Matrix_ & matrix_, CS dtl::type::size layer_, CS dtl::type::size x_, CS dtl::type::size y_, CS double rBL_) NE {
dtl::utility::layer::normal::rnoiseShoreBool(matrix_, layer_, x_, y_, rBL_);
dtl::utility::layer::normal::noiseShoreBool(matrix_, layer_, x_, y_, rBL_);
}
TP<TN Matrix_>
DVCC
void rnoiseShoreBothBool(Matrix_ & matrix_, CS dtl::type::size layer_, CS dtl::type::size x_, CS dtl::type::size y_, CS double rBL1_, CS double rBL2_) NE {
dtl::utility::layer::normal::rnoiseShoreBool(matrix_, layer_, x_, y_, rBL1_);
dtl::utility::layer::normal::noiseShoreBool(matrix_, layer_, x_, y_, rBL2_);
}
}
}
}
}
#endif 
#ifndef IDTL_DTL_UTILITY_PERLIN_NOISE
#define IDTL_DTL_UTILITY_PERLIN_NOISE
#include <cmath>
#include <cstdint>
#include <algorithm>
#include <array>
#include <random>
NS dtl {
inline NS utility {
class PerlinNoise {
private:
using Pint = std::uint_fast8_t;
std::array<Pint, 512> p{ {} };
DVCN
CE double getFade(CS double t_) CS NE {
RT t_ * t_* t_* (t_ * (t_ * 6 - 15) + 10);
}
DVCN
CE double getLerp(CS double t_, CS double a_, CS double b_) CS NE {
RT a_ + t_ * (b_ - a_);
}
DVCN
CE double makeGrad(CS Pint hash_, CS double u_, CS double v_) CS NE {
RT (((hash_ & 1) == 0) ? u_ : -u_) + (((hash_ & 2) == 0) ? v_ : -v_);
}
DVCN
CE double makeGrad(CS Pint hash_, CS double x_, CS double y_, CS double z_) CS NE {
RT this->makeGrad(hash_, hash_ < 8 ? x_ : y_, hash_ < 4 ? y_ : hash_ == 12 || hash_ == 14 ? x_ : z_);
}
DVCN
CE double getGrad(CS Pint hash_, CS double x_, CS double y_, CS double z_) CS NE {
RT this->makeGrad(hash_ & 15, x_, y_, z_);
}
DVCN
double setNoise(double x_ = 0.0, double y_ = 0.0, double z_ = 0.0) CS NE {
CS dtl::type::size x_int{ static_cast<dtl::type::size>(static_cast<dtl::type::size>(std::floor(x_)) & 255) };
CS dtl::type::size y_int{ static_cast<dtl::type::size>(static_cast<dtl::type::size>(std::floor(y_)) & 255) };
CS dtl::type::size z_int{ static_cast<dtl::type::size>(static_cast<dtl::type::size>(std::floor(z_)) & 255) };
x_ -= std::floor(x_);
y_ -= std::floor(y_);
z_ -= std::floor(z_);
CS double u{ this->getFade(x_) };
CS double v{ this->getFade(y_) };
CS double w{ this->getFade(z_) };
CS dtl::type::size a0{ static_cast<dtl::type::size>(this->p[x_int] + y_int) };
CS dtl::type::size a1{ static_cast<dtl::type::size>(this->p[a0] + z_int) };
CS dtl::type::size a2{ static_cast<dtl::type::size>(this->p[a0 + 1] + z_int) };
CS dtl::type::size b0{ static_cast<dtl::type::size>(this->p[x_int + 1] + y_int) };
CS dtl::type::size b1{ static_cast<dtl::type::size>(this->p[b0] + z_int) };
CS dtl::type::size b2{ static_cast<dtl::type::size>(this->p[b0 + 1] + z_int) };
RT this->getLerp(w,
this->getLerp(v,
this->getLerp(u, this->getGrad(this->p[a1], x_, y_, z_), this->getGrad(this->p[b1], x_ - 1, y_, z_)),
this->getLerp(u, this->getGrad(this->p[a2], x_, y_ - 1, z_), this->getGrad(this->p[b2], x_ - 1, y_ - 1, z_))),
this->getLerp(v,
this->getLerp(u, this->getGrad(this->p[a1 + 1], x_, y_, z_ - 1), this->getGrad(this->p[b1 + 1], x_ - 1, y_, z_ - 1)),
this->getLerp(u, this->getGrad(this->p[a2 + 1], x_, y_ - 1, z_ - 1), this->getGrad(this->p[b2 + 1], x_ - 1, y_ - 1, z_ - 1))));
}
DVCN
double setOctaveNoise(CS std::size_t octaves_, double x_) CS NE {
double noise_value{};
double amp{ 1.0 };
for (std::size_t i{}; i < octaves_; ++i) {
noise_value += this->setNoise(x_) * amp;
x_ *= 2.0;
amp *= 0.5;
}
RT noise_value;
}
DVCN
double setOctaveNoise(CS std::size_t octaves_, double x_, double y_) CS NE {
double noise_value{};
double amp{ 1.0 };
for (std::size_t i{}; i < octaves_; ++i) {
noise_value += this->setNoise(x_, y_) * amp;
x_ *= 2.0;
y_ *= 2.0;
amp *= 0.5;
}
RT noise_value;
}
DVCN
double setOctaveNoise(CS std::size_t octaves_, double x_, double y_, double z_) CS NE {
double noise_value{};
double amp{ 1.0 };
for (std::size_t i{}; i < octaves_; ++i) {
noise_value += this->setNoise(x_, y_, z_) * amp;
x_ *= 2.0;
y_ *= 2.0;
z_ *= 2.0;
amp *= 0.5;
}
RT noise_value;
}
public:
TP <TN... Args>
DVCN
double noise(CS Args... args_) CS NE {
RT this->setNoise(args_...)* 0.5 + 0.5;
}
TP <TN... Args>
DVCN
double octaveNoise(CS std::size_t octaves_, CS Args... args_) CS NE {
RT this->setOctaveNoise(octaves_, args_...)* 0.5 + 0.5;
}
void setSeed(CS std::uint_fast32_t seed_) {
for (dtl::type::size i{}; i < 256; ++i)
this->p[i] = static_cast<Pint>(i);
std::shuffle(this->p.begin(), this->p.begin() + 256, std::default_random_engine(seed_));
for (dtl::type::size i{}; i < 256; ++i)
this->p[256 + i] = this->p[i];
}
CE PerlinNoise() = default;
explicit PerlinNoise(CS std::uint_fast32_t seed_) {
this->setSeed(seed_);
}
};
}
}
#endif 
#ifndef IDTL_DTL_UTILITY_REPLACE_ALL
#define IDTL_DTL_UTILITY_REPLACE_ALL
#include <cstdint>
#include <vector>
#ifndef IDTL_DTL_TYPE_SORT
#define IDTL_DTL_TYPE_SORT
#ifndef DTL_TYPE_SORT
#if defined(SPROUT_ALGORITHM_SORT) 
#define DTL_TYPE_SORT (::sprout::sort)
#else
#include <algorithm>
#define DTL_TYPE_SORT (std::sort)
#endif
#endif
#endif 
NS dtl {
inline NS utility {
TP<TN MI>
class ReplaceAll {
private:
using IS = dtl::type::size;
IS start_x{};
IS start_y{};
IS width{};
IS height{};
MI after_value{};
std::vector<MI> before_value{};
DVCC
void string_String() CS NE {}
TP<TN Int_, TN ...Args_>
DVCC
void string_String(CS Int_& first_, CS Args_& ... args_) NE {
this->before_value.emplace_back(static_cast<MI>(first_));
this->string_String(args_...);
}
TP<TN Matrix_>
DVCC
inline void substitutionSTL(Matrix_&& matrix_, CS IS point_x_, CS IS point_y_) CS NE {
for (std::int_fast32_t high_value{ static_cast<std::int_fast32_t>(this->before_value.size()) - 1 }, low_value{}, mid_value{}; low_value <= high_value;) {
mid_value = (low_value + high_value) / 2;
if (this->before_value[mid_value] == matrix_[point_y_][point_x_]) {
matrix_[point_y_][point_x_] = this->after_value;
RT;
}
else if (this->before_value[mid_value] < matrix_[point_y_][point_x_]) low_value = mid_value + 1;
else high_value = mid_value - 1;
}
}
TP<TN Matrix_>
DVCC
inline void substitutionArray(Matrix_&& matrix_, CS IS point_x_, CS IS point_y_, CS IS max_x_) CS NE {
for (std::int_fast32_t high_value{ static_cast<std::int_fast32_t>(this->before_value.size()) - 1 }, low_value{}, mid_value{}; low_value <= high_value;) {
mid_value = (low_value + high_value) / 2;
if (this->before_value[mid_value] == matrix_[point_y_ * max_x_ + point_x_]) {
matrix_[point_y_][point_x_] = this->after_value;
RT;
}
else if (this->before_value[mid_value] < matrix_[point_y_ * max_x_ + point_x_]) low_value = mid_value + 1;
else high_value = mid_value - 1;
}
}
TP<TN Matrix_>
DVCC
inline void substitutionLayer(Matrix_&& matrix_, CS IS layer_, CS IS point_x_, CS IS point_y_) CS NE {
for (std::int_fast32_t high_value{ static_cast<std::int_fast32_t>(this->before_value.size()) - 1 }, low_value{}, mid_value{}; low_value <= high_value;) {
mid_value = (low_value + high_value) / 2;
if (this->before_value[mid_value] == matrix_[point_y_][point_x_][layer_]) {
matrix_[point_y_][point_x_] = this->after_value;
RT;
}
else if (this->before_value[mid_value] < matrix_[point_y_][point_x_][layer_]) low_value = mid_value + 1;
else high_value = mid_value - 1;
}
}
TP<TN Matrix_, TN Function_>
DVCC
inline void substitutionSTL(Matrix_&& matrix_, CS IS point_x_, CS IS point_y_, Function_&& function_) CS NE {
for (std::int_fast32_t high_value{ static_cast<std::int_fast32_t>(this->before_value.size()) - 1 }, low_value{}, mid_value{}; low_value <= high_value;) {
mid_value = (low_value + high_value) / 2;
if (this->before_value[mid_value] == matrix_[point_y_][point_x_] && function_(matrix_[point_y_][point_x_])) {
matrix_[point_y_][point_x_] = this->after_value;
RT;
}
else if (this->before_value[mid_value] < matrix_[point_y_][point_x_]) low_value = mid_value + 1;
else high_value = mid_value - 1;
}
}
TP<TN Matrix_, TN Function_>
DVCC
inline void substitutionArray(Matrix_&& matrix_, CS IS point_x_, CS IS point_y_, CS IS max_x_, Function_&& function_) CS NE {
for (std::int_fast32_t high_value{ static_cast<std::int_fast32_t>(this->before_value.size()) - 1 }, low_value{}, mid_value{}; low_value <= high_value;) {
mid_value = (low_value + high_value) / 2;
if (this->before_value[mid_value] == matrix_[point_y_ * max_x_ + point_x_] && function_(matrix_[point_y_ * max_x_ + point_x_])) {
matrix_[point_y_][point_x_] = this->after_value;
RT;
}
else if (this->before_value[mid_value] < matrix_[point_y_ * max_x_ + point_x_]) low_value = mid_value + 1;
else high_value = mid_value - 1;
}
}
TP<TN Matrix_, TN Function_>
DVCC
inline void substitutionLayer(Matrix_&& matrix_, CS IS layer_, CS IS point_x_, CS IS point_y_, Function_&& function_) CS NE {
for (std::int_fast32_t high_value{ static_cast<std::int_fast32_t>(this->before_value.size()) - 1 }, low_value{}, mid_value{}; low_value <= high_value;) {
mid_value = (low_value + high_value) / 2;
if (this->before_value[mid_value] == matrix_[point_y_][point_x_][layer_] && function_(matrix_[point_y_][point_x_][layer_])) {
matrix_[point_y_][point_x_] = this->after_value;
RT;
}
else if (this->before_value[mid_value] < matrix_[point_y_][point_x_][layer_]) low_value = mid_value + 1;
else high_value = mid_value - 1;
}
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawSTL(Matrix_&& matrix_, CS IS end_y_, Args_&& ... args_) CS NE {
if (this->before_value.size() == 0) RT false;
for (IS i{ this->start_y }; i < end_y_; ++i)
for (IS j{ this->start_x }; j < matrix_[i].size(); ++j)
this->substitutionSTL(matrix_, j, i, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawWidthSTL(Matrix_ && matrix_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
if (this->before_value.size() == 0) RT false;
for (IS i{ this->start_y }; i < end_y_; ++i)
for (IS j{ this->start_x }; j < matrix_[i].size() && j < end_x_; ++j)
this->substitutionSTL(matrix_, j, i, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawLayerSTL(Matrix_ && matrix_, CS IS layer_, CS IS end_y_, Args_ && ... args_) CS NE {
if (this->before_value.size() == 0) RT false;
for (IS i{ this->start_y }; i < end_y_; ++i)
for (IS j{ this->start_x }; j < matrix_[i].size(); ++j)
this->substitutionLayer(matrix_, layer_, j, i, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawLayerWidthSTL(Matrix_ && matrix_, CS IS layer_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
if (this->before_value.size() == 0) RT false;
for (IS i{ this->start_y }; i < end_y_; ++i)
for (IS j{ this->start_x }; j < matrix_[i].size() && j < end_x_; ++j)
this->substitutionLayer(matrix_, layer_, j, i, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawNormal(Matrix_ && matrix_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
if (this->before_value.size() == 0) RT false;
for (IS i{ this->start_y }; i < end_y_; ++i)
for (IS j{ this->start_x }; j < end_x_; ++j)
this->substitutionSTL(matrix_, j, i, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawLayerNormal(Matrix_ && matrix_, CS IS layer_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
if (this->before_value.size() == 0) RT false;
for (IS i{ this->start_y }; i < end_y_; ++i)
for (IS j{ this->start_x }; j < end_x_; ++j)
this->substitutionLayer(matrix_, layer_, j, i, args_...);
RT true;
}
TP<TN Matrix_, TN ...Args_>
DVCC
BL drawArray(Matrix_ && matrix_, CS IS end_x_, CS IS end_y_, CS IS max_x_, Args_ && ... args_) CS NE {
if (this->before_value.size() == 0) RT false;
for (IS i{ this->start_y }; i < end_y_; ++i)
for (IS j{ this->start_x }; j < end_x_; ++j)
this->substitutionArray(matrix_, j, i, max_x_, args_...);
RT true;
}
public:
DVCN
CE IS getPointX() CS NE {
RT this->start_x;
}
DVCN
CE IS getPointY() CS NE {
RT this->start_y;
}
DVCN
CE IS getWidth() CS NE {
RT this->width;
}
DVCN
CE IS getHeight() CS NE {
RT this->height;
}
DVCN
CE MI getValue() CS NE {
RT this->after_value;
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_) CS NE {
RT (this->width == 0) ? this->drawSTL(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height) : this->drawWidthSTL(matrix_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, Function_ && function_) CS NE {
RT (this->width == 0) ? this->drawSTL(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_) : this->drawWidthSTL(matrix_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_, CS IS layer_) CS NE {
RT (this->width == 0) ? this->drawLayerSTL(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height) : this->drawLayerWidthSTL(matrix_, layer_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, CS IS layer_, Function_ && function_) CS NE {
RT (this->width == 0) ? this->drawLayerSTL(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_) : this->drawLayerWidthSTL(matrix_, layer_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_) CS NE {
RT this->drawNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_, Function_ && function_) CS NE {
RT this->drawNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_, CS IS layer_, CS IS max_x_, CS IS max_y_) CS NE {
RT this->drawLayerNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, CS IS layer_, CS IS max_x_, CS IS max_y_, Function_ && function_) CS NE {
RT this->drawLayerNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL drawArray(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_) CS NE {
RT this->drawArray(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, max_x_);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperatorArray(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_, Function_ && function_) CS NE {
RT this->drawArray(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, max_x_, function_);
}
TP<TN Matrix_, TN ...Args_>
CE BL operator()(Matrix_ && matrix_, Args_ && ... args_) CS NE {
RT this->draw(DTL_TYPE_FORWARD<Matrix_>(matrix_), DTL_TYPE_FORWARD<Args_>(args_)...);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& create(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->draw(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createArray(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->drawArray(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createOperator(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->drawOperator(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createOperatorArray(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->drawOperatorArray(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
DVCC
ReplaceAll& clearPointX() NE {
this->start_x = 0;
RT *this;
}
DVCC
ReplaceAll& clearPointY() NE {
this->start_y = 0;
RT *this;
}
DVCC
ReplaceAll& clearWidth() NE {
this->width = 0;
RT *this;
}
DVCC
ReplaceAll& clearHeight() NE {
this->height = 0;
RT *this;
}
DVCC
ReplaceAll& clearPoint() NE {
this->clearPointX();
this->clearPointY();
RT *this;
}
DVCC
ReplaceAll& clearRange() NE {
this->clearPointX();
this->clearPointY();
this->clearWidth();
this->clearHeight();
RT *this;
}
DVCC
ReplaceAll& clear() NE {
this->clearRange();
RT *this;
}
DVCC
ReplaceAll& setPointX(CS IS start_x_) NE {
this->start_x = start_x_;
RT *this;
}
DVCC
ReplaceAll& setPointY(CS IS start_y_) NE {
this->start_y = start_y_;
RT *this;
}
DVCC
ReplaceAll& setWidth(CS IS width_) NE {
this->width = width_;
RT *this;
}
DVCC
ReplaceAll& setHeight(CS IS height_) NE {
this->height = height_;
RT *this;
}
DVCC
ReplaceAll& setPoint(CS IS point_) NE {
this->start_x = point_;
this->start_y = point_;
RT *this;
}
DVCC
ReplaceAll& setPoint(CS IS start_x_, CS IS start_y_) NE {
this->start_x = start_x_;
this->start_y = start_y_;
RT *this;
}
DVCC
ReplaceAll& setRange(CS IS start_x_, CS IS start_y_, CS IS length_) NE {
this->start_x = start_x_;
this->start_y = start_y_;
this->width = length_;
this->height = length_;
RT *this;
}
DVCC
ReplaceAll& setRange(CS IS start_x_, CS IS start_y_, CS IS width_, CS IS height_) NE {
this->start_x = start_x_;
this->start_y = start_y_;
this->width = width_;
this->height = height_;
RT *this;
}
DVCC
ReplaceAll& setRange(CS dtl::base::MatrixRange& matrix_range_) NE {
this->start_x = matrix_range_.x;
this->start_y = matrix_range_.y;
this->width = matrix_range_.w;
this->height = matrix_range_.h;
RT *this;
}
CE ReplaceAll() NE = default;
CE explicit ReplaceAll(CS MI & after_value_) NE
:after_value(after_value_) {}
TP<TN ...Args_>
explicit ReplaceAll(CS MI& after_value_, CS MI& first_before_value_, CS Args_& ... second_and_subsequent_before_value_) NE
:after_value(after_value_) {
this->string_String(first_before_value_, second_and_subsequent_before_value_...);
DTL_TYPE_SORT(before_value.begin(), before_value.end());
}
CE explicit ReplaceAll(CS dtl::base::MatrixRange & matrix_range_) NE
:start_x(matrix_range_.x), start_y(matrix_range_.y),
width(matrix_range_.w), height(matrix_range_.h) {}
CE explicit ReplaceAll(CS dtl::base::MatrixRange & matrix_range_, CS MI & after_value_) NE
:start_x(matrix_range_.x), start_y(matrix_range_.y),
width(matrix_range_.w), height(matrix_range_.h),
after_value(after_value_) {}
TP<TN ...Args_>
explicit ReplaceAll(CS dtl::base::MatrixRange& matrix_range_, CS MI& after_value_, CS MI& first_before_value_, CS Args_& ... second_and_subsequent_before_value_) NE
:start_x(matrix_range_.x), start_y(matrix_range_.y),
width(matrix_range_.w), height(matrix_range_.h),
after_value(after_value_) {
this->string_String(first_before_value_, second_and_subsequent_before_value_...);
DTL_TYPE_SORT(before_value.begin(), before_value.end());
}
};
}
}
#endif 
#ifndef IDTL_DTL_UTILITY_REPLACE_SOME
#define IDTL_DTL_UTILITY_REPLACE_SOME
#include <cstdint>
#include <vector>
NS dtl {
inline NS utility {
TP<TN MI>
class ReplaceSome {
private:
using IS = dtl::type::size;
IS start_x{};
IS start_y{};
IS width{};
IS height{};
MI after_value{};
std::vector<MI> before_value{};
dtl::type::size replace_num{};
DVCC
void string_String() CS NE {}
TP<TN Int_, TN ...Args_>
DVCC
void string_String(CS Int_& first_, CS Args_& ... args_) NE {
this->before_value.emplace_back(static_cast<MI>(first_));
this->string_String(args_...);
}
TP<TN Matrix_>
DVCC
inline void substitutionSTL(Matrix_&& matrix_, std::vector<std::pair<dtl::type::size, dtl::type::size>>& value_pairs, CS IS point_x_, CS IS point_y_) CS NE {
for (std::int_fast32_t high_value{ static_cast<std::int_fast32_t>(this->before_value.size()) - 1 }, low_value{}, mid_value{}; low_value <= high_value;) {
mid_value = (low_value + high_value) / 2;
if (this->before_value[mid_value] == matrix_[point_y_][point_x_]) {
value_pairs.emplace_back(std::make_pair(point_y_, point_x_));
RT;
}
else if (this->before_value[mid_value] < matrix_[point_y_][point_x_]) low_value = mid_value + 1;
else high_value = mid_value - 1;
}
}
TP<TN Matrix_>
DVCC
inline void substitutionArray(Matrix_&& matrix_, std::vector<std::pair<dtl::type::size, dtl::type::size>>& value_pairs, CS IS point_x_, CS IS point_y_, CS IS max_x_) CS NE {
for (std::int_fast32_t high_value{ static_cast<std::int_fast32_t>(this->before_value.size()) - 1 }, low_value{}, mid_value{}; low_value <= high_value;) {
mid_value = (low_value + high_value) / 2;
if (this->before_value[mid_value] == matrix_[point_y_ * max_x_ + point_x_]) {
value_pairs.emplace_back(std::make_pair(point_y_, point_x_));
RT;
}
else if (this->before_value[mid_value] < matrix_[point_y_ * max_x_ + point_x_]) low_value = mid_value + 1;
else high_value = mid_value - 1;
}
}
TP<TN Matrix_>
DVCC
inline void substitutionLayer(Matrix_ && matrix_, std::vector<std::pair<dtl::type::size, dtl::type::size>>& value_pairs, CS IS layer_, CS IS point_x_, CS IS point_y_) CS NE {
for (std::int_fast32_t high_value{ static_cast<std::int_fast32_t>(this->before_value.size()) - 1 }, low_value{}, mid_value{}; low_value <= high_value;) {
mid_value = (low_value + high_value) / 2;
if (this->before_value[mid_value] == matrix_[point_y_][point_x_][layer_]) {
value_pairs.emplace_back(std::make_pair(point_y_, point_x_));
RT;
}
else if (this->before_value[mid_value] < matrix_[point_y_][point_x_][layer_]) low_value = mid_value + 1;
else high_value = mid_value - 1;
}
}
TP<TN Matrix_, TN Function_>
DVCC
inline void substitutionSTL(Matrix_ && matrix_, std::vector<std::pair<dtl::type::size, dtl::type::size>>& value_pairs, CS IS point_x_, CS IS point_y_, Function_ && function_) CS NE {
for (std::int_fast32_t high_value{ static_cast<std::int_fast32_t>(this->before_value.size()) - 1 }, low_value{}, mid_value{}; low_value <= high_value;) {
mid_value = (low_value + high_value) / 2;
if (this->before_value[mid_value] == matrix_[point_y_][point_x_] && function_(matrix_[point_y_][point_x_])) {
value_pairs.emplace_back(std::make_pair(point_y_, point_x_));
RT;
}
else if (this->before_value[mid_value] < matrix_[point_y_][point_x_]) low_value = mid_value + 1;
else high_value = mid_value - 1;
}
}
TP<TN Matrix_, TN Function_>
DVCC
inline void substitutionArray(Matrix_ && matrix_, std::vector<std::pair<dtl::type::size, dtl::type::size>>& value_pairs, CS IS point_x_, CS IS point_y_, CS IS max_x_, Function_ && function_) CS NE {
for (std::int_fast32_t high_value{ static_cast<std::int_fast32_t>(this->before_value.size()) - 1 }, low_value{}, mid_value{}; low_value <= high_value;) {
mid_value = (low_value + high_value) / 2;
if (this->before_value[mid_value] == matrix_[point_y_ * max_x_ + point_x_] && function_(matrix_[point_y_ * max_x_ + point_x_])) {
value_pairs.emplace_back(std::make_pair(point_y_, point_x_));
RT;
}
else if (this->before_value[mid_value] < matrix_[point_y_ * max_x_ + point_x_]) low_value = mid_value + 1;
else high_value = mid_value - 1;
}
}
TP<TN Matrix_, TN Function_>
DVCC
inline void substitutionLayer(Matrix_ && matrix_, std::vector<std::pair<dtl::type::size, dtl::type::size>>& value_pairs, CS IS layer_, CS IS point_x_, CS IS point_y_, Function_ && function_) CS NE {
for (std::int_fast32_t high_value{ static_cast<std::int_fast32_t>(this->before_value.size()) - 1 }, low_value{}, mid_value{}; low_value <= high_value;) {
mid_value = (low_value + high_value) / 2;
if (this->before_value[mid_value] == matrix_[point_y_][point_x_][layer_] && function_(matrix_[point_y_][point_x_][layer_])) {
value_pairs.emplace_back(std::make_pair(point_y_, point_x_));
RT;
}
else if (this->before_value[mid_value] < matrix_[point_y_][point_x_][layer_]) low_value = mid_value + 1;
else high_value = mid_value - 1;
}
}
TP<TN Matrix_, TN ...Args_>
BL drawSTL(Matrix_&& matrix_, CS IS end_y_, Args_&& ... args_) CS NE {
if (this->replace_num == 0) RT true;
if (this->before_value.size() == 0) RT false;
std::vector<std::pair<dtl::type::size, dtl::type::size>> value_pairs{};
for (IS i{ this->start_y }; i < end_y_; ++i)
for (IS j{ this->start_x }; j < matrix_[i].size(); ++j)
this->substitutionSTL(matrix_, value_pairs, j, i, args_...);
if (value_pairs.size() == 0) RT false;
value_pairs.shrink_to_fit();
if (this->replace_num >= value_pairs.size()) {
for (CS auto& i : value_pairs)
matrix_[i.first][i.second] = this->after_value;
RT true;
}
for (dtl::type::size modify_count{}, index{}; modify_count < this->replace_num; ++modify_count) {
index = dtl::random::mt32bit.get<dtl::type::size>(value_pairs.size());
matrix_[value_pairs[index].first][value_pairs[index].second] = this->after_value;
value_pairs.erase(std::remove(value_pairs.begin(), value_pairs.end(), value_pairs[index]), value_pairs.end());
if (value_pairs.size() == 0) break;
}
RT true;
}
TP<TN Matrix_, TN ...Args_>
BL drawWidthSTL(Matrix_ && matrix_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
if (this->replace_num == 0) RT true;
if (this->before_value.size() == 0) RT false;
std::vector<std::pair<dtl::type::size, dtl::type::size>> value_pairs{};
for (IS i{ this->start_y }; i < end_y_; ++i)
for (IS j{ this->start_x }; j < matrix_[i].size() && j < end_x_; ++j)
this->substitutionSTL(matrix_, value_pairs, j, i, args_...);
if (value_pairs.size() == 0) RT false;
value_pairs.shrink_to_fit();
if (this->replace_num >= value_pairs.size()) {
for (CS auto& i : value_pairs)
matrix_[i.first][i.second] = this->after_value;
RT true;
}
for (dtl::type::size modify_count{}, index{}; modify_count < this->replace_num; ++modify_count) {
index = dtl::random::mt32bit.get<dtl::type::size>(value_pairs.size());
matrix_[value_pairs[index].first][value_pairs[index].second] = this->after_value;
value_pairs.erase(std::remove(value_pairs.begin(), value_pairs.end(), value_pairs[index]), value_pairs.end());
if (value_pairs.size() == 0) break;
}
RT true;
}
TP<TN Matrix_, TN ...Args_>
BL drawLayerSTL(Matrix_ && matrix_, CS IS layer_, CS IS end_y_, Args_ && ... args_) CS NE {
if (this->replace_num == 0) RT true;
if (this->before_value.size() == 0) RT false;
std::vector<std::pair<dtl::type::size, dtl::type::size>> value_pairs{};
for (IS i{ this->start_y }; i < end_y_; ++i)
for (IS j{ this->start_x }; j < matrix_[i].size(); ++j)
this->substitutionLayer(matrix_, value_pairs, layer_, j, i, args_...);
if (value_pairs.size() == 0) RT false;
value_pairs.shrink_to_fit();
if (this->replace_num >= value_pairs.size()) {
for (CS auto& i : value_pairs)
matrix_[i.first][i.second][layer_] = this->after_value;
RT true;
}
for (dtl::type::size modify_count{}, index{}; modify_count < this->replace_num; ++modify_count) {
index = dtl::random::mt32bit.get<dtl::type::size>(value_pairs.size());
matrix_[value_pairs[index].first][value_pairs[index].second][layer_] = this->after_value;
value_pairs.erase(std::remove(value_pairs.begin(), value_pairs.end(), value_pairs[index]), value_pairs.end());
if (value_pairs.size() == 0) break;
}
RT true;
}
TP<TN Matrix_, TN ...Args_>
BL drawLayerWidthSTL(Matrix_ && matrix_, CS IS layer_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
if (this->replace_num == 0) RT true;
if (this->before_value.size() == 0) RT false;
std::vector<std::pair<dtl::type::size, dtl::type::size>> value_pairs{};
for (IS i{ this->start_y }; i < end_y_; ++i)
for (IS j{ this->start_x }; j < matrix_[i].size() && j < end_x_; ++j)
this->substitutionLayer(matrix_, value_pairs, layer_, j, i, args_...);
if (value_pairs.size() == 0) RT false;
value_pairs.shrink_to_fit();
if (this->replace_num >= value_pairs.size()) {
for (CS auto& i : value_pairs)
matrix_[i.first][i.second][layer_] = this->after_value;
RT true;
}
for (dtl::type::size modify_count{}, index{}; modify_count < this->replace_num; ++modify_count) {
index = dtl::random::mt32bit.get<dtl::type::size>(value_pairs.size());
matrix_[value_pairs[index].first][value_pairs[index].second] = this->after_value;
value_pairs.erase(std::remove(value_pairs.begin(), value_pairs.end(), value_pairs[index]), value_pairs.end());
if (value_pairs.size() == 0) break;
}
for (dtl::type::size modify_count{}, index{}; modify_count < this->replace_num; ++modify_count) {
index = dtl::random::mt32bit.get<dtl::type::size>(value_pairs.size());
matrix_[value_pairs[index].first][value_pairs[index].second][layer_] = this->after_value;
value_pairs.erase(std::remove(value_pairs.begin(), value_pairs.end(), value_pairs[index]), value_pairs.end());
if (value_pairs.size() == 0) break;
}
RT true;
}
TP<TN Matrix_, TN ...Args_>
BL drawNormal(Matrix_ && matrix_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
if (this->replace_num == 0) RT true;
if (this->before_value.size() == 0) RT false;
std::vector<std::pair<dtl::type::size, dtl::type::size>> value_pairs{};
for (IS i{ this->start_y }; i < end_y_; ++i)
for (IS j{ this->start_x }; j < end_x_; ++j)
this->substitutionSTL(matrix_, value_pairs, j, i, args_...);
if (value_pairs.size() == 0) RT false;
value_pairs.shrink_to_fit();
if (this->replace_num >= value_pairs.size()) {
for (CS auto& i : value_pairs)
matrix_[i.first][i.second] = this->after_value;
RT true;
}
for (dtl::type::size modify_count{}, index{}; modify_count < this->replace_num; ++modify_count) {
index = dtl::random::mt32bit.get<dtl::type::size>(value_pairs.size());
matrix_[value_pairs[index].first][value_pairs[index].second] = this->after_value;
value_pairs.erase(std::remove(value_pairs.begin(), value_pairs.end(), value_pairs[index]), value_pairs.end());
if (value_pairs.size() == 0) break;
}
RT true;
}
TP<TN Matrix_, TN ...Args_>
BL drawLayerNormal(Matrix_ && matrix_, CS IS layer_, CS IS end_x_, CS IS end_y_, Args_ && ... args_) CS NE {
if (this->replace_num == 0) RT true;
if (this->before_value.size() == 0) RT false;
std::vector<std::pair<dtl::type::size, dtl::type::size>> value_pairs{};
for (IS i{ this->start_y }; i < end_y_; ++i)
for (IS j{ this->start_x }; j < end_x_; ++j)
this->substitutionLayer(matrix_, value_pairs, layer_, j, i, args_...);
if (value_pairs.size() == 0) RT false;
value_pairs.shrink_to_fit();
if (this->replace_num >= value_pairs.size()) {
for (CS auto& i : value_pairs)
matrix_[i.first][i.second][layer_] = this->after_value;
RT true;
}
for (dtl::type::size modify_count{}, index{}; modify_count < this->replace_num; ++modify_count) {
index = dtl::random::mt32bit.get<dtl::type::size>(value_pairs.size());
matrix_[value_pairs[index].first][value_pairs[index].second][layer_] = this->after_value;
value_pairs.erase(std::remove(value_pairs.begin(), value_pairs.end(), value_pairs[index]), value_pairs.end());
if (value_pairs.size() == 0) break;
}
RT true;
}
TP<TN Matrix_, TN ...Args_>
BL drawArray(Matrix_ && matrix_, CS IS end_x_, CS IS end_y_, CS IS max_x_, Args_ && ... args_) CS NE {
if (this->replace_num == 0) RT true;
if (this->before_value.size() == 0) RT false;
std::vector<std::pair<dtl::type::size, dtl::type::size>> value_pairs{};
for (IS i{ this->start_y }; i < end_y_; ++i)
for (IS j{ this->start_x }; j < end_x_; ++j)
this->substitutionArray(matrix_, value_pairs, j, i, max_x_, args_...);
if (value_pairs.size() == 0) RT false;
value_pairs.shrink_to_fit();
if (this->replace_num >= value_pairs.size()) {
for (CS auto& i : value_pairs)
matrix_[i.first * max_x_ + i.second] = this->after_value;
RT true;
}
for (dtl::type::size modify_count{}, index{}; modify_count < this->replace_num; ++modify_count) {
index = dtl::random::mt32bit.get<dtl::type::size>(value_pairs.size());
matrix_[value_pairs[index].first * max_x_ + value_pairs[index].second] = this->after_value;
value_pairs.erase(std::remove(value_pairs.begin(), value_pairs.end(), value_pairs[index]), value_pairs.end());
if (value_pairs.size() == 0) break;
}
RT true;
}
public:
DVCN
CE IS getPointX() CS NE {
RT this->start_x;
}
DVCN
CE IS getPointY() CS NE {
RT this->start_y;
}
DVCN
CE IS getWidth() CS NE {
RT this->width;
}
DVCN
CE IS getHeight() CS NE {
RT this->height;
}
DVCN
CE MI getValue() CS NE {
RT this->after_value;
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_) CS NE {
RT (this->width == 0) ? this->drawSTL(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height) : this->drawWidthSTL(matrix_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, Function_ && function_) CS NE {
RT (this->width == 0) ? this->drawSTL(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_) : this->drawWidthSTL(matrix_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_, CS IS layer_) CS NE {
RT (this->width == 0) ? this->drawLayerSTL(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height) : this->drawLayerWidthSTL(matrix_, layer_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, CS IS layer_, Function_ && function_) CS NE {
RT (this->width == 0) ? this->drawLayerSTL(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_) : this->drawLayerWidthSTL(matrix_, layer_, this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= matrix_.size()) ? matrix_.size() : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_) CS NE {
RT this->drawNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_, Function_ && function_) CS NE {
RT this->drawNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL draw(Matrix_ && matrix_, CS IS layer_, CS IS max_x_, CS IS max_y_) CS NE {
RT this->drawLayerNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperator(Matrix_ && matrix_, CS IS layer_, CS IS max_x_, CS IS max_y_, Function_ && function_) CS NE {
RT this->drawLayerNormal(DTL_TYPE_FORWARD<Matrix_>(matrix_), layer_, (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, function_);
}
TP<TN Matrix_>
CE BL drawArray(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_) CS NE {
RT this->drawArray(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, max_x_);
}
TP<TN Matrix_, TN Function_>
CE BL drawOperatorArray(Matrix_ && matrix_, CS IS max_x_, CS IS max_y_, Function_ && function_) CS NE {
RT this->drawArray(DTL_TYPE_FORWARD<Matrix_>(matrix_), (this->width == 0 || this->start_x + this->width >= max_x_) ? max_x_ : this->start_x + this->width, (this->height == 0 || this->start_y + this->height >= max_y_) ? max_y_ : this->start_y + this->height, max_x_, function_);
}
TP<TN Matrix_, TN ...Args_>
CE BL operator()(Matrix_ && matrix_, Args_ && ... args_) CS NE {
RT this->draw(DTL_TYPE_FORWARD<Matrix_>(matrix_), DTL_TYPE_FORWARD<Args_>(args_)...);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& create(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->draw(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createArray(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->drawArray(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createOperator(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->drawOperator(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
TP<TN Matrix_, TN ...Args_>
DVCC
Matrix_&& createOperatorArray(Matrix_ && matrix_, Args_ && ... args_) CS NE {
this->drawOperatorArray(matrix_, DTL_TYPE_FORWARD<Args_>(args_)...);
RT DTL_TYPE_FORWARD<Matrix_>(matrix_);
}
DVCC
ReplaceSome& clearPointX() NE {
this->start_x = 0;
RT *this;
}
DVCC
ReplaceSome& clearPointY() NE {
this->start_y = 0;
RT *this;
}
DVCC
ReplaceSome& clearWidth() NE {
this->width = 0;
RT *this;
}
DVCC
ReplaceSome& clearHeight() NE {
this->height = 0;
RT *this;
}
DVCC
ReplaceSome& clearPoint() NE {
this->clearPointX();
this->clearPointY();
RT *this;
}
DVCC
ReplaceSome& clearRange() NE {
this->clearPointX();
this->clearPointY();
this->clearWidth();
this->clearHeight();
RT *this;
}
DVCC
ReplaceSome& clear() NE {
this->clearRange();
RT *this;
}
DVCC
ReplaceSome& setPointX(CS IS start_x_) NE {
this->start_x = start_x_;
RT *this;
}
DVCC
ReplaceSome& setPointY(CS IS start_y_) NE {
this->start_y = start_y_;
RT *this;
}
DVCC
ReplaceSome& setWidth(CS IS width_) NE {
this->width = width_;
RT *this;
}
DVCC
ReplaceSome& setHeight(CS IS height_) NE {
this->height = height_;
RT *this;
}
DVCC
ReplaceSome& setPoint(CS IS point_) NE {
this->start_x = point_;
this->start_y = point_;
RT *this;
}
DVCC
ReplaceSome& setPoint(CS IS start_x_, CS IS start_y_) NE {
this->start_x = start_x_;
this->start_y = start_y_;
RT *this;
}
DVCC
ReplaceSome& setRange(CS IS start_x_, CS IS start_y_, CS IS length_) NE {
this->start_x = start_x_;
this->start_y = start_y_;
this->width = length_;
this->height = length_;
RT *this;
}
DVCC
ReplaceSome& setRange(CS IS start_x_, CS IS start_y_, CS IS width_, CS IS height_) NE {
this->start_x = start_x_;
this->start_y = start_y_;
this->width = width_;
this->height = height_;
RT *this;
}
DVCC
ReplaceSome& setRange(CS dtl::base::MatrixRange& matrix_range_) NE {
this->start_x = matrix_range_.x;
this->start_y = matrix_range_.y;
this->width = matrix_range_.w;
this->height = matrix_range_.h;
RT *this;
}
CE ReplaceSome() NE = default;
CE explicit ReplaceSome(CS dtl::type::size replace_num_) NE
:replace_num(replace_num_) {}
CE explicit ReplaceSome(CS dtl::type::size replace_num_, CS MI& after_value) NE
:after_value(after_value), replace_num(replace_num_) {}
TP<TN ...Args_>
explicit ReplaceSome(CS dtl::type::size replace_num_, CS MI & after_value, CS MI & first_before_value_, CS Args_ & ... second_and_subsequent_before_value_) NE
:after_value(after_value), replace_num(replace_num_) {
this->string_String(first_before_value_, second_and_subsequent_before_value_...);
DTL_TYPE_SORT(before_value.begin(), before_value.end());
}
CE explicit ReplaceSome(CS dtl::base::MatrixRange & matrix_range_) NE
:start_x(matrix_range_.x), start_y(matrix_range_.y),
width(matrix_range_.w), height(matrix_range_.h) {}
CE explicit ReplaceSome(CS dtl::base::MatrixRange& matrix_range_, CS dtl::type::size replace_num_) NE
:start_x(matrix_range_.x), start_y(matrix_range_.y),
width(matrix_range_.w), height(matrix_range_.h),
replace_num(replace_num_) {}
CE explicit ReplaceSome(CS dtl::base::MatrixRange & matrix_range_, CS dtl::type::size replace_num_, CS MI & after_value) NE
:start_x(matrix_range_.x), start_y(matrix_range_.y),
width(matrix_range_.w), height(matrix_range_.h),
after_value(after_value), replace_num(replace_num_) {}
TP<TN ...Args_>
explicit ReplaceSome(CS dtl::base::MatrixRange & matrix_range_, CS dtl::type::size replace_num_, CS MI & after_value, CS MI & first_before_value_, CS Args_ & ... second_and_subsequent_before_value_) NE
:start_x(matrix_range_.x), start_y(matrix_range_.y),
width(matrix_range_.w), height(matrix_range_.h),
after_value(after_value), replace_num(replace_num_) {
this->string_String(first_before_value_, second_and_subsequent_before_value_...);
DTL_TYPE_SORT(before_value.begin(), before_value.end());
}
};
}
}
#endif 
#endif 
#endif 
#endif 
#endif 
#endif